{"version":3,"sources":["../src/NotificationServicesController/processors/process-notifications.ts"],"names":[],"mappings":";;;;;;;;;;;;AAaA,IAAM,wBAAwB,CAC5B,MACgC,OAAO,OAAO,aAAa,EAAE,SAAS,EAAE,IAAI;AAE9E,IAAM,wBAAwB,CAC5B,MAEA,EAAE;AAUG,SAAS,oBACd,cACA,oBAA8B,CAAC,GAChB;AACf,QAAM,oBAAoB,CAAC,MAAa;AACtC,UAAM,OAAe,cAAc;AACnC,UAAM,IAAI,MAAM,4CAA4C,IAAI,EAAE;AAAA,EACpE;AAEA,MAAI,sBAAsB,YAAY,GAAG;AACvC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AACA,MAAE,SAAS,0BAA0B,GAAG,iBAAiB;AACzD,WAAO;AAAA,EACT;AAEA,MAAI,sBAAsB,YAAY,GAAG;AACvC,WAAO,2BAA2B,YAAsC;AAAA,EAC1E;AAEA,SAAO,kBAAkB,YAAqB;AAChD;AASO,SAAS,wBACd,cACA,oBAA8B,CAAC,GACJ;AAC3B,MAAI;AACF,UAAM,wBAAwB;AAAA,MAC5B;AAAA,MACA;AAAA,IACF;AACA,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF","sourcesContent":["import { TRIGGER_TYPES } from '../constants/notification-schema';\nimport type { FeatureAnnouncementRawNotification } from '../types/feature-announcement/feature-announcement';\nimport type {\n  INotification,\n  NotificationUnion,\n} from '../types/notification/notification';\nimport type { OnChainRawNotification } from '../types/on-chain-notification/on-chain-notification';\nimport {\n  isFeatureAnnouncementRead,\n  processFeatureAnnouncement,\n} from './process-feature-announcement';\nimport { processOnChainNotification } from './process-onchain-notifications';\n\nconst isOnChainNotification = (\n  n: NotificationUnion,\n): n is OnChainRawNotification => Object.values(TRIGGER_TYPES).includes(n.type);\n\nconst isFeatureAnnouncement = (\n  n: NotificationUnion,\n): n is FeatureAnnouncementRawNotification =>\n  n.type === TRIGGER_TYPES.FEATURES_ANNOUNCEMENT;\n\n/**\n * Process feature announcement and wallet notifications into a shared/normalised notification shape.\n * We can still differentiate notifications by the `type` property\n *\n * @param notification - a feature announcement or on chain notification\n * @param readNotifications - all read notifications currently\n * @returns a processed notification\n */\nexport function processNotification(\n  notification: NotificationUnion,\n  readNotifications: string[] = [],\n): INotification {\n  const exhaustedAllCases = (_: never) => {\n    const type: string = notification?.type;\n    throw new Error(`No processor found for notification kind ${type}`);\n  };\n\n  if (isFeatureAnnouncement(notification)) {\n    const n = processFeatureAnnouncement(\n      notification as FeatureAnnouncementRawNotification,\n    );\n    n.isRead = isFeatureAnnouncementRead(n, readNotifications);\n    return n;\n  }\n\n  if (isOnChainNotification(notification)) {\n    return processOnChainNotification(notification as OnChainRawNotification);\n  }\n\n  return exhaustedAllCases(notification as never);\n}\n\n/**\n * Safe version of processing a notification. Rather than throwing an error if failed to process, it will return the Notification or undefined\n *\n * @param notification - notification to processes\n * @param readNotifications - all read notifications currently\n * @returns a process notification or undefined if failed to process\n */\nexport function safeProcessNotification(\n  notification: NotificationUnion,\n  readNotifications: string[] = [],\n): INotification | undefined {\n  try {\n    const processedNotification = processNotification(\n      notification,\n      readNotifications,\n    );\n    return processedNotification;\n  } catch {\n    return undefined;\n  }\n}\n"]}