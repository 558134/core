{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";AAAA,SAAS,yBAAyB;AAClC;AAAA,EACE;AAAA,EACA;AAAA,OACK;AAEP,SAAS,OAAO,YAAY,gBAAgB;AAC5C,SAAS,gBAAgB;AAOzB,IAAM,QAAQ;AAOd,SAAS,gBAAgB,SAAiB,cAAsB;AAC9D,MAAI,CAAC,WAAW,OAAO,YAAY,YAAY,CAAC,kBAAkB,OAAO,GAAG;AAC1E,UAAM,IAAI;AAAA,MACR,YAAY,YAAY,cAAc,OAAO;AAAA,IAC/C;AAAA,EACF;AACF;AASO,SAAS,qBAAqB,MAAc;AACjD,MAAI;AACF,UAAM,WAAW,SAAS,IAAI;AAC9B,QAAI,SAAS,MAAM,KAAK,GAAG;AACzB,aAAO,MAAM,QAAQ;AAAA,IACvB;AAAA,EACF,SAAS,GAAG;AAAA,EAEZ;AACA,SAAO,WAAW,OAAO,KAAK,MAAM,MAAM,CAAC;AAC7C;AAQO,SAAS,wBAAwB,aAAoC;AAC1E,QAAM,EAAE,MAAM,KAAK,IAAI;AACvB,kBAAgB,MAAM,MAAM;AAE5B,MAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,UAAM,IAAI,MAAM,2BAA2B,IAAI,0BAA0B;AAAA,EAC3E;AACF;AAQO,SAAS,+BACd,aACA;AACA,kBAAgB,YAAY,MAAM,MAAM;AAExC,MAAI,CAAC,YAAY,QAAQ,CAAC,MAAM,QAAQ,YAAY,IAAI,GAAG;AACzD,UAAM,IAAI;AAAA;AAAA;AAAA,MAGR,2BAA2B,YAAY,IAAI;AAAA,IAC7C;AAAA,EACF;AAEA,MAAI;AAIF,uBAAmB,YAAY,IAAW;AAAA,EAC5C,SAAS,GAAG;AACV,UAAM,IAAI,MAAM,6BAA6B;AAAA,EAC/C;AACF;AASO,SAAS,iCACd,aACA,gBACA;AACA,kBAAgB,YAAY,MAAM,MAAM;AAExC,MACE,CAAC,YAAY,QACb,MAAM,QAAQ,YAAY,IAAI,KAC7B,OAAO,YAAY,SAAS,YAC3B,OAAO,YAAY,SAAS,UAC9B;AACA,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,MAAI;AACJ,MAAI,OAAO,YAAY,SAAS,UAAU;AACxC,WAAO,YAAY;AAAA,EACrB,OAAO;AACL,QAAI;AACF,aAAO,KAAK,MAAM,YAAY,IAAI;AAAA,IACpC,SAAS,GAAG;AACV,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAAA,EACF;AAEA,QAAM,aAAa,SAAS,MAAM,oBAAoB;AACtD,MAAI,WAAW,OAAO,SAAS,GAAG;AAChC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,MAAI,CAAC,gBAAgB;AACnB,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAChE;AAEA,MAAI,EAAE,QAAQ,IAAI,KAAK;AACvB,MAAI,SAAS;AACX,QAAI,OAAO,YAAY,UAAU;AAC/B,gBAAU,SAAS,SAAS,QAAQ,WAAW,IAAI,IAAI,KAAK,EAAE;AAAA,IAChE;AAEA,UAAM,gBAAgB,SAAS,gBAAgB,EAAE;AACjD,QAAI,OAAO,MAAM,aAAa,GAAG;AAC/B,YAAM,IAAI;AAAA;AAAA;AAAA,QAGR,qCAAqC,OAAO;AAAA,MAC9C;AAAA,IACF;AAEA,QAAI,YAAY,eAAe;AAC7B,YAAM,IAAI;AAAA;AAAA;AAAA,QAGR,qBAAqB,OAAO,oCAAoC,aAAa;AAAA,MAC/E;AAAA,IACF;AAAA,EACF;AACF;AAQO,SAAS,uCACd,aACA;AACA,QAAM,EAAE,KAAK,IAAI;AACjB,kBAAgB,MAAM,MAAM;AAC9B;AAQO,SAAS,6BACd,aACA;AACA,QAAM,EAAE,KAAK,IAAI;AACjB,kBAAgB,MAAM,MAAM;AAC9B","sourcesContent":["import { isValidHexAddress } from '@metamask/controller-utils';\nimport {\n  TYPED_MESSAGE_SCHEMA,\n  typedSignatureHash,\n} from '@metamask/eth-sig-util';\nimport type { Hex } from '@metamask/utils';\nimport { add0x, bytesToHex, remove0x } from '@metamask/utils';\nimport { validate } from 'jsonschema';\n\nimport type { DecryptMessageParams } from './DecryptMessageManager';\nimport type { EncryptionPublicKeyParams } from './EncryptionPublicKeyManager';\nimport type { PersonalMessageParams } from './PersonalMessageManager';\nimport type { TypedMessageParams } from './TypedMessageManager';\n\nconst hexRe = /^[0-9A-Fa-f]+$/gu;\n/**\n * Validates an address string and throws in the event of any validation error.\n *\n * @param address - The address to validate.\n * @param propertyName - The name of the property source to use in the error message.\n */\nfunction validateAddress(address: string, propertyName: string) {\n  if (!address || typeof address !== 'string' || !isValidHexAddress(address)) {\n    throw new Error(\n      `Invalid \"${propertyName}\" address: ${address} must be a valid string.`,\n    );\n  }\n}\n\n/**\n * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if\n * it is already formatted as a hex.\n *\n * @param data - The buffer data to convert to a hex.\n * @returns A hex string conversion of the buffer data.\n */\nexport function normalizeMessageData(data: string) {\n  try {\n    const stripped = remove0x(data);\n    if (stripped.match(hexRe)) {\n      return add0x(stripped);\n    }\n  } catch (e) {\n    /* istanbul ignore next */\n  }\n  return bytesToHex(Buffer.from(data, 'utf8'));\n}\n\n/**\n * Validates a PersonalMessageParams objects for required properties and throws in\n * the event of any validation error.\n *\n * @param messageData - PersonalMessageParams object to validate.\n */\nexport function validateSignMessageData(messageData: PersonalMessageParams) {\n  const { from, data } = messageData;\n  validateAddress(from, 'from');\n\n  if (!data || typeof data !== 'string') {\n    throw new Error(`Invalid message \"data\": ${data} must be a valid string.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V1.\n *\n * @param messageData - TypedMessageParams object to validate.\n */\nexport function validateTypedSignMessageDataV1(\n  messageData: TypedMessageParams,\n) {\n  validateAddress(messageData.from, 'from');\n\n  if (!messageData.data || !Array.isArray(messageData.data)) {\n    throw new Error(\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n\n  try {\n    // typedSignatureHash will throw if the data is invalid.\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typedSignatureHash(messageData.data as any);\n  } catch (e) {\n    throw new Error(`Expected EIP712 typed data.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V3.\n *\n * @param messageData - TypedMessageParams object to validate.\n * @param currentChainId - The current chainId.\n */\nexport function validateTypedSignMessageDataV3V4(\n  messageData: TypedMessageParams,\n  currentChainId: Hex | undefined,\n) {\n  validateAddress(messageData.from, 'from');\n\n  if (\n    !messageData.data ||\n    Array.isArray(messageData.data) ||\n    (typeof messageData.data !== 'object' &&\n      typeof messageData.data !== 'string')\n  ) {\n    throw new Error(\n      `Invalid message \"data\": Must be a valid string or object.`,\n    );\n  }\n\n  let data;\n  if (typeof messageData.data === 'object') {\n    data = messageData.data;\n  } else {\n    try {\n      data = JSON.parse(messageData.data);\n    } catch (e) {\n      throw new Error('Data must be passed as a valid JSON string.');\n    }\n  }\n\n  const validation = validate(data, TYPED_MESSAGE_SCHEMA);\n  if (validation.errors.length > 0) {\n    throw new Error(\n      'Data must conform to EIP-712 schema. See https://git.io/fNtcx.',\n    );\n  }\n\n  if (!currentChainId) {\n    throw new Error('Current chainId cannot be null or undefined.');\n  }\n\n  let { chainId } = data.domain;\n  if (chainId) {\n    if (typeof chainId === 'string') {\n      chainId = parseInt(chainId, chainId.startsWith('0x') ? 16 : 10);\n    }\n\n    const activeChainId = parseInt(currentChainId, 16);\n    if (Number.isNaN(activeChainId)) {\n      throw new Error(\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Cannot sign messages for chainId \"${chainId}\", because MetaMask is switching networks.`,\n      );\n    }\n\n    if (chainId !== activeChainId) {\n      throw new Error(\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Provided chainId \"${chainId}\" must match the active chainId \"${activeChainId}\"`,\n      );\n    }\n  }\n}\n\n/**\n * Validates messageData for the eth_getEncryptionPublicKey message and throws in\n * the event of any validation error.\n *\n * @param messageData - address string to validate.\n */\nexport function validateEncryptionPublicKeyMessageData(\n  messageData: EncryptionPublicKeyParams,\n) {\n  const { from } = messageData;\n  validateAddress(from, 'from');\n}\n\n/**\n * Validates messageData for the eth_decrypt message and throws in\n * the event of any validation error.\n *\n * @param messageData - address string to validate.\n */\nexport function validateDecryptedMessageData(\n  messageData: DecryptMessageParams,\n) {\n  const { from } = messageData;\n  validateAddress(from, 'from');\n}\n"]}