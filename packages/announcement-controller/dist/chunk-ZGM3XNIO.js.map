{"version":3,"sources":["../src/AnnouncementController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAKA,SAAS,sBAAsB;AAkD/B,IAAM,iBAAiB;AAEvB,IAAM,eAAe;AAAA,EACnB,eAAe,CAAC;AAClB;AAEA,IAAM,WAAW;AAAA,EACf,eAAe;AAAA,IACb,SAAS;AAAA,IACT,WAAW;AAAA,EACb;AACF;AAlEA;AA+EO,IAAM,yBAAN,cAAqC,eAI1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIG;AACD,UAAM,cAAc,EAAE,GAAG,cAAc,GAAG,MAAM;AAChD,UAAM,EAAE,WAAW,UAAU,MAAM,gBAAgB,OAAO,YAAY,CAAC;AAYzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXE,0BAAK,wCAAL,WAAuB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAuBA,cAAoB;AAClB,SAAK,OAAO,CAAC,EAAE,cAAc,MAAM;AACjC,iBAAW,gBAAgB,OAAO,OAAO,aAAa,GAAG;AACvD,qBAAa,UAAU;AAAA,MACzB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,WAAqC;AAChD,SAAK,OAAO,CAAC,EAAE,cAAc,MAAM;AACjC,iBAAW,MAAM,OAAO,KAAK,SAAS,EAAE,IAAI,MAAM,GAAG;AACnD,sBAAc,EAAE,EAAE,UAAU,UAAU,EAAE;AAAA,MAC1C;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAlCE;AAAA,sBAAiB,SAAC,kBAAyC;AACzD,OAAK,OAAO,CAAC,UAAU;AACrB,WAAO,OAAO,gBAAgB,EAAE,QAAQ,CAAC,iBAA+B;AACtE,YAAM,cAAc,aAAa,EAAE,IAAI,MAAM,cAC3C,aAAa,EACf,KAAK,EAAE,GAAG,cAAc,SAAS,MAAM;AAAA,IACzC,CAAC;AAAA,EACH,CAAC;AACH","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\n\ntype ViewedAnnouncement = {\n  [id: number]: boolean;\n};\n\ntype Announcement = {\n  id: number;\n  date: string;\n};\n\n/**\n * A map of announcement ids to Announcement objects\n */\nexport type AnnouncementMap = {\n  [id: number]: Announcement;\n};\n\ntype StateAnnouncement = Announcement & { isShown: boolean };\n\n/**\n * A map of announcement ids to StateAnnouncement objects\n */\nexport type StateAnnouncementMap = {\n  [id: number]: StateAnnouncement;\n};\n\n/**\n * Announcement state will hold all the seen and unseen announcements\n * that are still active\n */\nexport type AnnouncementControllerState = {\n  announcements: StateAnnouncementMap;\n};\n\nexport type AnnouncementControllerActions =\n  AnnouncementControllerGetStateAction;\nexport type AnnouncementControllerEvents =\n  AnnouncementControllerStateChangeEvent;\n\nexport type AnnouncementControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  AnnouncementControllerState\n>;\n\nexport type AnnouncementControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  AnnouncementControllerState\n>;\n\nconst controllerName = 'AnnouncementController';\n\nconst defaultState = {\n  announcements: {},\n};\n\nconst metadata = {\n  announcements: {\n    persist: true,\n    anonymous: true,\n  },\n};\n\nexport type AnnouncementControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AnnouncementControllerActions,\n  AnnouncementControllerEvents,\n  never,\n  never\n>;\n\n/**\n * Controller for managing in-app announcements.\n */\nexport class AnnouncementController extends BaseController<\n  typeof controllerName,\n  AnnouncementControllerState,\n  AnnouncementControllerMessenger\n> {\n  /**\n   * Creates a AnnouncementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   * @param args.allAnnouncements - Announcements to be passed through to #addAnnouncements\n   */\n  constructor({\n    messenger,\n    state,\n    allAnnouncements,\n  }: {\n    messenger: AnnouncementControllerMessenger;\n    state?: AnnouncementControllerState;\n    allAnnouncements: AnnouncementMap;\n  }) {\n    const mergedState = { ...defaultState, ...state };\n    super({ messenger, metadata, name: controllerName, state: mergedState });\n    this.#addAnnouncements(allAnnouncements);\n  }\n\n  /**\n   * Compares the announcements in state with the announcements from file\n   * to check if there are any new announcements\n   * if yes, the new announcement will be added to the state with a flag indicating\n   * that the announcement is not seen by the user.\n   *\n   * @param allAnnouncements - all announcements to compare with the announcements from state\n   */\n  #addAnnouncements(allAnnouncements: AnnouncementMap): void {\n    this.update((state) => {\n      Object.values(allAnnouncements).forEach((announcement: Announcement) => {\n        state.announcements[announcement.id] = state.announcements[\n          announcement.id\n        ] ?? { ...announcement, isShown: false };\n      });\n    });\n  }\n\n  /**\n   * Resets the isShown status for all announcements\n   */\n  resetViewed(): void {\n    this.update(({ announcements }) => {\n      for (const announcement of Object.values(announcements)) {\n        announcement.isShown = false;\n      }\n    });\n  }\n\n  /**\n   * Updates the status of the status of the specified announcements\n   * once it is read by the user.\n   *\n   * @param viewedIds - The announcement IDs to mark as viewed.\n   */\n  updateViewed(viewedIds: ViewedAnnouncement): void {\n    this.update(({ announcements }) => {\n      for (const id of Object.keys(viewedIds).map(Number)) {\n        announcements[id].isShown = viewedIds[id];\n      }\n    });\n  }\n}\n"]}