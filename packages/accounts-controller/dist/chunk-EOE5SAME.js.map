{"version":3,"sources":["../src/AccountsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { SnapKeyring } from '@metamask/eth-snap-keyring';\nimport type { InternalAccount } from '@metamask/keyring-api';\nimport {\n  EthAccountType,\n  EthMethod,\n  isEvmAccountType,\n} from '@metamask/keyring-api';\nimport { KeyringTypes } from '@metamask/keyring-controller';\nimport type {\n  KeyringControllerState,\n  KeyringControllerGetKeyringForAccountAction,\n  KeyringControllerGetKeyringsByTypeAction,\n  KeyringControllerGetAccountsAction,\n  KeyringControllerStateChangeEvent,\n} from '@metamask/keyring-controller';\nimport type {\n  SnapControllerState,\n  SnapStateChange,\n} from '@metamask/snaps-controllers';\nimport type { SnapId } from '@metamask/snaps-sdk';\nimport type { Snap } from '@metamask/snaps-utils';\nimport type { CaipChainId } from '@metamask/utils';\nimport {\n  type Keyring,\n  type Json,\n  isCaipChainId,\n  parseCaipChainId,\n} from '@metamask/utils';\nimport type { Draft } from 'immer';\n\nimport {\n  getUUIDFromAddressOfNormalAccount,\n  isNormalKeyringType,\n  keyringTypeToName,\n} from './utils';\n\nconst controllerName = 'AccountsController';\n\nexport type AccountId = string;\n\nexport type AccountsControllerState = {\n  internalAccounts: {\n    accounts: Record<AccountId, InternalAccount>;\n    selectedAccount: string; // id of the selected account\n  };\n};\n\nexport type AccountsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  AccountsControllerState\n>;\n\nexport type AccountsControllerSetSelectedAccountAction = {\n  type: `${typeof controllerName}:setSelectedAccount`;\n  handler: AccountsController['setSelectedAccount'];\n};\n\nexport type AccountsControllerSetAccountNameAction = {\n  type: `${typeof controllerName}:setAccountName`;\n  handler: AccountsController['setAccountName'];\n};\n\nexport type AccountsControllerListAccountsAction = {\n  type: `${typeof controllerName}:listAccounts`;\n  handler: AccountsController['listAccounts'];\n};\n\nexport type AccountsControllerListMultichainAccountsAction = {\n  type: `${typeof controllerName}:listMultichainAccounts`;\n  handler: AccountsController['listMultichainAccounts'];\n};\n\nexport type AccountsControllerUpdateAccountsAction = {\n  type: `${typeof controllerName}:updateAccounts`;\n  handler: AccountsController['updateAccounts'];\n};\n\nexport type AccountsControllerGetSelectedAccountAction = {\n  type: `${typeof controllerName}:getSelectedAccount`;\n  handler: AccountsController['getSelectedAccount'];\n};\n\nexport type AccountsControllerGetSelectedMultichainAccountAction = {\n  type: `${typeof controllerName}:getSelectedMultichainAccount`;\n  handler: AccountsController['getSelectedMultichainAccount'];\n};\n\nexport type AccountsControllerGetAccountByAddressAction = {\n  type: `${typeof controllerName}:getAccountByAddress`;\n  handler: AccountsController['getAccountByAddress'];\n};\n\nexport type AccountsControllerGetNextAvailableAccountNameAction = {\n  type: `${typeof controllerName}:getNextAvailableAccountName`;\n  handler: AccountsController['getNextAvailableAccountName'];\n};\n\nexport type AccountsControllerGetAccountAction = {\n  type: `${typeof controllerName}:getAccount`;\n  handler: AccountsController['getAccount'];\n};\n\nexport type AllowedActions =\n  | KeyringControllerGetKeyringForAccountAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetAccountsAction;\n\nexport type AccountsControllerActions =\n  | AccountsControllerGetStateAction\n  | AccountsControllerSetSelectedAccountAction\n  | AccountsControllerListAccountsAction\n  | AccountsControllerListMultichainAccountsAction\n  | AccountsControllerSetAccountNameAction\n  | AccountsControllerUpdateAccountsAction\n  | AccountsControllerGetAccountByAddressAction\n  | AccountsControllerGetSelectedAccountAction\n  | AccountsControllerGetNextAvailableAccountNameAction\n  | AccountsControllerGetAccountAction\n  | AccountsControllerGetSelectedMultichainAccountAction;\n\nexport type AccountsControllerChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  AccountsControllerState\n>;\n\nexport type AccountsControllerSelectedAccountChangeEvent = {\n  type: `${typeof controllerName}:selectedAccountChange`;\n  payload: [InternalAccount];\n};\n\nexport type AccountsControllerSelectedEvmAccountChangeEvent = {\n  type: `${typeof controllerName}:selectedEvmAccountChange`;\n  payload: [InternalAccount];\n};\n\nexport type AccountsControllerAccountAddedEvent = {\n  type: `${typeof controllerName}:accountAdded`;\n  payload: [InternalAccount];\n};\n\nexport type AccountsControllerAccountRemovedEvent = {\n  type: `${typeof controllerName}:accountRemoved`;\n  payload: [AccountId];\n};\n\nexport type AllowedEvents = SnapStateChange | KeyringControllerStateChangeEvent;\n\nexport type AccountsControllerEvents =\n  | AccountsControllerChangeEvent\n  | AccountsControllerSelectedAccountChangeEvent\n  | AccountsControllerSelectedEvmAccountChangeEvent\n  | AccountsControllerAccountAddedEvent\n  | AccountsControllerAccountRemovedEvent;\n\nexport type AccountsControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AccountsControllerActions | AllowedActions,\n  AccountsControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\ntype AddressAndKeyringTypeObject = {\n  address: string;\n  type: string;\n};\n\nconst accountsControllerMetadata = {\n  internalAccounts: {\n    persist: true,\n    anonymous: false,\n  },\n};\n\nconst defaultState: AccountsControllerState = {\n  internalAccounts: {\n    accounts: {},\n    selectedAccount: '',\n  },\n};\n\nexport const EMPTY_ACCOUNT = {\n  id: '',\n  address: '',\n  options: {},\n  methods: [],\n  type: EthAccountType.Eoa,\n  metadata: {\n    name: '',\n    keyring: {\n      type: '',\n    },\n    importTime: 0,\n  },\n};\n\n/**\n * Controller that manages internal accounts.\n * The accounts controller is responsible for creating and managing internal accounts.\n * It also provides convenience methods for accessing and updating the internal accounts.\n * The accounts controller also listens for keyring state changes and updates the internal accounts accordingly.\n * The accounts controller also listens for snap state changes and updates the internal accounts accordingly.\n *\n */\nexport class AccountsController extends BaseController<\n  typeof controllerName,\n  AccountsControllerState,\n  AccountsControllerMessenger\n> {\n  /**\n   * Constructor for AccountsController.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The messenger object.\n   * @param options.state - Initial state to set on this controller\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: AccountsControllerMessenger;\n    state: AccountsControllerState;\n  }) {\n    super({\n      messenger,\n      name: controllerName,\n      metadata: accountsControllerMetadata,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.messagingSystem.subscribe(\n      'SnapController:stateChange',\n      (snapStateState) => this.#handleOnSnapStateChange(snapStateState),\n    );\n\n    this.messagingSystem.subscribe(\n      'KeyringController:stateChange',\n      (keyringState) => this.#handleOnKeyringStateChange(keyringState),\n    );\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Returns the internal account object for the given account ID, if it exists.\n   *\n   * @param accountId - The ID of the account to retrieve.\n   * @returns The internal account object, or undefined if the account does not exist.\n   */\n  getAccount(accountId: string): InternalAccount | undefined {\n    return this.state.internalAccounts.accounts[accountId];\n  }\n\n  /**\n   * Returns an array of all evm internal accounts.\n   *\n   * @returns An array of InternalAccount objects.\n   */\n  listAccounts(): InternalAccount[] {\n    const accounts = Object.values(this.state.internalAccounts.accounts);\n    return accounts.filter((account) => isEvmAccountType(account.type));\n  }\n\n  /**\n   * Returns an array of all internal accounts.\n   *\n   * @param chainId - The chain ID.\n   * @returns An array of InternalAccount objects.\n   */\n  listMultichainAccounts(chainId?: CaipChainId): InternalAccount[] {\n    const accounts = Object.values(this.state.internalAccounts.accounts);\n    if (!chainId) {\n      return accounts;\n    }\n\n    if (!isCaipChainId(chainId)) {\n      throw new Error(`Invalid CAIP-2 chain ID: ${String(chainId)}`);\n    }\n\n    return accounts.filter((account) =>\n      this.#isAccountCompatibleWithChain(account, chainId),\n    );\n  }\n\n  /**\n   * Returns the internal account object for the given account ID.\n   *\n   * @param accountId - The ID of the account to retrieve.\n   * @returns The internal account object.\n   * @throws An error if the account ID is not found.\n   */\n  getAccountExpect(accountId: string): InternalAccount {\n    const account = this.getAccount(accountId);\n    if (account === undefined) {\n      throw new Error(`Account Id \"${accountId}\" not found`);\n    }\n    return account;\n  }\n\n  /**\n   * Returns the last selected EVM account.\n   *\n   * @returns The selected internal account.\n   */\n  getSelectedAccount(): InternalAccount {\n    // Edge case where the extension is setup but the srp is not yet created\n    // certain ui elements will query the selected address before any accounts are created.\n    if (this.state.internalAccounts.selectedAccount === '') {\n      return EMPTY_ACCOUNT;\n    }\n\n    const selectedAccount = this.getAccountExpect(\n      this.state.internalAccounts.selectedAccount,\n    );\n    if (isEvmAccountType(selectedAccount.type)) {\n      return selectedAccount;\n    }\n\n    const accounts = this.listAccounts();\n\n    if (!accounts.length) {\n      // ! Should never reach this.\n      throw new Error('No EVM accounts');\n    }\n\n    // This will never be undefined because we have already checked if accounts.length is > 0\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#getLastSelectedAccount(accounts)!;\n  }\n\n  /**\n   * __WARNING The return value may be undefined if there isn't an account for that chain id.__\n   *\n   * Retrieves the last selected account by chain ID.\n   *\n   * @param chainId - The chain ID to filter the accounts.\n   * @returns The last selected account compatible with the specified chain ID or undefined.\n   */\n  getSelectedMultichainAccount(\n    chainId?: CaipChainId,\n  ): InternalAccount | undefined {\n    // Edge case where the extension is setup but the srp is not yet created\n    // certain ui elements will query the selected address before any accounts are created.\n    if (this.state.internalAccounts.selectedAccount === '') {\n      return EMPTY_ACCOUNT;\n    }\n\n    if (!chainId) {\n      return this.getAccountExpect(this.state.internalAccounts.selectedAccount);\n    }\n\n    if (!isCaipChainId(chainId)) {\n      throw new Error(`Invalid CAIP-2 chain ID: ${chainId as string}`);\n    }\n\n    const accounts = Object.values(this.state.internalAccounts.accounts).filter(\n      (account) => this.#isAccountCompatibleWithChain(account, chainId),\n    );\n\n    return this.#getLastSelectedAccount(accounts);\n  }\n\n  /**\n   * Returns the account with the specified address.\n   * ! This method will only return the first account that matches the address\n   * @param address - The address of the account to retrieve.\n   * @returns The account with the specified address, or undefined if not found.\n   */\n  getAccountByAddress(address: string): InternalAccount | undefined {\n    return this.listMultichainAccounts().find(\n      (account) => account.address.toLowerCase() === address.toLowerCase(),\n    );\n  }\n\n  /**\n   * Sets the selected account by its ID.\n   *\n   * @param accountId - The ID of the account to be selected.\n   */\n  setSelectedAccount(accountId: string): void {\n    const account = this.getAccountExpect(accountId);\n\n    this.update((currentState: Draft<AccountsControllerState>) => {\n      currentState.internalAccounts.accounts[account.id].metadata.lastSelected =\n        Date.now();\n      currentState.internalAccounts.selectedAccount = account.id;\n    });\n\n    this.#publishAccountChangeEvent(account);\n  }\n\n  /**\n   * Sets the name of the account with the given ID.\n   *\n   * @param accountId - The ID of the account to set the name for.\n   * @param accountName - The new name for the account.\n   * @throws An error if an account with the same name already exists.\n   */\n  setAccountName(accountId: string, accountName: string): void {\n    const account = this.getAccountExpect(accountId);\n\n    if (\n      this.listMultichainAccounts().find(\n        (internalAccount) =>\n          internalAccount.metadata.name === accountName &&\n          internalAccount.id !== accountId,\n      )\n    ) {\n      throw new Error('Account name already exists');\n    }\n\n    this.update((currentState: Draft<AccountsControllerState>) => {\n      const internalAccount = {\n        ...account,\n        metadata: { ...account.metadata, name: accountName },\n      };\n      // Do not remove this comment - This error is flaky: Comment out or restore the `ts-expect-error` directive below as needed.\n      // // @ts-expect-error Known issue - `Json` causes recursive error in immer `Draft`/`WritableDraft` types\n      currentState.internalAccounts.accounts[accountId] = internalAccount;\n    });\n  }\n\n  /**\n   * Updates the internal accounts list by retrieving normal and snap accounts,\n   * removing duplicates, and updating the metadata of each account.\n   *\n   * @returns A Promise that resolves when the accounts have been updated.\n   */\n  async updateAccounts(): Promise<void> {\n    const snapAccounts = await this.#listSnapAccounts();\n    const normalAccounts = await this.#listNormalAccounts();\n\n    // keyring type map.\n    const keyringTypes = new Map<string, number>();\n    const previousAccounts = this.state.internalAccounts.accounts;\n\n    const accounts: Record<string, InternalAccount> = [\n      ...normalAccounts,\n      ...snapAccounts,\n    ].reduce((internalAccountMap, internalAccount) => {\n      const keyringTypeName = keyringTypeToName(\n        internalAccount.metadata.keyring.type,\n      );\n      const keyringAccountIndex = keyringTypes.get(keyringTypeName) ?? 0;\n      if (keyringAccountIndex) {\n        keyringTypes.set(keyringTypeName, keyringAccountIndex + 1);\n      } else {\n        keyringTypes.set(keyringTypeName, 1);\n      }\n\n      const existingAccount = previousAccounts[internalAccount.id];\n\n      internalAccountMap[internalAccount.id] = {\n        ...internalAccount,\n\n        metadata: {\n          ...internalAccount.metadata,\n          name:\n            this.#populateExistingMetadata(existingAccount?.id, 'name') ??\n            `${keyringTypeName} ${keyringAccountIndex + 1}`,\n          importTime:\n            this.#populateExistingMetadata(existingAccount?.id, 'importTime') ??\n            Date.now(),\n          lastSelected:\n            this.#populateExistingMetadata(\n              existingAccount?.id,\n              'lastSelected',\n            ) ?? 0,\n        },\n      };\n\n      return internalAccountMap;\n    }, {} as Record<string, InternalAccount>);\n\n    this.update((currentState: Draft<AccountsControllerState>) => {\n      currentState.internalAccounts.accounts = accounts;\n    });\n  }\n\n  /**\n   * Loads the backup state of the accounts controller.\n   *\n   * @param backup - The backup state to load.\n   */\n  loadBackup(backup: AccountsControllerState): void {\n    if (backup.internalAccounts) {\n      this.update((currentState: Draft<AccountsControllerState>) => {\n        currentState.internalAccounts = backup.internalAccounts;\n      });\n    }\n  }\n\n  /**\n   * Generates an internal account for a non-Snap account.\n   * @param address - The address of the account.\n   * @param type - The type of the account.\n   * @returns The generated internal account.\n   */\n  #generateInternalAccountForNonSnapAccount(\n    address: string,\n    type: string,\n  ): InternalAccount {\n    return {\n      id: getUUIDFromAddressOfNormalAccount(address),\n      address,\n      options: {},\n      methods: [\n        EthMethod.PersonalSign,\n        EthMethod.Sign,\n        EthMethod.SignTransaction,\n        EthMethod.SignTypedDataV1,\n        EthMethod.SignTypedDataV3,\n        EthMethod.SignTypedDataV4,\n      ],\n      type: EthAccountType.Eoa,\n      metadata: {\n        name: '',\n        importTime: Date.now(),\n        keyring: {\n          type,\n        },\n      },\n    };\n  }\n\n  /**\n   * Returns a list of internal accounts created using the SnapKeyring.\n   *\n   * @returns A promise that resolves to an array of InternalAccount objects.\n   */\n  async #listSnapAccounts(): Promise<InternalAccount[]> {\n    const [snapKeyring] = this.messagingSystem.call(\n      'KeyringController:getKeyringsByType',\n      SnapKeyring.type,\n    );\n    // snap keyring is not available until the first account is created in the keyring controller\n    if (!snapKeyring) {\n      return [];\n    }\n\n    const snapAccounts = (snapKeyring as SnapKeyring).listAccounts();\n\n    return snapAccounts;\n  }\n\n  /**\n   * Returns a list of normal accounts.\n   * Note: listNormalAccounts is a temporary method until the keyrings all implement the InternalAccount interface.\n   * Once all keyrings implement the InternalAccount interface, this method can be removed and getAccounts can be used instead.\n   *\n   * @returns A Promise that resolves to an array of InternalAccount objects.\n   */\n  async #listNormalAccounts(): Promise<InternalAccount[]> {\n    const addresses = await this.messagingSystem.call(\n      'KeyringController:getAccounts',\n    );\n    const internalAccounts: InternalAccount[] = [];\n    for (const address of addresses) {\n      const keyring = await this.messagingSystem.call(\n        'KeyringController:getKeyringForAccount',\n        address,\n      );\n\n      const keyringType = (keyring as Keyring<Json>).type;\n      if (!isNormalKeyringType(keyringType as KeyringTypes)) {\n        // We only consider \"normal accounts\" here, so keep looping\n        continue;\n      }\n\n      const id = getUUIDFromAddressOfNormalAccount(address);\n\n      internalAccounts.push({\n        id,\n        address,\n        options: {},\n        methods: [\n          EthMethod.PersonalSign,\n          EthMethod.Sign,\n          EthMethod.SignTransaction,\n          EthMethod.SignTypedDataV1,\n          EthMethod.SignTypedDataV3,\n          EthMethod.SignTypedDataV4,\n        ],\n        type: EthAccountType.Eoa,\n        metadata: {\n          name: this.#populateExistingMetadata(id, 'name') ?? '',\n          importTime:\n            this.#populateExistingMetadata(id, 'importTime') ?? Date.now(),\n          lastSelected: this.#populateExistingMetadata(id, 'lastSelected') ?? 0,\n          keyring: {\n            type: (keyring as Keyring<Json>).type,\n          },\n        },\n      });\n    }\n\n    return internalAccounts;\n  }\n\n  /**\n   * Handles changes in the keyring state, specifically when new accounts are added or removed.\n   *\n   * @param keyringState - The new state of the keyring controller.\n   */\n  #handleOnKeyringStateChange(keyringState: KeyringControllerState): void {\n    // check if there are any new accounts added\n    // TODO: change when accountAdded event is added to the keyring controller\n\n    // We check for keyrings length to be greater than 0 because the extension client may try execute\n    // submit password twice and clear the keyring state.\n    // https://github.com/MetaMask/KeyringController/blob/2d73a4deed8d013913f6ef0c9f5c0bb7c614f7d3/src/KeyringController.ts#L910\n    if (keyringState.isUnlocked && keyringState.keyrings.length > 0) {\n      const updatedNormalKeyringAddresses: AddressAndKeyringTypeObject[] = [];\n      const updatedSnapKeyringAddresses: AddressAndKeyringTypeObject[] = [];\n\n      for (const keyring of keyringState.keyrings) {\n        if (keyring.type === KeyringTypes.snap) {\n          updatedSnapKeyringAddresses.push(\n            ...keyring.accounts.map((address) => {\n              return {\n                address,\n                type: keyring.type,\n              };\n            }),\n          );\n        } else {\n          updatedNormalKeyringAddresses.push(\n            ...keyring.accounts.map((address) => {\n              return {\n                address,\n                type: keyring.type,\n              };\n            }),\n          );\n        }\n      }\n\n      const { previousNormalInternalAccounts, previousSnapInternalAccounts } =\n        this.listMultichainAccounts().reduce(\n          (accumulator, account) => {\n            if (account.metadata.keyring.type === KeyringTypes.snap) {\n              accumulator.previousSnapInternalAccounts.push(account);\n            } else {\n              accumulator.previousNormalInternalAccounts.push(account);\n            }\n            return accumulator;\n          },\n          {\n            previousNormalInternalAccounts: [] as InternalAccount[],\n            previousSnapInternalAccounts: [] as InternalAccount[],\n          },\n        );\n\n      const addedAccounts: AddressAndKeyringTypeObject[] = [];\n      const deletedAccounts: InternalAccount[] = [];\n\n      // snap account ids are random uuid while normal accounts\n      // are determininistic based on the address\n\n      // ^NOTE: This will be removed when normal accounts also implement internal accounts\n      // finding all the normal accounts that were added\n      for (const account of updatedNormalKeyringAddresses) {\n        if (\n          !this.state.internalAccounts.accounts[\n            getUUIDFromAddressOfNormalAccount(account.address)\n          ]\n        ) {\n          addedAccounts.push(account);\n        }\n      }\n\n      // finding all the snap accounts that were added\n      for (const account of updatedSnapKeyringAddresses) {\n        if (\n          !previousSnapInternalAccounts.find(\n            (internalAccount: InternalAccount) =>\n              internalAccount.address.toLowerCase() ===\n              account.address.toLowerCase(),\n          )\n        ) {\n          addedAccounts.push(account);\n        }\n      }\n\n      // finding all the normal accounts that were deleted\n      for (const account of previousNormalInternalAccounts) {\n        if (\n          !updatedNormalKeyringAddresses.find(\n            ({ address }) =>\n              address.toLowerCase() === account.address.toLowerCase(),\n          )\n        ) {\n          deletedAccounts.push(account);\n        }\n      }\n\n      // finding all the snap accounts that were deleted\n      for (const account of previousSnapInternalAccounts) {\n        if (\n          !updatedSnapKeyringAddresses.find(\n            ({ address }) =>\n              address.toLowerCase() === account.address.toLowerCase(),\n          )\n        ) {\n          deletedAccounts.push(account);\n        }\n      }\n\n      this.update((currentState: Draft<AccountsControllerState>) => {\n        if (deletedAccounts.length > 0) {\n          for (const account of deletedAccounts) {\n            currentState.internalAccounts.accounts = this.#handleAccountRemoved(\n              currentState.internalAccounts.accounts,\n              account.id,\n            );\n          }\n        }\n\n        if (addedAccounts.length > 0) {\n          for (const account of addedAccounts) {\n            currentState.internalAccounts.accounts =\n              this.#handleNewAccountAdded(\n                currentState.internalAccounts.accounts,\n                account,\n              );\n          }\n        }\n\n        // We don't use list accounts because it is not the updated state yet.\n        const existingAccounts = Object.values(\n          currentState.internalAccounts.accounts,\n        );\n\n        // handle if the selected account was deleted\n        if (\n          !currentState.internalAccounts.accounts[\n            this.state.internalAccounts.selectedAccount\n          ]\n        ) {\n          // if currently selected account is undefined and there are no accounts\n          // it mean the keyring was reinitialized.\n          if (existingAccounts.length === 0) {\n            currentState.internalAccounts.selectedAccount = '';\n            return;\n          }\n\n          // at this point, we know that `existingAccounts.length` is > 0, so\n          // `accountToSelect` won't be `undefined`!\n          const [accountToSelect] = existingAccounts.sort(\n            (accountA, accountB) => {\n              // sort by lastSelected descending\n              return (\n                (accountB.metadata.lastSelected ?? 0) -\n                (accountA.metadata.lastSelected ?? 0)\n              );\n            },\n          );\n          currentState.internalAccounts.selectedAccount = accountToSelect.id;\n          currentState.internalAccounts.accounts[\n            accountToSelect.id\n          ].metadata.lastSelected = this.#getLastSelectedIndex();\n\n          this.#publishAccountChangeEvent(accountToSelect);\n        }\n      });\n    }\n  }\n\n  /**\n   * Handles the change in SnapControllerState by updating the metadata of accounts that have a snap enabled.\n   *\n   * @param snapState - The new SnapControllerState.\n   */\n  #handleOnSnapStateChange(snapState: SnapControllerState) {\n    // only check if snaps changed in status\n    const { snaps } = snapState;\n    const accounts = this.listMultichainAccounts().filter(\n      (account) => account.metadata.snap,\n    );\n\n    this.update((currentState: Draft<AccountsControllerState>) => {\n      accounts.forEach((account) => {\n        const currentAccount =\n          currentState.internalAccounts.accounts[account.id];\n        if (currentAccount.metadata.snap) {\n          const snapId = currentAccount.metadata.snap.id;\n          const storedSnap: Snap = snaps[snapId as SnapId];\n          if (storedSnap) {\n            currentAccount.metadata.snap.enabled =\n              storedSnap.enabled && !storedSnap.blocked;\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns the list of accounts for a given keyring type.\n   * @param keyringType - The type of keyring.\n   * @param accounts - Accounts to filter by keyring type.\n   * @returns The list of accounts associcated with this keyring type.\n   */\n  #getAccountsByKeyringType(keyringType: string, accounts?: InternalAccount[]) {\n    return (accounts ?? this.listMultichainAccounts()).filter(\n      (internalAccount) => {\n        // We do consider `hd` and `simple` keyrings to be of same type. So we check those 2 types\n        // to group those accounts together!\n        if (\n          keyringType === KeyringTypes.hd ||\n          keyringType === KeyringTypes.simple\n        ) {\n          return (\n            internalAccount.metadata.keyring.type === KeyringTypes.hd ||\n            internalAccount.metadata.keyring.type === KeyringTypes.simple\n          );\n        }\n\n        return internalAccount.metadata.keyring.type === keyringType;\n      },\n    );\n  }\n\n  /**\n   * Returns the last selected account from the given array of accounts.\n   *\n   * @param accounts - An array of InternalAccount objects.\n   * @returns The InternalAccount object that was last selected, or undefined if the array is empty.\n   */\n  #getLastSelectedAccount(\n    accounts: InternalAccount[],\n  ): InternalAccount | undefined {\n    return accounts.reduce((prevAccount, currentAccount) => {\n      if (\n        // When the account is added, lastSelected will be set\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        currentAccount.metadata.lastSelected! >\n        // When the account is added, lastSelected will be set\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        prevAccount.metadata.lastSelected!\n      ) {\n        return currentAccount;\n      }\n      return prevAccount;\n    }, accounts[0]);\n  }\n\n  /**\n   * Returns the next account number for a given keyring type.\n   * @param keyringType - The type of keyring.\n   * @param accounts - Existing accounts to check for the next available account number.\n   * @returns An object containing the account prefix and index to use.\n   */\n  getNextAvailableAccountName(\n    keyringType: string = KeyringTypes.hd,\n    accounts?: InternalAccount[],\n  ): string {\n    const keyringName = keyringTypeToName(keyringType);\n    const keyringAccounts = this.#getAccountsByKeyringType(\n      keyringType,\n      accounts,\n    );\n    const lastDefaultIndexUsedForKeyringType = keyringAccounts.reduce(\n      (maxInternalAccountIndex, internalAccount) => {\n        // We **DO NOT USE** `\\d+` here to only consider valid \"human\"\n        // number (rounded decimal number)\n        const match = new RegExp(`${keyringName} ([0-9]+)$`, 'u').exec(\n          internalAccount.metadata.name,\n        );\n\n        if (match) {\n          // Quoting `RegExp.exec` documentation:\n          // > The returned array has the matched text as the first item, and then one item for\n          // > each capturing group of the matched text.\n          // So use `match[1]` to get the captured value\n          const internalAccountIndex = parseInt(match[1], 10);\n          return Math.max(maxInternalAccountIndex, internalAccountIndex);\n        }\n\n        return maxInternalAccountIndex;\n      },\n      0,\n    );\n\n    const index = Math.max(\n      keyringAccounts.length + 1,\n      // ESLint is confused; this is a number.\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      lastDefaultIndexUsedForKeyringType + 1,\n    );\n\n    return `${keyringName} ${index}`;\n  }\n\n  /**\n   * Checks if an account is compatible with a given chain namespace.\n   * @private\n   * @param account - The account to check compatibility for.\n   * @param chainId - The CAIP2 to check compatibility with.\n   * @returns Returns true if the account is compatible with the chain namespace, otherwise false.\n   */\n  #isAccountCompatibleWithChain(\n    account: InternalAccount,\n    chainId: CaipChainId,\n  ): boolean {\n    // TODO: Change this logic to not use account's type\n    // Because we currently only use type, we can only use namespace for now.\n    return account.type.startsWith(parseCaipChainId(chainId).namespace);\n  }\n\n  /**\n   * Retrieves the index value for `metadata.lastSelected`.\n   *\n   * @returns The index value.\n   */\n  #getLastSelectedIndex() {\n    // NOTE: For now we use the current date, since we know this value\n    // will always be higher than any already selected account index.\n    return Date.now();\n  }\n\n  /**\n   * Handles the addition of a new account to the controller.\n   * If the account is not a Snap Keyring account, generates an internal account for it and adds it to the controller.\n   * If the account is a Snap Keyring account, retrieves the account from the keyring and adds it to the controller.\n   * @param accountsState - AccountsController accounts state that is to be mutated.\n   * @param account - The address and keyring type object of the new account.\n   * @returns The updated AccountsController accounts state.\n   */\n  #handleNewAccountAdded(\n    accountsState: AccountsControllerState['internalAccounts']['accounts'],\n    account: AddressAndKeyringTypeObject,\n  ): AccountsControllerState['internalAccounts']['accounts'] {\n    let newAccount: InternalAccount;\n    if (account.type !== KeyringTypes.snap) {\n      newAccount = this.#generateInternalAccountForNonSnapAccount(\n        account.address,\n        account.type,\n      );\n    } else {\n      const [snapKeyring] = this.messagingSystem.call(\n        'KeyringController:getKeyringsByType',\n        SnapKeyring.type,\n      );\n\n      newAccount = (snapKeyring as SnapKeyring).getAccountByAddress(\n        account.address,\n      ) as InternalAccount;\n\n      // The snap deleted the account before the keyring controller could add it\n      if (!newAccount) {\n        return accountsState;\n      }\n    }\n\n    const isFirstAccount = Object.keys(accountsState).length === 0;\n\n    // Get next account name available for this given keyring\n    const accountName = this.getNextAvailableAccountName(\n      newAccount.metadata.keyring.type,\n      Object.values(accountsState),\n    );\n\n    const newAccountWithUpdatedMetadata = {\n      ...newAccount,\n      metadata: {\n        ...newAccount.metadata,\n        name: accountName,\n        importTime: Date.now(),\n        lastSelected: isFirstAccount ? this.#getLastSelectedIndex() : 0,\n      },\n    };\n    accountsState[newAccount.id] = newAccountWithUpdatedMetadata;\n\n    this.messagingSystem.publish(\n      'AccountsController:accountAdded',\n      newAccountWithUpdatedMetadata,\n    );\n\n    return accountsState;\n  }\n\n  #publishAccountChangeEvent(account: InternalAccount) {\n    if (isEvmAccountType(account.type)) {\n      this.messagingSystem.publish(\n        'AccountsController:selectedEvmAccountChange',\n        account,\n      );\n    }\n    this.messagingSystem.publish(\n      'AccountsController:selectedAccountChange',\n      account,\n    );\n  }\n\n  /**\n   * Handles the removal of an account from the internal accounts list.\n   * @param accountsState - AccountsController accounts state that is to be mutated.\n   * @param accountId - The ID of the account to be removed.\n   * @returns The updated AccountsController state.\n   */\n  #handleAccountRemoved(\n    accountsState: AccountsControllerState['internalAccounts']['accounts'],\n    accountId: string,\n  ): AccountsControllerState['internalAccounts']['accounts'] {\n    delete accountsState[accountId];\n\n    this.messagingSystem.publish(\n      'AccountsController:accountRemoved',\n      accountId,\n    );\n\n    return accountsState;\n  }\n\n  /**\n   * Retrieves the value of a specific metadata key for an existing account.\n   * @param accountId - The ID of the account.\n   * @param metadataKey - The key of the metadata to retrieve.\n   * @param account - The account object to retrieve the metadata key from.\n   * @returns The value of the specified metadata key, or undefined if the account or metadata key does not exist.\n   */\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  #populateExistingMetadata<T extends keyof InternalAccount['metadata']>(\n    accountId: string,\n    metadataKey: T,\n    account?: InternalAccount,\n  ): InternalAccount['metadata'][T] | undefined {\n    const internalAccount = account ?? this.getAccount(accountId);\n    return internalAccount ? internalAccount.metadata[metadataKey] : undefined;\n  }\n\n  /**\n   * Registers message handlers for the AccountsController.\n   * @private\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:setSelectedAccount`,\n      this.setSelectedAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:listAccounts`,\n      this.listAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:listMultichainAccounts`,\n      this.listMultichainAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:setAccountName`,\n      this.setAccountName.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateAccounts`,\n      this.updateAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSelectedAccount`,\n      this.getSelectedAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSelectedMultichainAccount`,\n      this.getSelectedMultichainAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getAccountByAddress`,\n      this.getAccountByAddress.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getNextAvailableAccountName`,\n      this.getNextAvailableAccountName.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `AccountsController:getAccount`,\n      this.getAccount.bind(this),\n    );\n  }\n}\n"]}