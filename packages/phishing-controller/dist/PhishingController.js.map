{"version":3,"file":"PhishingController.js","sourceRoot":"","sources":["../src/PhishingController.ts"],"names":[],"mappings":"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","sourcesContent":["import { toASCII } from 'punycode/';\nimport DEFAULT_PHISHING_RESPONSE from 'eth-phishing-detect/src/config.json';\nimport PhishingDetector from 'eth-phishing-detect/src/detector';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\n\n/**\n * @type EthPhishingResponse\n *\n * Configuration response from the eth-phishing-detect package\n * consisting of approved and unapproved website origins\n * @property blacklist - List of unapproved origins\n * @property fuzzylist - List of fuzzy-matched unapproved origins\n * @property tolerance - Fuzzy match tolerance level\n * @property version - Version number of this configuration\n * @property whitelist - List of approved origins\n */\nexport interface EthPhishingResponse {\n  blacklist: string[];\n  fuzzylist: string[];\n  tolerance: number;\n  version: number;\n  whitelist: string[];\n}\n\n/**\n * @type EthPhishingDetectConfig\n *\n * Interface defining expected input to PhishingDetector.\n * @property allowlist - List of approved origins (legacy naming \"whitelist\")\n * @property blocklist - List of unapproved origins (legacy naming \"blacklist\")\n * @property fuzzylist - List of fuzzy-matched unapproved origins\n * @property tolerance - Fuzzy match tolerance level\n */\nexport interface EthPhishingDetectConfig {\n  allowlist: string[];\n  blocklist: string[];\n  fuzzylist: string[];\n  tolerance: number;\n  name: string;\n  version: number;\n}\n\n/**\n * @type EthPhishingDetectResult\n *\n * Interface that describes the result of the `test` method.\n * @property name - Name of the config on which a match was found.\n * @property version - Version of the config on which a match was found.\n * @property result - Whether a domain was detected as a phishing domain. True means an unsafe domain.\n * @property match - The matching fuzzylist origin when a fuzzylist match is found. Returned as undefined for non-fuzzy true results.\n * @property type - The field of the config on which a match was found.\n */\nexport interface EthPhishingDetectResult {\n  name?: string;\n  version?: string;\n  result: boolean;\n  match?: string; // Returned as undefined for non-fuzzy true results.\n  type: 'all' | 'fuzzy' | 'blocklist' | 'allowlist';\n}\n\n/**\n * @type PhishingConfig\n *\n * Phishing controller configuration\n * @property interval - Polling interval used to fetch new block / approve lists\n */\nexport interface PhishingConfig extends BaseConfig {\n  refreshInterval: number;\n}\n\n/**\n * @type PhishingState\n *\n * Phishing controller state\n * @property phishing - eth-phishing-detect configuration\n * @property whitelist - array of temporarily-approved origins\n */\nexport interface PhishingState extends BaseState {\n  phishing: EthPhishingDetectConfig[];\n  whitelist: string[];\n}\n\nexport const PHISHING_CONFIG_BASE_URL =\n  'https://static.metafi.codefi.network/api/v1/lists';\n\nexport const METAMASK_CONFIG_FILE = '/eth_phishing_detect_config.json';\n\nexport const PHISHFORT_HOTLIST_FILE = '/phishfort_hotlist.json';\n\nexport const METAMASK_CONFIG_URL = `${PHISHING_CONFIG_BASE_URL}${METAMASK_CONFIG_FILE}`;\nexport const PHISHFORT_HOTLIST_URL = `${PHISHING_CONFIG_BASE_URL}${PHISHFORT_HOTLIST_FILE}`;\n\n/**\n * Controller that manages community-maintained lists of approved and unapproved website origins.\n */\nexport class PhishingController extends BaseController<\n  PhishingConfig,\n  PhishingState\n> {\n  private detector: any;\n\n  private lastFetched = 0;\n\n  #inProgressUpdate: Promise<void> | undefined;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'PhishingController';\n\n  /**\n   * Creates a PhishingController instance.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    config?: Partial<PhishingConfig>,\n    state?: Partial<PhishingState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      refreshInterval: 60 * 60 * 1000,\n    };\n\n    this.defaultState = {\n      phishing: [\n        {\n          allowlist: DEFAULT_PHISHING_RESPONSE.whitelist,\n          blocklist: DEFAULT_PHISHING_RESPONSE.blacklist,\n          fuzzylist: DEFAULT_PHISHING_RESPONSE.fuzzylist,\n          tolerance: DEFAULT_PHISHING_RESPONSE.tolerance,\n          name: `MetaMask`,\n          version: DEFAULT_PHISHING_RESPONSE.version,\n        },\n      ],\n      whitelist: [],\n    };\n    this.detector = new PhishingDetector(this.defaultState.phishing);\n    this.initialize();\n  }\n\n  /**\n   * Set the interval at which the phishing list will be refetched. Fetching will only occur on the next call to test/bypass. For immediate update to the phishing list, call updatePhishingLists directly.\n   *\n   * @param interval - the new interval, in ms.\n   */\n  setRefreshInterval(interval: number) {\n    this.configure({ refreshInterval: interval }, false, false);\n  }\n\n  /**\n   * Determine if an update to the phishing configuration is needed.\n   *\n   * @returns Whether an update is needed\n   */\n  isOutOfDate() {\n    return Date.now() - this.lastFetched >= this.config.refreshInterval;\n  }\n\n  /**\n   * Determines if a given origin is unapproved.\n   *\n   * It is strongly recommended that you call {@link isOutOfDate} before calling this,\n   * to check whether the phishing configuration is up-to-date. It can be\n   * updated by calling {@link updatePhishingLists}.\n   *\n   * @param origin - Domain origin of a website.\n   * @returns Whether the origin is an unapproved origin.\n   */\n  test(origin: string): EthPhishingDetectResult {\n    const punycodeOrigin = toASCII(origin);\n    if (this.state.whitelist.indexOf(punycodeOrigin) !== -1) {\n      return { result: false, type: 'all' }; // Same as whitelisted match returned by detector.check(...).\n    }\n    return this.detector.check(punycodeOrigin);\n  }\n\n  /**\n   * Temporarily marks a given origin as approved.\n   *\n   * @param origin - The origin to mark as approved.\n   */\n  bypass(origin: string) {\n    const punycodeOrigin = toASCII(origin);\n    const { whitelist } = this.state;\n    if (whitelist.indexOf(punycodeOrigin) !== -1) {\n      return;\n    }\n    this.update({ whitelist: [...whitelist, punycodeOrigin] });\n  }\n\n  /**\n   * Update the phishing configuration.\n   *\n   * If an update is in progress, no additional update will be made. Instead this will wait until\n   * the in-progress update has finished.\n   */\n  async updatePhishingLists() {\n    if (this.#inProgressUpdate) {\n      await this.#inProgressUpdate;\n      return;\n    }\n\n    try {\n      this.#inProgressUpdate = this.#updatePhishingLists();\n      await this.#inProgressUpdate;\n    } finally {\n      this.#inProgressUpdate = undefined;\n    }\n  }\n\n  /**\n   * Update the phishing configuration.\n   *\n   * This should only be called from the `updatePhishingLists` function, which is a wrapper around\n   * this function that prevents redundant configuration updates.\n   */\n  async #updatePhishingLists() {\n    if (this.disabled) {\n      return;\n    }\n\n    const configs: EthPhishingDetectConfig[] = [];\n\n    let metamaskConfigLegacy;\n    let phishfortHotlist;\n    try {\n      [metamaskConfigLegacy, phishfortHotlist] = await Promise.all([\n        this.queryConfig<EthPhishingResponse>(METAMASK_CONFIG_URL),\n        this.queryConfig<string[]>(PHISHFORT_HOTLIST_URL),\n      ]);\n    } finally {\n      // Set `lastFetched` even for failed requests to prevent server from being overwhelmed with\n      // traffic after a network disruption.\n      this.lastFetched = Date.now();\n    }\n\n    // Correctly shaping MetaMask config.\n    const metamaskConfig: EthPhishingDetectConfig = {\n      allowlist: metamaskConfigLegacy ? metamaskConfigLegacy.whitelist : [],\n      blocklist: metamaskConfigLegacy ? metamaskConfigLegacy.blacklist : [],\n      fuzzylist: metamaskConfigLegacy ? metamaskConfigLegacy.fuzzylist : [],\n      tolerance: metamaskConfigLegacy ? metamaskConfigLegacy.tolerance : 0,\n      name: `MetaMask`,\n      version: metamaskConfigLegacy ? metamaskConfigLegacy.version : 0,\n    };\n    if (metamaskConfigLegacy) {\n      configs.push(metamaskConfig);\n    }\n\n    // Correctly shaping PhishFort config.\n    const phishfortConfig: EthPhishingDetectConfig = {\n      allowlist: [],\n      blocklist: (phishfortHotlist || []).filter(\n        (i) => !metamaskConfig.blocklist.includes(i),\n      ), // Removal of duplicates.\n      fuzzylist: [],\n      tolerance: 0,\n      name: `PhishFort`,\n      version: 1,\n    };\n    if (phishfortHotlist) {\n      configs.push(phishfortConfig);\n    }\n\n    // Do not update if all configs are unavailable.\n    if (!configs.length) {\n      return;\n    }\n\n    this.detector = new PhishingDetector(configs);\n    this.update({\n      phishing: configs,\n    });\n  }\n\n  private async queryConfig<ResponseType>(\n    input: RequestInfo,\n  ): Promise<ResponseType | null> {\n    const response = await safelyExecute(\n      () => fetch(input, { cache: 'no-cache' }),\n      true,\n    );\n\n    switch (response?.status) {\n      case 200: {\n        return await response.json();\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n}\n\nexport default PhishingController;\n"]}