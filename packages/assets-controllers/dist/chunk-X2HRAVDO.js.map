{"version":3,"sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AccountsControllerGetAccountAction,\n  AccountsControllerGetSelectedAccountAction,\n  AccountsControllerSelectedEvmAccountChangeEvent,\n} from '@metamask/accounts-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type { InternalAccount } from '@metamask/keyring-api';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetStateAction,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport { createDeferredPromise, type Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially, TOKEN_PRICES_BATCH_SIZE } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare-service';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport { ZERO_ADDRESS } from './token-prices-service/codefi-v2';\nimport type {\n  TokensControllerGetStateAction,\n  TokensControllerStateChangeEvent,\n  TokensControllerState,\n} from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property aggregators - An array containing the token's aggregators\n * @property image - Image of the token, url or bit32 image\n * @property hasBalanceError - 'true' if there is an error while updating the token balance\n * @property isERC721 - 'true' if the token is a ERC721 token\n * @property name - Name of the token\n */\nexport type Token = {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  hasBalanceError?: boolean;\n  isERC721?: boolean;\n  name?: string;\n};\n\nconst DEFAULT_INTERVAL = 180000;\n\nexport type ContractExchangeRates = {\n  [address: string]: number | undefined;\n};\n\ntype MarketDataDetails = {\n  tokenAddress: `0x${string}`;\n  currency: string;\n  allTimeHigh: number;\n  allTimeLow: number;\n  circulatingSupply: number;\n  dilutedMarketCap: number;\n  high1d: number;\n  low1d: number;\n  marketCap: number;\n  marketCapPercentChange1d: number;\n  price: number;\n  priceChange1d: number;\n  pricePercentChange1d: number;\n  pricePercentChange1h: number;\n  pricePercentChange1y: number;\n  pricePercentChange7d: number;\n  pricePercentChange14d: number;\n  pricePercentChange30d: number;\n  pricePercentChange200d: number;\n  totalVolume: number;\n};\n\n/**\n * Represents a mapping of token contract addresses to their market data.\n */\nexport type ContractMarketData = Record<Hex, MarketDataDetails>;\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * The external actions available to the {@link TokenRatesController}.\n */\nexport type AllowedActions =\n  | TokensControllerGetStateAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetStateAction\n  | AccountsControllerGetAccountAction\n  | AccountsControllerGetSelectedAccountAction;\n\n/**\n * The external events available to the {@link TokenRatesController}.\n */\nexport type AllowedEvents =\n  | TokensControllerStateChangeEvent\n  | NetworkControllerStateChangeEvent\n  | AccountsControllerSelectedEvmAccountChangeEvent;\n\n/**\n * The name of the {@link TokenRatesController}.\n */\nexport const controllerName = 'TokenRatesController';\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property marketData - Market data for tokens, keyed by chain ID and then token contract address.\n */\nexport type TokenRatesControllerState = {\n  marketData: Record<Hex, Record<Hex, MarketDataDetails>>;\n};\n\n/**\n * The action that can be performed to get the state of the {@link TokenRatesController}.\n */\nexport type TokenRatesControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokenRatesControllerState\n>;\n\n/**\n * The actions that can be performed using the {@link TokenRatesController}.\n */\nexport type TokenRatesControllerActions = TokenRatesControllerGetStateAction;\n\n/**\n * The event that {@link TokenRatesController} can emit.\n */\nexport type TokenRatesControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  TokenRatesControllerState\n>;\n\n/**\n * The events that {@link TokenRatesController} can emit.\n */\nexport type TokenRatesControllerEvents = TokenRatesControllerStateChangeEvent;\n\n/**\n * The messenger of the {@link TokenRatesController} for communication.\n */\nexport type TokenRatesControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokenRatesControllerActions | AllowedActions,\n  TokenRatesControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\nconst tokenRatesControllerMetadata = {\n  marketData: { persist: true, anonymous: false },\n};\n\n/**\n * Get the default {@link TokenRatesController} state.\n *\n * @returns The default {@link TokenRatesController} state.\n */\nexport const getDefaultTokenRatesControllerState =\n  (): TokenRatesControllerState => {\n    return {\n      marketData: {},\n    };\n  };\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends StaticIntervalPollingController<\n  typeof controllerName,\n  TokenRatesControllerState,\n  TokenRatesControllerMessenger\n> {\n  #handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${Hex}:${string}`, Promise<void>> = {};\n\n  #selectedAccountId: string;\n\n  #disabled: boolean;\n\n  #chainId: Hex;\n\n  #ticker: string;\n\n  #interval: number;\n\n  #allTokens: TokensControllerState['allTokens'];\n\n  #allDetectedTokens: TokensControllerState['allDetectedTokens'];\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.disabled - Boolean to track if network requests are blocked\n   * @param options.tokenPricesService - An object in charge of retrieving token price\n   * @param options.messenger - The controller messenger instance for communication\n   * @param options.state - Initial state to set on this controller\n   */\n  constructor({\n    interval = DEFAULT_INTERVAL,\n    disabled = false,\n    tokenPricesService,\n    messenger,\n    state,\n  }: {\n    interval?: number;\n    disabled?: boolean;\n    tokenPricesService: AbstractTokenPricesService;\n    messenger: TokenRatesControllerMessenger;\n    state?: Partial<TokenRatesControllerState>;\n  }) {\n    super({\n      name: controllerName,\n      messenger,\n      state: { ...getDefaultTokenRatesControllerState(), ...state },\n      metadata: tokenRatesControllerMetadata,\n    });\n\n    this.setIntervalLength(interval);\n    this.#tokenPricesService = tokenPricesService;\n    this.#disabled = disabled;\n    this.#interval = interval;\n\n    const { chainId: currentChainId, ticker: currentTicker } =\n      this.#getChainIdAndTicker();\n    this.#chainId = currentChainId;\n    this.#ticker = currentTicker;\n\n    this.#selectedAccountId = this.#getSelectedAccount().id;\n\n    const { allTokens, allDetectedTokens } = this.#getTokensControllerState();\n    this.#allTokens = allTokens;\n    this.#allDetectedTokens = allDetectedTokens;\n\n    this.#subscribeToTokensStateChange();\n\n    this.#subscribeToNetworkStateChange();\n\n    this.#subscribeToAccountChange();\n  }\n\n  #subscribeToTokensStateChange() {\n    this.messagingSystem.subscribe(\n      'TokensController:stateChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      async ({ allTokens, allDetectedTokens }) => {\n        const previousTokenAddresses = this.#getTokenAddresses(this.#chainId);\n        this.#allTokens = allTokens;\n        this.#allDetectedTokens = allDetectedTokens;\n\n        const newTokenAddresses = this.#getTokenAddresses(this.#chainId);\n        if (\n          !isEqual(previousTokenAddresses, newTokenAddresses) &&\n          this.#pollState === PollState.Active\n        ) {\n          await this.updateExchangeRates();\n        }\n      },\n      ({ allTokens, allDetectedTokens }) => {\n        return { allTokens, allDetectedTokens };\n      },\n    );\n  }\n\n  #subscribeToNetworkStateChange() {\n    this.messagingSystem.subscribe(\n      'NetworkController:stateChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      async ({ selectedNetworkClientId }) => {\n        const {\n          configuration: { chainId, ticker },\n        } = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          selectedNetworkClientId,\n        );\n\n        if (this.#chainId !== chainId || this.#ticker !== ticker) {\n          this.update((state) => {\n            state.marketData = {};\n          });\n          this.#chainId = chainId;\n          this.#ticker = ticker;\n          if (this.#pollState === PollState.Active) {\n            await this.updateExchangeRates();\n          }\n        }\n      },\n    );\n  }\n\n  #subscribeToAccountChange() {\n    this.messagingSystem.subscribe(\n      'AccountsController:selectedEvmAccountChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      async (selectedAccount) => {\n        if (this.#selectedAccountId !== selectedAccount.id) {\n          this.#selectedAccountId = selectedAccount.id;\n          if (this.#pollState === PollState.Active) {\n            await this.updateExchangeRates();\n          }\n        }\n      },\n    );\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const selectedAccount = this.messagingSystem.call(\n      'AccountsController:getAccount',\n      this.#selectedAccountId,\n    );\n    const selectedAddress = selectedAccount?.address ?? '';\n    const tokens = this.#allTokens[chainId]?.[selectedAddress] || [];\n    const detectedTokens =\n      this.#allDetectedTokens[chainId]?.[selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Allows controller to make active and passive polling requests\n   */\n  enable(): void {\n    this.#disabled = false;\n  }\n\n  /**\n   * Blocks controller from making network calls\n   */\n  disable(): void {\n    this.#disabled = true;\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  #getSelectedAccount(): InternalAccount {\n    const selectedAccount = this.messagingSystem.call(\n      'AccountsController:getSelectedAccount',\n    );\n\n    return selectedAccount;\n  }\n\n  #getChainIdAndTicker(): {\n    chainId: Hex;\n    ticker: string;\n  } {\n    const { selectedNetworkClientId } = this.messagingSystem.call(\n      'NetworkController:getState',\n    );\n    const networkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      selectedNetworkClientId,\n    );\n    return {\n      chainId: networkClient.configuration.chainId,\n      ticker: networkClient.configuration.ticker,\n    };\n  }\n\n  #getTokensControllerState(): {\n    allTokens: TokensControllerState['allTokens'];\n    allDetectedTokens: TokensControllerState['allDetectedTokens'];\n  } {\n    const { allTokens, allDetectedTokens } = this.messagingSystem.call(\n      'TokensController:getState',\n    );\n\n    return {\n      allTokens,\n      allDetectedTokens,\n    };\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.#handle) {\n      clearTimeout(this.#handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.#handle = setTimeout(() => {\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.#poll();\n    }, this.#interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    await this.updateExchangeRatesByChainId({\n      chainId: this.#chainId,\n      nativeCurrency: this.#ticker,\n    });\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   *\n   * @param options - The options to fetch exchange rates.\n   * @param options.chainId - The chain ID.\n   * @param options.nativeCurrency - The ticker for the chain.\n   */\n  async updateExchangeRatesByChainId({\n    chainId,\n    nativeCurrency,\n  }: {\n    chainId: Hex;\n    nativeCurrency: string;\n  }) {\n    if (this.#disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n\n    const updateKey: `${Hex}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const contractInformations = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const marketData = {\n        [chainId]: {\n          ...(contractInformations ?? {}),\n        },\n      };\n\n      this.update((state) => {\n        state.marketData = marketData;\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractMarketData> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce((obj, tokenAddress) => {\n        obj = {\n          ...obj,\n          [tokenAddress]: undefined,\n        };\n\n        return obj;\n      }, {});\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates token rates for the given networkClientId\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      networkClientId,\n    );\n    await this.updateExchangeRatesByChainId({\n      chainId: networkClient.configuration.chainId,\n      nativeCurrency: networkClient.configuration.ticker,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractMarketData> {\n    let contractNativeInformations;\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n    contractNativeInformations = tokenPricesByTokenAddress;\n\n    // fetch for native token\n    if (tokenAddresses.length === 0) {\n      const contractNativeInformationsNative =\n        await this.#tokenPricesService.fetchTokenPrices({\n          tokenAddresses: [],\n          chainId,\n          currency: nativeCurrency,\n        });\n\n      contractNativeInformations = {\n        [ZERO_ADDRESS]: {\n          currency: nativeCurrency,\n          ...contractNativeInformationsNative[ZERO_ADDRESS],\n        },\n      };\n    }\n    return Object.entries(contractNativeInformations).reduce(\n      (obj, [tokenAddress, token]) => {\n        obj = {\n          ...obj,\n          [tokenAddress]: { ...token },\n        };\n\n        return obj;\n      },\n      {},\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractMarketData> {\n    const [\n      contractExchangeInformations,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.#chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {};\n    }\n\n    const updatedContractExchangeRates = Object.entries(\n      contractExchangeInformations,\n    ).reduce((acc, [tokenAddress, token]) => {\n      acc = {\n        ...acc,\n        [tokenAddress]: {\n          ...token,\n          price: token.price\n            ? token.price * fallbackCurrencyToNativeCurrencyConversionRate\n            : undefined,\n        },\n      };\n      return acc;\n    }, {});\n\n    return updatedContractExchangeRates;\n  }\n}\n\nexport default TokenRatesController;\n"]}