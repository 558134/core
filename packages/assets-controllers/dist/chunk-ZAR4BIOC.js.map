{"version":3,"sources":["../src/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = ControllerStateChangeEvent<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerEvents = TokenListStateChange;\n\nexport type GetTokenListState = ControllerGetStateAction<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerActions = GetTokenListState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype AllowedEvents = NetworkControllerStateChangeEvent;\n\nexport type TokenListControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  TokenListControllerActions | AllowedActions,\n  TokenListControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nexport const getDefaultTokenListState = (): TokenListState => {\n  return {\n    tokenList: {},\n    tokensChainsCache: {},\n    preventPollingOnNetworkRestart: false,\n  };\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends StaticIntervalPollingController<\n  typeof name,\n  TokenListState,\n  TokenListControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListControllerMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...getDefaultTokenListState(), ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    const selectedNetworkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      networkControllerState.selectedNetworkClientId,\n    );\n    const { chainId } = selectedNetworkClient.configuration;\n\n    if (this.chainId !== chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI = await safelyExecute(\n          () =>\n            fetchTokenListByChainId(\n              chainId,\n              this.abortController.signal,\n            ) as Promise<TokenListToken[]>,\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        for (const token of tokensFromAPI) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}