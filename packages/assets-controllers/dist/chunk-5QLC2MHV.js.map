{"version":3,"sources":["../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  ERC1155,\n  ERC1155_INTERFACE_ID,\n  ERC1155_METADATA_URI_INTERFACE_ID,\n  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n  safelyExecute,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport { abiERC1155 } from '@metamask/metamask-eth-abis';\nimport type * as BN from 'bn.js';\n\nimport { getFormattedIpfsUrl, ethersBigNumberToBN } from '../../../assetsUtil';\n\nexport class ERC1155Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  async contractSupportsURIMetadataInterface(\n    address: string,\n  ): Promise<boolean> {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  }\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  async contractSupportsTokenReceiverInterface(\n    address: string,\n  ): Promise<boolean> {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  }\n\n  /**\n   * Query if contract implements ERC1155 interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.\n   */\n  async contractSupportsBase1155Interface(address: string): Promise<boolean> {\n    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getTokenURI(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.uri(tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contractAddress - ERC1155 asset contract address.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getBalanceOf(\n    contractAddress: string,\n    address: string,\n    tokenId: string,\n  ): Promise<BN> {\n    const contract = new Contract(contractAddress, abiERC1155, this.provider);\n    const balance = await contract.balanceOf(address, tokenId);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  async transferSingle(\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> {\n    const contract = new Contract(operator, abiERC1155, this.provider);\n    return new Promise<void>((resolve, reject) => {\n      contract.transferSingle(\n        operator,\n        from,\n        to,\n        id,\n        value,\n        (error: Error, result: void) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(result);\n        },\n      );\n    });\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getAssetSymbol(address: string): Promise<string> {\n    const contract = new Contract(\n      address,\n      // Contract ABI fragment containing only the symbol method to fetch the symbol of the contract.\n      [\n        {\n          inputs: [],\n          name: 'symbol',\n          outputs: [{ name: '_symbol', type: 'string' }],\n          stateMutability: 'view',\n          type: 'function',\n          payable: false,\n        },\n      ],\n      this.provider,\n    );\n    return contract.symbol();\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getAssetName(address: string): Promise<string> {\n    const contract = new Contract(\n      address,\n      // Contract ABI fragment containing only the name method to fetch the name of the contract.\n      [\n        {\n          inputs: [],\n          name: 'name',\n          outputs: [{ name: '_name', type: 'string' }],\n          stateMutability: 'view',\n          type: 'function',\n          payable: false,\n        },\n      ],\n      this.provider,\n    );\n    return contract.name();\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private async contractSupportsInterface(\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.supportsInterface(interfaceId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  async getDetails(\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    image: string | undefined;\n    name: string | undefined;\n    symbol: string | undefined;\n  }> {\n    const isERC1155 = await this.contractSupportsBase1155Interface(address);\n\n    if (!isERC1155) {\n      throw new Error(\"This isn't a valid ERC1155 contract\");\n    }\n\n    let image;\n\n    const [symbol, name, tokenURI] = await Promise.all([\n      safelyExecute(() => this.getAssetSymbol(address)),\n      safelyExecute(() => this.getAssetName(address)),\n      tokenId\n        ? safelyExecute(() =>\n            this.getTokenURI(address, tokenId).then((uri) =>\n              uri.startsWith('ipfs://')\n                ? getFormattedIpfsUrl(ipfsGateway, uri, true)\n                : uri,\n            ),\n          )\n        : undefined,\n    ]);\n\n    if (tokenURI) {\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // Catch block should be kept empty to ignore exceptions, and\n        // pass as much information as possible to the return statement\n      }\n    }\n\n    // TODO consider querying to the metadata to get name.\n    return {\n      standard: ERC1155,\n      tokenURI,\n      image,\n      symbol,\n      name,\n    };\n  }\n}\n"]}