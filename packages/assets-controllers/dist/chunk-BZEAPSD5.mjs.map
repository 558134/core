{"version":3,"sources":["../src/assetsUtil.ts"],"sourcesContent":["import type { BigNumber } from '@ethersproject/bignumber';\nimport {\n  convertHexToDecimal,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport BN from 'bn.js';\n\nimport type { Nft, NftMetadata } from './NftController';\nimport type { AbstractTokenPricesService } from './token-prices-service';\nimport { type ContractExchangeRates } from './TokenRatesController';\n\n/**\n * The maximum number of token addresses that should be sent to the Price API in\n * a single request.\n */\nexport const TOKEN_PRICES_BATCH_SIZE = 30;\n\n/**\n * Compares nft metadata entries to any nft entry.\n * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,\n * there's a need to update the nft in state.\n *\n * @param newNftMetadata - Nft metadata object.\n * @param nft - Nft object to compare with.\n * @returns Whether there are differences.\n */\nexport function compareNftMetadata(newNftMetadata: NftMetadata, nft: Nft) {\n  const keys: (keyof NftMetadata)[] = [\n    'image',\n    'backgroundColor',\n    'imagePreview',\n    'imageThumbnail',\n    'imageOriginal',\n    'animation',\n    'animationOriginal',\n    'externalLink',\n    'tokenURI',\n  ];\n  const differentValues = keys.reduce((value, key) => {\n    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {\n      return value + 1;\n    }\n    return value;\n  }, 0);\n  return differentValues > 0;\n}\n\n/**\n * Checks whether the existing nft object has all the keys of the new incoming nft metadata object\n * @param newNftMetadata - New nft metadata object\n * @param nft - Existing nft object to compare with\n * @returns Whether the existing nft object has all the new keys from the new Nft metadata object\n */\nexport function hasNewCollectionFields(\n  newNftMetadata: NftMetadata,\n  nft: Nft,\n): boolean {\n  const keysNewNftMetadata = Object.keys(newNftMetadata.collection ?? {});\n  const keysExistingNft = new Set(Object.keys(nft.collection ?? {}));\n\n  return keysNewNftMetadata.some((key) => !keysExistingNft.has(key));\n}\n\nconst aggregatorNameByKey: Record<string, string> = {\n  aave: 'Aave',\n  bancor: 'Bancor',\n  cmc: 'CMC',\n  cryptocom: 'Crypto.com',\n  coinGecko: 'CoinGecko',\n  oneInch: '1inch',\n  paraswap: 'Paraswap',\n  pmm: 'PMM',\n  zapper: 'Zapper',\n  zerion: 'Zerion',\n  zeroEx: '0x',\n  synthetix: 'Synthetix',\n  yearn: 'Yearn',\n  apeswap: 'ApeSwap',\n  binanceDex: 'BinanceDex',\n  pancakeTop100: 'PancakeTop100',\n  pancakeExtended: 'PancakeExtended',\n  balancer: 'Balancer',\n  quickswap: 'QuickSwap',\n  matcha: 'Matcha',\n  pangolinDex: 'PangolinDex',\n  pangolinDexStableCoin: 'PangolinDexStableCoin',\n  pangolinDexAvaxBridge: 'PangolinDexAvaxBridge',\n  traderJoe: 'TraderJoe',\n  airswapLight: 'AirswapLight',\n  kleros: 'Kleros',\n};\n\n/**\n * Formats aggregator names to presentable format.\n *\n * @param aggregators - List of token list names in camelcase.\n * @returns Formatted aggregator names.\n */\nexport const formatAggregatorNames = (aggregators: string[]) => {\n  return aggregators.map(\n    (key) =>\n      aggregatorNameByKey[key] ||\n      `${key[0].toUpperCase()}${key.substring(1, key.length)}`,\n  );\n};\n\n/**\n * Format token list assets to use image proxy from Codefi.\n *\n * @param params - Object that contains chainID and tokenAddress.\n * @param params.chainId - ChainID of network in 0x-prefixed hexadecimal format.\n * @param params.tokenAddress - Address of token in mixed or lowercase.\n * @returns Formatted image url\n */\nexport const formatIconUrlWithProxy = ({\n  chainId,\n  tokenAddress,\n}: {\n  chainId: Hex;\n  tokenAddress: string;\n}) => {\n  const chainIdDecimal = convertHexToDecimal(chainId).toString();\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  return `https://static.cx.metamask.io/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;\n};\n\n/**\n * Networks where token detection is supported - Values are in hex format\n */\nexport enum SupportedTokenDetectionNetworks {\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  mainnet = '0x1', // decimal: 1\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  bsc = '0x38', // decimal: 56\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  polygon = '0x89', // decimal: 137\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  avax = '0xa86a', // decimal: 43114\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  aurora = '0x4e454152', // decimal: 1313161554\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  linea_goerli = '0xe704', // decimal: 59140\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  linea_mainnet = '0xe708', // decimal: 59144\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  arbitrum = '0xa4b1', // decimal: 42161\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  optimism = '0xa', // decimal: 10\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  base = '0x2105', // decimal: 8453\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  zksync = '0x144', // decimal: 324\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  cronos = '0x19', // decimal: 25\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  celo = '0xa4ec', // decimal: 42220\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  gnosis = '0x64', // decimal: 100\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  fantom = '0xfa', // decimal: 250\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  polygon_zkevm = '0x44d', // decimal: 1101\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  moonbeam = '0x504', // decimal: 1284\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  moonriver = '0x505', // decimal: 1285\n}\n\n/**\n * Check if token detection is enabled for certain networks.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport function isTokenDetectionSupportedForNetwork(chainId: Hex): boolean {\n  return Object.values<Hex>(SupportedTokenDetectionNetworks).includes(chainId);\n}\n\n/**\n * Check if token list polling is enabled for a given network.\n * Currently this method is used to support e2e testing for consumers of this package.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports tokenlists\n */\nexport function isTokenListSupportedForNetwork(chainId: Hex): boolean {\n  return isTokenDetectionSupportedForNetwork(chainId);\n}\n\n/**\n * Removes IPFS protocol prefix from input string.\n *\n * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})\n * @returns IPFS content identifier and (possibly) path in a string\n * @throws Will throw if the url passed is not IPFS.\n */\nexport function removeIpfsProtocolPrefix(ipfsUrl: string) {\n  if (ipfsUrl.startsWith('ipfs://ipfs/')) {\n    return ipfsUrl.replace('ipfs://ipfs/', '');\n  } else if (ipfsUrl.startsWith('ipfs://')) {\n    return ipfsUrl.replace('ipfs://', '');\n  }\n  // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)\n  throw new Error('this method should not be used with non ipfs urls');\n}\n\n/**\n * Extracts content identifier and path from an input string.\n *\n * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix\n * @returns IFPS content identifier (cid) and sub path as string.\n * @throws Will throw if the url passed is not ipfs.\n */\nexport async function getIpfsCIDv1AndPath(ipfsUrl: string): Promise<{\n  cid: string;\n  path?: string;\n}> {\n  const url = removeIpfsProtocolPrefix(ipfsUrl);\n\n  // check if there is a path\n  // (CID is everything preceding first forward slash, path is everything after)\n  const index = url.indexOf('/');\n  const cid = index !== -1 ? url.substring(0, index) : url;\n  const path = index !== -1 ? url.substring(index) : undefined;\n\n  const { CID } = await import('multiformats');\n  // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)\n  // because most cid v0s appear to be incompatible with IPFS subdomains\n  return {\n    cid: CID.parse(cid).toV1().toString(),\n    path,\n  };\n}\n\n/**\n * Formats URL correctly for use retrieving assets hosted on IPFS.\n *\n * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).\n * @param ipfsUrl - The IFPS URL pointed at the asset.\n * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.\n * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.\n */\nexport async function getFormattedIpfsUrl(\n  ipfsGateway: string,\n  ipfsUrl: string,\n  subdomainSupported: boolean,\n): Promise<string> {\n  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));\n  if (subdomainSupported) {\n    const { cid, path } = await getIpfsCIDv1AndPath(ipfsUrl);\n    return `${protocol}//${cid}.ipfs.${host}${path ?? ''}`;\n  }\n  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);\n  return `${origin}/ipfs/${cidAndPath}`;\n}\n\n/**\n * Adds URL protocol prefix to input URL string if missing.\n *\n * @param urlString - An IPFS URL.\n * @returns A URL with a https:// prepended.\n */\nexport function addUrlProtocolPrefix(urlString: string): string {\n  if (!urlString.match(/(^http:\\/\\/)|(^https:\\/\\/)/u)) {\n    return `https://${urlString}`;\n  }\n  return urlString;\n}\n\n/**\n * Converts an Ethers BigNumber to a BN.\n *\n * @param bigNumber - An Ethers BigNumber instance.\n * @returns A BN object.\n */\nexport function ethersBigNumberToBN(bigNumber: BigNumber): BN {\n  return new BN(remove0x(bigNumber.toHexString()), 'hex');\n}\n\n/**\n * Partitions a list of values into groups that are at most `batchSize` in\n * length.\n *\n * @param values - The list of values.\n * @param args - The remaining arguments.\n * @param args.batchSize - The desired maximum number of values per batch.\n * @returns The list of batches.\n */\nexport function divideIntoBatches<Value>(\n  values: Value[],\n  { batchSize }: { batchSize: number },\n): Value[][] {\n  const batches = [];\n  for (let i = 0; i < values.length; i += batchSize) {\n    batches.push(values.slice(i, i + batchSize));\n  }\n  return batches;\n}\n\n/**\n * Constructs an object from processing batches of the given values\n * sequentially.\n *\n * @param args - The arguments to this function.\n * @param args.values - A list of values to iterate over.\n * @param args.batchSize - The maximum number of values in each batch.\n * @param args.eachBatch - A function to call for each batch. This function is\n * similar to the function that `Array.prototype.reduce` takes, in that it\n * receives the object that is being built, each batch in the list of batches\n * and the index, and should return an updated version of the object.\n * @param args.initialResult - The initial value of the final data structure,\n * i.e., the value that will be fed into the first call of `eachBatch`.\n * @returns The built object.\n */\nexport async function reduceInBatchesSerially<\n  Value,\n  Result extends Record<PropertyKey, unknown>,\n>({\n  values,\n  batchSize,\n  eachBatch,\n  initialResult,\n}: {\n  values: Value[];\n  batchSize: number;\n  eachBatch: (\n    workingResult: Partial<Result>,\n    batch: Value[],\n    index: number,\n  ) => Partial<Result> | Promise<Partial<Result>>;\n  initialResult: Partial<Result>;\n}): Promise<Result> {\n  const batches = divideIntoBatches(values, { batchSize });\n  let workingResult = initialResult;\n  for (const [index, batch] of batches.entries()) {\n    workingResult = await eachBatch(workingResult, batch, index);\n  }\n  // There's no way around this — we have to assume that in the end, the result\n  // matches the intended type.\n  const finalResult = workingResult as Result;\n  return finalResult;\n}\n\n/**\n * Retrieves token prices for a set of contract addresses in a specific currency and chainId.\n *\n * @param args - The arguments to function.\n * @param args.tokenPricesService - An object in charge of retrieving token prices.\n * @param args.nativeCurrency - The native currency to request price in.\n * @param args.tokenAddresses - The list of contract addresses.\n * @param args.chainId - The chainId of the tokens.\n * @returns The prices for the requested tokens.\n */\nexport async function fetchTokenContractExchangeRates({\n  tokenPricesService,\n  nativeCurrency,\n  tokenAddresses,\n  chainId,\n}: {\n  tokenPricesService: AbstractTokenPricesService;\n  nativeCurrency: string;\n  tokenAddresses: Hex[];\n  chainId: Hex;\n}): Promise<ContractExchangeRates> {\n  const isChainIdSupported =\n    tokenPricesService.validateChainIdSupported(chainId);\n  const isCurrencySupported =\n    tokenPricesService.validateCurrencySupported(nativeCurrency);\n\n  if (!isChainIdSupported || !isCurrencySupported) {\n    return {};\n  }\n\n  const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n    Hex,\n    Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n  >({\n    values: [...tokenAddresses].sort(),\n    batchSize: TOKEN_PRICES_BATCH_SIZE,\n    eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n      const tokenPricesByTokenAddressForBatch =\n        await tokenPricesService.fetchTokenPrices({\n          tokenAddresses: batch,\n          chainId,\n          currency: nativeCurrency,\n        });\n\n      return {\n        ...allTokenPricesByTokenAddress,\n        ...tokenPricesByTokenAddressForBatch,\n      };\n    },\n    initialResult: {},\n  });\n\n  return Object.entries(tokenPricesByTokenAddress).reduce(\n    (obj, [tokenAddress, tokenPrice]) => {\n      return {\n        ...obj,\n        [toChecksumHexAddress(tokenAddress)]: tokenPrice?.price,\n      };\n    },\n    {},\n  );\n}\n"],"mappings":"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","names":["SupportedTokenDetectionNetworks"]}