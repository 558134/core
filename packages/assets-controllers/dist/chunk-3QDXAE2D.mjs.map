{"version":3,"sources":["../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  timeoutFetch,\n  ERC721_INTERFACE_ID,\n  ERC721_METADATA_INTERFACE_ID,\n  ERC721_ENUMERABLE_INTERFACE_ID,\n  ERC721,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\n\nimport { getFormattedIpfsUrl } from '../../../assetsUtil';\n\nexport class ERC721Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC721Metadata interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Metadata interface.\n   */\n  contractSupportsMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_METADATA_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721Enumerable interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.\n   */\n  contractSupportsEnumerableInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_ENUMERABLE_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721 interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721 interface.\n   */\n  contractSupportsBase721Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);\n  };\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getNftTokenId = async (\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.tokenOfOwnerByIndex(selectedAddress, index);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    const supportsMetadata = await this.contractSupportsMetadataInterface(\n      address,\n    );\n    if (!supportsMetadata) {\n      // Do not throw error here, supporting Metadata interface is optional even though majority of ERC721 nfts do support it.\n      // This change is made because of instances of NFTs that are ERC404( mixed ERC20 / ERC721 implementation).\n      // As of today, ERC404 is unofficial but some people use it, the contract does not support Metadata interface, but it has the tokenURI() fct.\n      console.error('Contract does not support ERC721 metadata interface.');\n    }\n    return contract.tokenURI(tokenId);\n  };\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  getAssetName = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.name();\n  };\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  getAssetSymbol = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.symbol();\n  };\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getOwnerOf(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.ownerOf(tokenId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private readonly contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    try {\n      return await contract.supportsInterface(interfaceId);\n    } catch (err) {\n      // Mirror previous implementation\n      if (\n        err instanceof Error &&\n        err.message.includes('call revert exception')\n      ) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    symbol: string | undefined;\n    name: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC721 = await this.contractSupportsBase721Interface(address);\n    if (!isERC721) {\n      throw new Error(\"This isn't a valid ERC721 contract\");\n    }\n\n    const [symbol, name, tokenURI] = await Promise.all([\n      safelyExecute(() => this.getAssetSymbol(address)),\n      safelyExecute(() => this.getAssetName(address)),\n      tokenId\n        ? safelyExecute(() =>\n            this.getTokenURI(address, tokenId).then((uri) =>\n              uri.startsWith('ipfs://')\n                ? getFormattedIpfsUrl(ipfsGateway, uri, true)\n                : uri,\n            ),\n          )\n        : undefined,\n    ]);\n\n    let image;\n    if (tokenURI) {\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    return {\n      standard: ERC721,\n      tokenURI,\n      symbol,\n      name,\n      image,\n    };\n  };\n}\n"],"mappings":"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","names":[]}