{"version":3,"sources":["../src/CurrencyRateController.ts"],"names":["fetchExchangeRate"],"mappings":"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","sourcesContent":["import type {\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport {\n  TESTNET_TICKER_SYMBOLS,\n  FALL_BACK_VS_CURRENCY,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport { Mutex } from 'async-mutex';\n\nimport { fetchExchangeRate as defaultFetchExchangeRate } from './crypto-compare-service';\n\n/**\n * @type CurrencyRateState\n * @property currencyRates - Object keyed by native currency\n * @property currencyRates.conversionDate - Timestamp of conversion rate expressed in ms since UNIX epoch\n * @property currencyRates.conversionRate - Conversion rate from current base asset to the current currency\n * @property currentCurrency - Currently-active ISO 4217 currency code\n * @property usdConversionRate - Conversion rate from usd to the current currency\n */\nexport type CurrencyRateState = {\n  currentCurrency: string;\n  currencyRates: Record<\n    string,\n    {\n      conversionDate: number | null;\n      conversionRate: number | null;\n      usdConversionRate: number | null;\n    }\n  >;\n};\n\nconst name = 'CurrencyRateController';\n\nexport type CurrencyRateStateChange = ControllerStateChangeEvent<\n  typeof name,\n  CurrencyRateState\n>;\n\nexport type CurrencyRateControllerEvents = CurrencyRateStateChange;\n\nexport type GetCurrencyRateState = ControllerGetStateAction<\n  typeof name,\n  CurrencyRateState\n>;\n\nexport type CurrencyRateControllerActions = GetCurrencyRateState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype CurrencyRateMessenger = RestrictedControllerMessenger<\n  typeof name,\n  CurrencyRateControllerActions | AllowedActions,\n  CurrencyRateControllerEvents,\n  AllowedActions['type'],\n  never\n>;\n\nconst metadata = {\n  currentCurrency: { persist: true, anonymous: true },\n  currencyRates: { persist: true, anonymous: true },\n};\n\nconst defaultState = {\n  currentCurrency: 'usd',\n  currencyRates: {\n    ETH: {\n      conversionDate: 0,\n      conversionRate: 0,\n      usdConversionRate: null,\n    },\n  },\n};\n\n/**\n * Controller that passively polls on a set interval for an exchange rate from the current network\n * asset to the user's preferred currency.\n */\nexport class CurrencyRateController extends StaticIntervalPollingController<\n  typeof name,\n  CurrencyRateState,\n  CurrencyRateMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private readonly fetchExchangeRate;\n\n  private readonly includeUsdRate;\n\n  /**\n   * Creates a CurrencyRateController instance.\n   *\n   * @param options - Constructor options.\n   * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.messenger - A reference to the messaging system.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.\n   */\n  constructor({\n    includeUsdRate = false,\n    interval = 180000,\n    messenger,\n    state,\n    fetchExchangeRate = defaultFetchExchangeRate,\n  }: {\n    includeUsdRate?: boolean;\n    interval?: number;\n    messenger: CurrencyRateMessenger;\n    state?: Partial<CurrencyRateState>;\n    fetchExchangeRate?: typeof defaultFetchExchangeRate;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.includeUsdRate = includeUsdRate;\n    this.setIntervalLength(interval);\n    this.fetchExchangeRate = fetchExchangeRate;\n  }\n\n  /**\n   * Sets a currency to track.\n   *\n   * @param currentCurrency - ISO 4217 currency code.\n   */\n  async setCurrentCurrency(currentCurrency: string) {\n    const releaseLock = await this.mutex.acquire();\n    const nativeCurrencies = Object.keys(this.state.currencyRates);\n    try {\n      this.update(() => {\n        return {\n          ...defaultState,\n          currentCurrency,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    nativeCurrencies.forEach(this.updateExchangeRate.bind(this));\n  }\n\n  /**\n   * Updates the exchange rate for the current currency and native currency pair.\n   *\n   * @param nativeCurrency - The ticker symbol for the chain.\n   */\n  async updateExchangeRate(nativeCurrency: string): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    const { currentCurrency, currencyRates } = this.state;\n\n    let conversionDate: number | null = null;\n    let conversionRate: number | null = null;\n    let usdConversionRate: number | null = null;\n\n    // For preloaded testnets (Goerli, Sepolia) we want to fetch exchange rate for real ETH.\n    const nativeCurrencyForExchangeRate = Object.values(\n      TESTNET_TICKER_SYMBOLS,\n    ).includes(nativeCurrency)\n      ? FALL_BACK_VS_CURRENCY // ETH\n      : nativeCurrency;\n\n    try {\n      if (\n        currentCurrency &&\n        nativeCurrency &&\n        // if either currency is an empty string we can skip the comparison\n        // because it will result in an error from the api and ultimately\n        // a null conversionRate either way.\n        currentCurrency !== '' &&\n        nativeCurrency !== ''\n      ) {\n        const fetchExchangeRateResponse = await this.fetchExchangeRate(\n          currentCurrency,\n          nativeCurrencyForExchangeRate,\n          this.includeUsdRate,\n        );\n        conversionRate = fetchExchangeRateResponse.conversionRate;\n        usdConversionRate = fetchExchangeRateResponse.usdConversionRate;\n        conversionDate = Date.now() / 1000;\n      }\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('market does not exist for this coin pair')\n        )\n      ) {\n        throw error;\n      }\n    } finally {\n      try {\n        this.update(() => {\n          return {\n            currencyRates: {\n              ...currencyRates,\n              [nativeCurrency]: {\n                conversionDate,\n                conversionRate,\n                usdConversionRate,\n              },\n            },\n            currentCurrency,\n          };\n        });\n      } finally {\n        releaseLock();\n      }\n    }\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopAllPolling();\n  }\n\n  /**\n   * Updates exchange rate for the current currency.\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      networkClientId,\n    );\n    await this.updateExchangeRate(networkClient.configuration.ticker);\n  }\n}\n\nexport default CurrencyRateController;\n"]}