{"version":3,"sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type {\n  AccountsControllerSelectedEvmAccountChangeEvent,\n  AccountsControllerGetAccountAction,\n  AccountsControllerGetSelectedAccountAction,\n} from '@metamask/accounts-controller';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  RestrictedControllerMessenger,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport {\n  BaseController,\n  type ControllerGetStateAction,\n} from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  ApprovalType,\n  NFT_API_BASE_URL,\n  NFT_API_VERSION,\n} from '@metamask/controller-utils';\nimport { type InternalAccount } from '@metamask/keyring-api';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type {\n  PreferencesControllerStateChangeEvent,\n  PreferencesState,\n} from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { v4 as random } from 'uuid';\n\nimport type {\n  AssetsContractControllerGetERC1155BalanceOfAction,\n  AssetsContractControllerGetERC1155TokenURIAction,\n  AssetsContractControllerGetERC721AssetNameAction,\n  AssetsContractControllerGetERC721AssetSymbolAction,\n  AssetsContractControllerGetERC721OwnerOfAction,\n  AssetsContractControllerGetERC721TokenURIAction,\n} from './AssetsContractController';\nimport {\n  compareNftMetadata,\n  getFormattedIpfsUrl,\n  hasNewCollectionFields,\n} from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftContract,\n  ReservoirResponse,\n  Collection,\n  Attributes,\n  LastSale,\n  GetCollectionsResponse,\n  TopBid,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\nexport type Nft =\n  | {\n      tokenId: string;\n      address: string;\n      isCurrentlyOwned?: boolean;\n    } & NftMetadata;\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport type NftContract = {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n};\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\nexport type NftMetadata = {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: string;\n  transactionId?: string;\n  tokenURI?: string | null;\n  collection?: Collection;\n  address?: string;\n  attributes?: Attributes[];\n  lastSale?: LastSale;\n  rarityRank?: string;\n  topBid?: TopBid;\n};\n\n/**\n * @type NftControllerState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\nexport type NftControllerState = {\n  allNftContracts: {\n    [key: string]: {\n      [chainId: Hex]: NftContract[];\n    };\n  };\n  allNfts: {\n    [key: string]: {\n      [chainId: Hex]: Nft[];\n    };\n  };\n  ignoredNfts: Nft[];\n};\n\nconst nftControllerMetadata = {\n  allNftContracts: { persist: true, anonymous: false },\n  allNfts: { persist: true, anonymous: false },\n  ignoredNfts: { persist: true, anonymous: false },\n};\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\ntype NftAsset = {\n  address: string;\n  tokenId: string;\n};\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\nexport type NftControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  NftControllerState\n>;\nexport type NftControllerActions = NftControllerGetStateAction;\n\n/**\n * The external actions available to the {@link NftController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | AccountsControllerGetAccountAction\n  | AccountsControllerGetSelectedAccountAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | AssetsContractControllerGetERC721AssetNameAction\n  | AssetsContractControllerGetERC721AssetSymbolAction\n  | AssetsContractControllerGetERC721TokenURIAction\n  | AssetsContractControllerGetERC721OwnerOfAction\n  | AssetsContractControllerGetERC1155BalanceOfAction\n  | AssetsContractControllerGetERC1155TokenURIAction;\n\nexport type AllowedEvents =\n  | PreferencesControllerStateChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | AccountsControllerSelectedEvmAccountChangeEvent;\n\nexport type NftControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  NftControllerState\n>;\n\nexport type NftControllerEvents = NftControllerStateChangeEvent;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  NftControllerActions | AllowedActions,\n  NftControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultNftControllerState = (): NftControllerState => ({\n  allNftContracts: {},\n  allNfts: {},\n  ignoredNfts: [],\n});\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<\n  typeof controllerName,\n  NftControllerState,\n  NftControllerMessenger\n> {\n  readonly #mutex = new Mutex();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  #selectedAccountId: string;\n\n  #chainId: Hex;\n\n  #ipfsGateway: string;\n\n  #openSeaEnabled: boolean;\n\n  #useIpfsSubdomains: boolean;\n\n  #isIpfsGatewayEnabled: boolean;\n\n  readonly #onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ipfsGateway - The configured IPFS gateway.\n   * @param options.openSeaEnabled - Controls whether the OpenSea API is used.\n   * @param options.useIpfsSubdomains - Controls whether IPFS subdomains are used.\n   * @param options.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor({\n    chainId: initialChainId,\n    ipfsGateway = IPFS_DEFAULT_GATEWAY_URL,\n    openSeaEnabled = false,\n    useIpfsSubdomains = true,\n    isIpfsGatewayEnabled = true,\n    onNftAdded,\n    messenger,\n    state = {},\n  }: {\n    chainId: Hex;\n    ipfsGateway?: string;\n    openSeaEnabled?: boolean;\n    useIpfsSubdomains?: boolean;\n    isIpfsGatewayEnabled?: boolean;\n    onNftAdded?: (data: {\n      address: string;\n      symbol: string | undefined;\n      tokenId: string;\n      standard: string | null;\n      source: string;\n    }) => void;\n    messenger: NftControllerMessenger;\n    state?: Partial<NftControllerState>;\n  }) {\n    super({\n      name: controllerName,\n      metadata: nftControllerMetadata,\n      messenger,\n      state: {\n        ...getDefaultNftControllerState(),\n        ...state,\n      },\n    });\n\n    this.#selectedAccountId = this.messagingSystem.call(\n      'AccountsController:getSelectedAccount',\n    ).id;\n    this.#chainId = initialChainId;\n    this.#ipfsGateway = ipfsGateway;\n    this.#openSeaEnabled = openSeaEnabled;\n    this.#useIpfsSubdomains = useIpfsSubdomains;\n    this.#isIpfsGatewayEnabled = isIpfsGatewayEnabled;\n    this.#onNftAdded = onNftAdded;\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      this.#onPreferencesControllerStateChange.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      this.#onNetworkControllerNetworkDidChange.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'AccountsController:selectedEvmAccountChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      this.#onSelectedAccountChange.bind(this),\n    );\n  }\n\n  /**\n   * Handles the network change on the network controller.\n   * @param networkState - The new state of the preference controller.\n   * @param networkState.selectedNetworkClientId - The current selected network client id.\n   */\n  #onNetworkControllerNetworkDidChange({\n    selectedNetworkClientId,\n  }: NetworkState) {\n    const {\n      configuration: { chainId },\n    } = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      selectedNetworkClientId,\n    );\n    this.#chainId = chainId;\n  }\n\n  /**\n   * Handles the state change of the preference controller.\n   * @param preferencesState - The new state of the preference controller.\n   * @param preferencesState.ipfsGateway - The configured IPFS gateway.\n   * @param preferencesState.openSeaEnabled - Controls whether the OpenSea API is used.\n   * @param preferencesState.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.\n   */\n  async #onPreferencesControllerStateChange({\n    ipfsGateway,\n    openSeaEnabled,\n    isIpfsGatewayEnabled,\n  }: PreferencesState) {\n    const selectedAccount = this.messagingSystem.call(\n      'AccountsController:getSelectedAccount',\n    );\n    this.#selectedAccountId = selectedAccount.id;\n    this.#ipfsGateway = ipfsGateway;\n    this.#openSeaEnabled = openSeaEnabled;\n    this.#isIpfsGatewayEnabled = isIpfsGatewayEnabled;\n\n    const needsUpdateNftMetadata =\n      (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;\n\n    if (needsUpdateNftMetadata && selectedAccount) {\n      await this.#updateNftUpdateForAccount(selectedAccount);\n    }\n  }\n\n  /**\n   * Handles the selected account change on the accounts controller.\n   * @param internalAccount - The new selected account.\n   */\n  async #onSelectedAccountChange(internalAccount: InternalAccount) {\n    const oldSelectedAccountId = this.#selectedAccountId;\n    this.#selectedAccountId = internalAccount.id;\n\n    const needsUpdateNftMetadata =\n      ((this.#isIpfsGatewayEnabled && this.#ipfsGateway !== '') ||\n        this.#openSeaEnabled) &&\n      oldSelectedAccountId !== internalAccount.id;\n\n    if (needsUpdateNftMetadata) {\n      await this.#updateNftUpdateForAccount(internalAccount);\n    }\n  }\n\n  getNftApi() {\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return `${NFT_API_BASE_URL}/tokens`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  #updateNestedNftState<\n    Key extends typeof ALL_NFTS_STATE_KEY | typeof ALL_NFTS_CONTRACTS_STATE_KEY,\n    NftCollection extends Key extends typeof ALL_NFTS_STATE_KEY\n      ? Nft[]\n      : NftContract[],\n  >(\n    newCollection: NftCollection,\n    baseStateKey: Key,\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    // userAddress can be an empty string if it is not set via an account change or in constructor\n    // while this doesn't cause any issues, we want to ensure that we don't store assets to an empty string address\n    if (!userAddress) {\n      return;\n    }\n\n    this.update((state) => {\n      const oldState = state[baseStateKey];\n      const addressState = oldState[userAddress] || {};\n      const newAddressState = {\n        ...addressState,\n        [chainId]: newCollection,\n      };\n      state[baseStateKey] = {\n        ...oldState,\n        [userAddress]: newAddressState,\n      };\n    });\n  }\n\n  /**\n   * Request individual NFT information from NFT API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  async #getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the nft-api\n    const urlParams = new URLSearchParams({\n      chainIds: '1',\n      tokens: `${contractAddress}:${tokenId}`,\n      includeTopBid: 'true',\n      includeAttributes: 'true',\n      includeLastSale: 'true',\n    }).toString();\n\n    // First fetch token information\n    const nftInformation: ReservoirResponse | undefined =\n      await fetchWithErrorHandling({\n        url: `${this.getNftApi()}?${urlParams}`,\n        options: {\n          headers: {\n            Version: NFT_API_VERSION,\n          },\n        },\n      });\n    // Params for getCollections API call\n    const getCollectionParams = new URLSearchParams({\n      chainId: '1',\n      id: `${nftInformation?.tokens[0]?.token?.collection?.id as string}`,\n    }).toString();\n    // Fetch collection information using collectionId\n    const collectionInformation: GetCollectionsResponse | undefined =\n      await fetchWithErrorHandling({\n        url: `${NFT_API_BASE_URL as string}/collections?${getCollectionParams}`,\n        options: {\n          headers: {\n            Version: NFT_API_VERSION,\n          },\n        },\n      });\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.tokens?.[0]?.token) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n\n    const {\n      image,\n      metadata: { imageOriginal } = {},\n      name,\n      description,\n      collection,\n      kind,\n      rarityRank,\n      rarity,\n      attributes,\n      lastSale,\n      imageSmall,\n    } = nftInformation.tokens[0].token;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image || null },\n      collection?.creator && { creator: collection.creator },\n      imageOriginal && { imageOriginal },\n      imageSmall && { imageThumbnail: imageSmall },\n      kind && { standard: kind.toUpperCase() },\n      lastSale && { lastSale },\n      attributes && { attributes },\n      nftInformation.tokens[0].market?.topBid && {\n        topBid: nftInformation.tokens[0].market?.topBid,\n      },\n      rarityRank && { rarityRank },\n      rarity && { rarity },\n      (collection || collectionInformation) && {\n        collection: {\n          ...(collection || {}),\n          creator:\n            collection?.creator ||\n            collectionInformation?.collections[0].creator,\n          openseaVerificationStatus:\n            collectionInformation?.collections[0].openseaVerificationStatus,\n          contractDeployedAt:\n            collectionInformation?.collections[0].contractDeployedAt,\n          ownerCount: collectionInformation?.collections[0].ownerCount,\n          topBid: collectionInformation?.collections[0].topBid,\n        },\n      },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  async #getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const result = await this.#getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !this.#isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    const isDisplayNFTMediaToggleEnabled = this.#openSeaEnabled;\n    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = await getFormattedIpfsUrl(\n        this.#ipfsGateway,\n        tokenURI,\n        this.#useIpfsSubdomains,\n      );\n    }\n    if (tokenURI.startsWith('data:image/')) {\n      return {\n        image: tokenURI,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  async #getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.messagingSystem.call(\n        'AssetsContractController:getERC721TokenURI',\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.messagingSystem.call(\n        'AssetsContractController:getERC1155TokenURI',\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  async #getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.#getCorrectChainId({\n      networkClientId,\n    });\n    const [blockchainMetadata, nftApiMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.#getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.#openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.#getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n    return {\n      ...nftApiMetadata,\n      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,\n      image: nftApiMetadata?.image ?? blockchainMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  async #getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.messagingSystem.call(\n        'AssetsContractController:getERC721AssetName',\n        contractAddress,\n        networkClientId,\n      ),\n      this.messagingSystem.call(\n        'AssetsContractController:getERC721AssetSymbol',\n        contractAddress,\n        networkClientId,\n      ),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  async #getNftContractInformation(\n    contractAddress: string,\n    nftMetadataFromApi: NftMetadata,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData = await safelyExecute(() =>\n      this.#getNftContractInformationFromContract(\n        contractAddress,\n        networkClientId,\n      ),\n    );\n\n    if (\n      blockchainContractData ||\n      !Object.values(nftMetadataFromApi).every((value) => value === null)\n    ) {\n      return {\n        address: contractAddress,\n        ...blockchainContractData,\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        schema_name: nftMetadataFromApi?.standard ?? null,\n        collection: {\n          name: null,\n          // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n          // eslint-disable-next-line @typescript-eslint/naming-convention\n          image_url:\n            nftMetadataFromApi?.collection?.image ??\n            nftMetadataFromApi?.collection?.imageUrl ??\n            null,\n          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,\n          ...nftMetadataFromApi?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      asset_contract_type: null,\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      created_date: null,\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      schema_name: null,\n      symbol: null,\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      total_supply: null,\n      description: null,\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      external_link: null,\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns A promise resolving to `undefined`.\n   */\n  async #addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<void> {\n    const releaseLock = await this.#mutex.acquire();\n    try {\n      const checksumHexAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = [...(allNfts[userAddress]?.[chainId] ?? [])];\n\n      const existingEntry = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === checksumHexAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n\n        const hasNewFields = hasNewCollectionFields(nftMetadata, existingEntry);\n\n        if (\n          !differentMetadata &&\n          existingEntry.isCurrentlyOwned &&\n          !hasNewFields\n        ) {\n          return;\n        }\n\n        const indexToUpdate = nfts.findIndex(\n          (nft) =>\n            nft.address.toLowerCase() === checksumHexAddress.toLowerCase() &&\n            nft.tokenId === tokenId,\n        );\n\n        if (indexToUpdate !== -1) {\n          nfts[indexToUpdate] = {\n            ...existingEntry,\n            ...nftMetadata,\n          };\n        }\n      } else {\n        const newEntry: Nft = {\n          address: checksumHexAddress,\n          tokenId,\n          favorite: false,\n          isCurrentlyOwned: true,\n          ...nftMetadata,\n        };\n\n        nfts.push(newEntry);\n      }\n\n      this.#updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.#onNftAdded) {\n        this.#onNftAdded({\n          address: checksumHexAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.nftMetadata - The retrieved NFTMetadata from API.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  async #addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n    nftMetadata,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    nftMetadata: NftMetadata;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.#mutex.acquire();\n    try {\n      const checksumHexAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.#getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() ===\n          checksumHexAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      // get name and symbol if ERC721 then put together the metadata\n      const contractInformation = await this.#getNftContractInformation(\n        checksumHexAddress,\n        nftMetadata,\n        networkClientId,\n      );\n      const {\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        asset_contract_type,\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        created_date,\n        symbol,\n        description,\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        external_link,\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        schema_name,\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        collection: { name, image_url, tokenCount },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: checksumHexAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        tokenCount !== null &&\n          typeof tokenCount !== 'undefined' && { totalSupply: tokenCount },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.#updateNestedNftState(\n        newNftContracts,\n        ALL_NFTS_CONTRACTS_STATE_KEY,\n        {\n          chainId,\n          userAddress,\n        },\n      );\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  #removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    const checksumHexAddress = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === checksumHexAddress.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === checksumHexAddress && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.#updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update((state) => {\n      state.ignoredNfts = newIgnoredNfts;\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  #removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    const checksumHexAddress = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === checksumHexAddress.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.#updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  #removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    const checksumHexAddress = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(\n          nftContract.address.toLowerCase() === checksumHexAddress.toLowerCase()\n        ),\n    );\n    this.#updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  async #validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  #getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      const {\n        configuration: { chainId },\n      } = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n      return chainId;\n    }\n    return this.#chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {},\n  ) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n    if (!addressToSearch) {\n      return;\n    }\n\n    await this.#validateWatchNft(asset, type, addressToSearch);\n\n    const nftMetadata = await this.#getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: addressToSearch,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.messagingSystem.call(\n        'AssetsContractController:getERC721OwnerOf',\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.messagingSystem.call(\n        'AssetsContractController:getERC1155BalanceOf',\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {},\n  ) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n\n    if (\n      !(await this.isNftOwner(addressToSearch, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress: addressToSearch,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = {},\n  ) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n    if (!addressToSearch) {\n      return;\n    }\n\n    const checksumHexAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.#getCorrectChainId({ networkClientId });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.#getNftInformation(\n        checksumHexAddress,\n        tokenId,\n        networkClientId,\n      ));\n\n    const newNftContracts = await this.#addNftContract({\n      tokenAddress: checksumHexAddress,\n      userAddress: addressToSearch,\n      networkClientId,\n      source,\n      nftMetadata,\n    });\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === checksumHexAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.#addIndividualNft(\n        checksumHexAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        addressToSearch,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.nfts - nfts to update metadata for.\n   * @param options.userAddress - The current user address\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   */\n  async updateNftMetadata({\n    nfts,\n    userAddress,\n    networkClientId,\n  }: {\n    nfts: Nft[];\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n  }) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n\n    const releaseLock = await this.#mutex.acquire();\n\n    try {\n      const chainId = this.#getCorrectChainId({ networkClientId });\n\n      const nftsWithChecksumAdr = nfts.map((nft) => {\n        return {\n          ...nft,\n          address: toChecksumHexAddress(nft.address),\n        };\n      });\n      const nftMetadataResults = await Promise.all(\n        nftsWithChecksumAdr.map(async (nft) => {\n          const resMetadata = await this.#getNftInformation(\n            nft.address,\n            nft.tokenId,\n            networkClientId,\n          );\n          return {\n            nft,\n            newMetadata: resMetadata,\n          };\n        }),\n      );\n\n      // We want to avoid updating the state if the state and fetched nft info are the same\n      const nftsWithDifferentMetadata: NftUpdate[] = [];\n      const { allNfts } = this.state;\n      const stateNfts = allNfts[addressToSearch]?.[chainId] || [];\n\n      nftMetadataResults.forEach((singleNft) => {\n        const existingEntry: Nft | undefined = stateNfts.find(\n          (nft) =>\n            nft.address.toLowerCase() === singleNft.nft.address.toLowerCase() &&\n            nft.tokenId === singleNft.nft.tokenId,\n        );\n\n        if (existingEntry) {\n          const differentMetadata = compareNftMetadata(\n            singleNft.newMetadata,\n            existingEntry,\n          );\n\n          if (differentMetadata) {\n            nftsWithDifferentMetadata.push(singleNft);\n          }\n        }\n      });\n\n      if (nftsWithDifferentMetadata.length !== 0) {\n        nftsWithDifferentMetadata.forEach((elm) =>\n          this.updateNft(elm.nft, elm.newMetadata, addressToSearch, chainId),\n        );\n      }\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {},\n  ) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n    const chainId = this.#getCorrectChainId({ networkClientId });\n    const checksumHexAddress = toChecksumHexAddress(address);\n    this.#removeIndividualNft(checksumHexAddress, tokenId, {\n      chainId,\n      userAddress: addressToSearch,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[addressToSearch]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === checksumHexAddress.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.#removeNftContract(checksumHexAddress, {\n        chainId,\n        userAddress: addressToSearch,\n      });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {},\n  ) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n    const chainId = this.#getCorrectChainId({ networkClientId });\n    const checksumHexAddress = toChecksumHexAddress(address);\n    this.#removeAndIgnoreIndividualNft(checksumHexAddress, tokenId, {\n      chainId,\n      userAddress: addressToSearch,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[addressToSearch]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === checksumHexAddress.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.#removeNftContract(checksumHexAddress, {\n        chainId,\n        userAddress: addressToSearch,\n      });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update((state) => {\n      state.ignoredNfts = [];\n    });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {},\n  ) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n    const chainId = this.#getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(addressToSearch, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    const updatedNft = {\n      ...nft,\n      isCurrentlyOwned: isOwned,\n    };\n\n    if (batch) {\n      return updatedNft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = [...(allNfts[addressToSearch]?.[chainId] || [])];\n    const indexToUpdate = nfts.findIndex(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (indexToUpdate !== -1) {\n      nfts[indexToUpdate] = updatedNft;\n      this.update((state) => {\n        state.allNfts[addressToSearch] = Object.assign(\n          {},\n          state.allNfts[addressToSearch],\n          {\n            [chainId]: nfts,\n          },\n        );\n      });\n      this.#updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress: addressToSearch,\n        chainId,\n      });\n    }\n\n    return updatedNft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus({\n    networkClientId,\n    userAddress,\n  }: {\n    networkClientId?: NetworkClientId;\n    userAddress?: string;\n  } = {}) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n    const chainId = this.#getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[addressToSearch]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.#updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress: addressToSearch,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {},\n  ) {\n    const addressToSearch = this.#getAddressOrSelectedAddress(userAddress);\n    const chainId = this.#getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = [...(allNfts[addressToSearch]?.[chainId] || [])];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.#updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: addressToSearch,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n    this.#updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.#updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n\n  #getAddressOrSelectedAddress(address: string | undefined): string {\n    if (address) {\n      return address;\n    }\n\n    // If the address is not defined (or empty), we fallback to the currently selected account's address\n    const selectedAccount = this.messagingSystem.call(\n      'AccountsController:getAccount',\n      this.#selectedAccountId,\n    );\n    return selectedAccount?.address || '';\n  }\n\n  async #updateNftUpdateForAccount(account: InternalAccount) {\n    const nfts: Nft[] =\n      this.state.allNfts[account.address]?.[this.#chainId] ?? [];\n\n    // Filter only nfts\n    const nftsToUpdate = nfts.filter(\n      (singleNft) =>\n        !singleNft.name && !singleNft.description && !singleNft.image,\n    );\n    if (nftsToUpdate.length !== 0) {\n      await this.updateNftMetadata({\n        nfts: nftsToUpdate,\n        userAddress: account.address,\n      });\n    }\n  }\n}\n\nexport default NftController;\n"]}