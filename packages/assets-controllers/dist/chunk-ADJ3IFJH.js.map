{"version":3,"sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type {\n  AccountsControllerGetAccountAction,\n  AccountsControllerGetSelectedAccountAction,\n  AccountsControllerSelectedEvmAccountChangeEvent,\n} from '@metamask/accounts-controller';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n  ERC721,\n  ERC1155,\n  isValidHexAddress,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport type { InternalAccount } from '@metamask/keyring-api';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  NetworkState,\n  Provider,\n} from '@metamask/network-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { v1 as random } from 'uuid';\n\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListStateChange,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensControllerState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport type TokensControllerState = {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n};\n\nconst metadata = {\n  tokens: {\n    persist: true,\n    anonymous: false,\n  },\n  ignoredTokens: {\n    persist: true,\n    anonymous: false,\n  },\n  detectedTokens: {\n    persist: true,\n    anonymous: false,\n  },\n  allTokens: {\n    persist: true,\n    anonymous: false,\n  },\n  allIgnoredTokens: {\n    persist: true,\n    anonymous: false,\n  },\n  allDetectedTokens: {\n    persist: true,\n    anonymous: false,\n  },\n};\n\nconst controllerName = 'TokensController';\n\nexport type TokensControllerActions =\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\nexport type TokensControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokensControllerState\n>;\n\nexport type TokensControllerAddDetectedTokensAction = {\n  type: `${typeof controllerName}:addDetectedTokens`;\n  handler: TokensController['addDetectedTokens'];\n};\n\n/**\n * The external actions available to the {@link TokensController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerGetNetworkClientByIdAction\n  | AccountsControllerGetAccountAction\n  | AccountsControllerGetSelectedAccountAction;\n\nexport type TokensControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  TokensControllerState\n>;\n\nexport type TokensControllerEvents = TokensControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerNetworkDidChangeEvent\n  | TokenListStateChange\n  | AccountsControllerSelectedEvmAccountChangeEvent;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokensControllerActions | AllowedActions,\n  TokensControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultTokensState = (): TokensControllerState => {\n  return {\n    tokens: [],\n    ignoredTokens: [],\n    detectedTokens: [],\n    allTokens: {},\n    allIgnoredTokens: {},\n    allDetectedTokens: {},\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseController<\n  typeof controllerName,\n  TokensControllerState,\n  TokensControllerMessenger\n> {\n  readonly #mutex = new Mutex();\n\n  #chainId: Hex;\n\n  #selectedAccountId: string;\n\n  #provider: Provider | undefined;\n\n  #abortController: AbortController;\n\n  /**\n   * Tokens controller options\n   * @param options - Constructor options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.provider - Network provider.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    provider,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    provider: Provider | undefined;\n    state?: Partial<TokensControllerState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super({\n      name: controllerName,\n      metadata,\n      messenger,\n      state: {\n        ...getDefaultTokensState(),\n        ...state,\n      },\n    });\n\n    this.#chainId = initialChainId;\n\n    this.#provider = provider;\n\n    this.#selectedAccountId = this.#getSelectedAccount().id;\n\n    this.#abortController = new AbortController();\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:addDetectedTokens` as const,\n      this.addDetectedTokens.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'AccountsController:selectedEvmAccountChange',\n      this.#onSelectedAccountChange.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      this.#onNetworkDidChange.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      ({ tokenList }) => {\n        const { tokens } = this.state;\n        if (tokens.length && !tokens[0].name) {\n          this.#updateTokensAttribute(tokenList, 'name');\n        }\n      },\n    );\n  }\n\n  /**\n   * Handles the event when the network changes.\n   *\n   * @param networkState - The changed network state.\n   * @param networkState.selectedNetworkClientId - The ID of the currently\n   * selected network client.\n   */\n  #onNetworkDidChange({ selectedNetworkClientId }: NetworkState) {\n    const selectedNetworkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      selectedNetworkClientId,\n    );\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId } = selectedNetworkClient.configuration;\n    this.#abortController.abort();\n    this.#abortController = new AbortController();\n    this.#chainId = chainId;\n    const selectedAddress = this.#getSelectedAddress();\n    this.update((state) => {\n      state.tokens = allTokens[chainId]?.[selectedAddress] || [];\n      state.ignoredTokens = allIgnoredTokens[chainId]?.[selectedAddress] || [];\n      state.detectedTokens =\n        allDetectedTokens[chainId]?.[selectedAddress] || [];\n    });\n  }\n\n  /**\n   * Handles the selected account change in the accounts controller.\n   * @param selectedAccount - The new selected account\n   */\n  #onSelectedAccountChange(selectedAccount: InternalAccount) {\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    this.#selectedAccountId = selectedAccount.id;\n    this.update((state) => {\n      state.tokens = allTokens[this.#chainId]?.[selectedAccount.address] ?? [];\n      state.ignoredTokens =\n        allIgnoredTokens[this.#chainId]?.[selectedAccount.address] ?? [];\n      state.detectedTokens =\n        allDetectedTokens[this.#chainId]?.[selectedAccount.address] ?? [];\n    });\n  }\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  async #fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.#chainId,\n        tokenAddress,\n        this.#abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const chainId = this.#chainId;\n    const releaseLock = await this.#mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      ).configuration.chainId;\n    }\n\n    const accountAddress =\n      this.#getAddressOrSelectedAddress(interactingAddress);\n    const isInteractingWithWalletAccount =\n      this.#isInteractingWithWallet(accountAddress);\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this.#detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.#fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.#chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this.#getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensControllerState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update((state) => {\n        Object.assign(state, newState);\n      });\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.#mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        ).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this.#getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update((state) => {\n        state.tokens = newTokens;\n        state.allTokens = newAllTokens;\n        state.detectedTokens = newDetectedTokens;\n        state.allDetectedTokens = newAllDetectedTokens;\n        state.ignoredTokens = newIgnoredTokens;\n        state.allIgnoredTokens = newAllIgnoredTokens;\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this.#getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update((state) => {\n      state.ignoredTokens = newIgnoredTokens;\n      state.tokens = newTokens;\n      state.detectedTokens = newDetectedTokens;\n      state.allIgnoredTokens = newAllIgnoredTokens;\n      state.allDetectedTokens = newAllDetectedTokens;\n      state.allTokens = newAllTokens;\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.#mutex.acquire();\n\n    const chainId = detectionDetails?.chainId ?? this.#chainId;\n    // Previously selectedAddress could be an empty string. This is to preserve the behaviour\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.#getSelectedAddress();\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this.#getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const selectedAddress = this.#getSelectedAddress();\n\n      newTokens = newAllTokens?.[this.#chainId]?.[selectedAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[this.#chainId]?.[selectedAddress] || [];\n\n      this.update((state) => {\n        state.tokens = newTokens;\n        state.allTokens = newAllTokens;\n        state.detectedTokens = newDetectedTokens;\n        state.allDetectedTokens = newAllDetectedTokens;\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this.#detectIsERC721(tokenAddress);\n    const tokens = [...this.state.tokens];\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    const updatedToken = { ...tokens[tokenIndex], isERC721 };\n    tokens[tokenIndex] = updatedToken;\n    this.update((state) => {\n      state.tokens = tokens;\n    });\n    return updatedToken;\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  #updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update((state) => {\n      state.tokens = newTokens;\n    });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async #detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this.#createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  #getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    return new Web3Provider(\n      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n      networkClientId\n        ? this.messagingSystem.call(\n            'NetworkController:getNetworkClientById',\n            networkClientId,\n          ).provider\n        : this.#provider,\n    );\n  }\n\n  #createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const web3provider = this.#getProvider(networkClientId);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  #generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    if (!asset.address) {\n      throw rpcErrors.invalidParams('Address must be specified');\n    }\n\n    if (!isValidHexAddress(asset.address)) {\n      throw rpcErrors.invalidParams(`Invalid address \"${asset.address}\"`);\n    }\n\n    const selectedAddress =\n      this.#getAddressOrSelectedAddress(interactingAddress);\n\n    // Validate contract\n\n    if (await this.#detectIsERC721(asset.address, networkClientId)) {\n      throw rpcErrors.invalidParams(\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`,\n      );\n    }\n\n    const provider = this.#getProvider(networkClientId);\n    const isErc1155 = await safelyExecute(() =>\n      new ERC1155Standard(provider).contractSupportsBase1155Interface(\n        asset.address,\n      ),\n    );\n    if (isErc1155) {\n      throw rpcErrors.invalidParams(\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`,\n      );\n    }\n\n    const erc20 = new ERC20Standard(provider);\n    const [contractName, contractSymbol, contractDecimals] = await Promise.all([\n      safelyExecute(() => erc20.getTokenName(asset.address)),\n      safelyExecute(() => erc20.getTokenSymbol(asset.address)),\n      safelyExecute(async () => erc20.getTokenDecimals(asset.address)),\n    ]);\n\n    asset.name = contractName;\n\n    // Validate symbol\n\n    if (!asset.symbol && !contractSymbol) {\n      throw rpcErrors.invalidParams(\n        'A symbol is required, but was not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractSymbol !== undefined &&\n      asset.symbol !== undefined &&\n      asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()\n    ) {\n      throw rpcErrors.invalidParams(\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`,\n      );\n    }\n\n    asset.symbol = contractSymbol ?? asset.symbol;\n    if (typeof asset.symbol !== 'string') {\n      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);\n    }\n\n    if (asset.symbol.length > 11) {\n      throw rpcErrors.invalidParams(\n        `Invalid symbol \"${asset.symbol}\": longer than 11 characters`,\n      );\n    }\n\n    // Validate decimals\n\n    if (asset.decimals === undefined && contractDecimals === undefined) {\n      throw rpcErrors.invalidParams(\n        'Decimals are required, but were not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractDecimals !== undefined &&\n      asset.decimals !== undefined &&\n      String(asset.decimals) !== contractDecimals\n    ) {\n      throw rpcErrors.invalidParams(\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`,\n      );\n    }\n\n    const decimalsStr = contractDecimals ?? asset.decimals;\n    const decimalsNum = parseInt(decimalsStr as unknown as string, 10);\n    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {\n      throw rpcErrors.invalidParams(\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Invalid decimals \"${decimalsStr}\": must be an integer 0 <= 36`,\n      );\n    }\n    asset.decimals = decimalsNum;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this.#generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: selectedAddress,\n    };\n\n    await this.#requestApproval(suggestedAssetMeta);\n\n    const { address, symbol, decimals, name, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  #getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n\n    const userAddressToAddTokens =\n      this.#getAddressOrSelectedAddress(interactingAddress);\n\n    const chainIdToAddTokens = interactingChainId ?? this.#chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  #getAddressOrSelectedAddress(address: string | undefined): string {\n    if (address) {\n      return address;\n    }\n\n    return this.#getSelectedAddress();\n  }\n\n  #isInteractingWithWallet(address: string | undefined) {\n    const selectedAddress = this.#getSelectedAddress();\n\n    return selectedAddress === address;\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update((state) => {\n      state.ignoredTokens = [];\n      state.allIgnoredTokens = {};\n    });\n  }\n\n  async #requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n\n  #getSelectedAccount() {\n    return this.messagingSystem.call('AccountsController:getSelectedAccount');\n  }\n\n  #getSelectedAddress() {\n    // If the address is not defined (or empty), we fallback to the currently selected account's address\n    const account = this.messagingSystem.call(\n      'AccountsController:getAccount',\n      this.#selectedAccountId,\n    );\n    return account?.address || '';\n  }\n}\n\nexport default TokensController;\n"]}