{"version":3,"sources":["../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"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","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n  CircuitState,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolívar fuerte\n  'vef',\n  // Vietnamese đồng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * Represents the zero address, commonly used as a placeholder in blockchain transactions.\n * In the context of fetching market data, the zero address is utilized to retrieve information\n * specifically for native currencies. This allows for a standardized approach to query market\n * data for blockchain-native assets without a specific contract address.\n */\nexport const ZERO_ADDRESS: Hex =\n  '0x0000000000000000000000000000000000000000' as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n * @see Used by {@link CodefiTokenPricesServiceV2} to validate that a given chain ID is supported by V2 of the Codefi Price API.\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Mantle\n  '0x1388',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n  // Linea Mainnet\n  '0xe708',\n] as const;\n\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price.api.cx.metamask.io/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\nconst DEFAULT_DEGRADED_THRESHOLD = 5_000;\n\n/**\n * The shape of the data that the /spot-prices endpoint returns.\n */\ntype MarketData = {\n  /**\n   * The all-time highest price of the token.\n   */\n  allTimeHigh: number;\n  /**\n   * The all-time lowest price of the token.\n   */\n  allTimeLow: number;\n  /**\n   * The number of tokens currently in circulation.\n   */\n  circulatingSupply: number;\n  /**\n   * The market cap calculated using the diluted supply.\n   */\n  dilutedMarketCap: number;\n  /**\n   * The highest price of the token in the last 24 hours.\n   */\n  high1d: number;\n  /**\n   * The lowest price of the token in the last 24 hours.\n   */\n  low1d: number;\n  /**\n   * The current market capitalization of the token.\n   */\n  marketCap: number;\n  /**\n   * The percentage change in market capitalization over the last 24 hours.\n   */\n  marketCapPercentChange1d: number;\n  /**\n   * The current price of the token.\n   */\n  price: number;\n  /**\n   * The absolute change in price over the last 24 hours.\n   */\n  priceChange1d: number;\n  /**\n   * The percentage change in price over the last 24 hours.\n   */\n  pricePercentChange1d: number;\n  /**\n   * The percentage change in price over the last hour.\n   */\n  pricePercentChange1h: number;\n  /**\n   * The percentage change in price over the last year.\n   */\n  pricePercentChange1y: number;\n  /**\n   * The percentage change in price over the last 7 days.\n   */\n  pricePercentChange7d: number;\n  /**\n   * The percentage change in price over the last 14 days.\n   */\n  pricePercentChange14d: number;\n  /**\n   * The percentage change in price over the last 30 days.\n   */\n  pricePercentChange30d: number;\n  /**\n   * The percentage change in price over the last 200 days.\n   */\n  pricePercentChange200d: number;\n  /**\n   * The total trading volume of the token in the last 24 hours.\n   */\n  totalVolume: number;\n};\n\ntype MarketDataByTokenAddress = { [address: Hex]: MarketData };\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.degradedThreshold - The threshold between \"normal\" and \"degrated\" service,\n   * in milliseconds.\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing\n   * metrics about network failures.\n   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests\n   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    onBreak,\n    onDegraded,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    degradedThreshold?: number;\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    onBreak?: () => void;\n    onDegraded?: () => void;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    if (onBreak) {\n      circuitBreakerPolicy.onBreak(onBreak);\n    }\n    if (onDegraded) {\n      retryPolicy.onGiveUp(() => {\n        if (circuitBreakerPolicy.state === CircuitState.Closed) {\n          onDegraded();\n        }\n      });\n      retryPolicy.onSuccess(({ duration }) => {\n        if (\n          circuitBreakerPolicy.state === CircuitState.Closed &&\n          duration > degradedThreshold\n        ) {\n          onDegraded();\n        }\n      });\n    }\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append(\n      'tokenAddresses',\n      [ZERO_ADDRESS, ...tokenAddresses].join(','),\n    );\n    url.searchParams.append('vsCurrency', currency);\n    url.searchParams.append('includeMarketData', 'true');\n\n    const addressCryptoDataMap: MarketDataByTokenAddress =\n      await this.#tokenPricePolicy.execute(() =>\n        handleFetch(url, { headers: { 'Cache-Control': 'no-cache' } }),\n      );\n\n    return [ZERO_ADDRESS, ...tokenAddresses].reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n\n        const marketData = addressCryptoDataMap[lowercasedTokenAddress];\n\n        if (!marketData) {\n          return obj;\n        }\n\n        const token: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          currency,\n          ...marketData,\n        };\n\n        return {\n          ...obj,\n          [tokenAddress]: token,\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"]}