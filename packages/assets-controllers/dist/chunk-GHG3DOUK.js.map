{"version":3,"sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type {\n  ActionConstraint,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { IPFS_DEFAULT_GATEWAY_URL } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerGetSelectedNetworkClientAction,\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkDidChangeEvent,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';\nimport { getKnownPropertyNames, type Hex } from '@metamask/utils';\nimport type BN from 'bn.js';\nimport abiSingleCallBalancesContract from 'single-call-balance-checker-abi';\n\nimport { SupportedTokenDetectionNetworks } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';\n\n/**\n * Check if token detection is enabled for certain networks\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {\n  [SupportedTokenDetectionNetworks.mainnet]:\n    '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',\n  [SupportedTokenDetectionNetworks.bsc]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.polygon]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.avax]:\n    '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',\n  [SupportedTokenDetectionNetworks.aurora]:\n    '0x1286415D333855237f89Df27D388127181448538',\n  [SupportedTokenDetectionNetworks.linea_goerli]:\n    '0x10dAd7Ca3921471f616db788D9300DC97Db01783',\n  [SupportedTokenDetectionNetworks.linea_mainnet]:\n    '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',\n  [SupportedTokenDetectionNetworks.arbitrum]:\n    '0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c',\n  [SupportedTokenDetectionNetworks.optimism]:\n    '0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',\n  [SupportedTokenDetectionNetworks.base]:\n    '0x6AA75276052D96696134252587894ef5FFA520af',\n  [SupportedTokenDetectionNetworks.zksync]:\n    '0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34',\n  [SupportedTokenDetectionNetworks.cronos]:\n    '0x768ca200f0fc702ac9ea502498c18f5eff176378',\n  [SupportedTokenDetectionNetworks.celo]:\n    '0x6aa75276052d96696134252587894ef5ffa520af',\n  [SupportedTokenDetectionNetworks.gnosis]:\n    '0x6aa75276052d96696134252587894ef5ffa520af',\n  [SupportedTokenDetectionNetworks.fantom]:\n    '0x6aa75276052d96696134252587894ef5ffa520af',\n  [SupportedTokenDetectionNetworks.polygon_zkevm]:\n    '0x6aa75276052d96696134252587894ef5ffa520af',\n  [SupportedTokenDetectionNetworks.moonbeam]:\n    '0x6aa75276052d96696134252587894ef5ffa520af',\n  [SupportedTokenDetectionNetworks.moonriver]:\n    '0x6aa75276052d96696134252587894ef5ffa520af',\n} as const satisfies Record<Hex, string>;\n\nexport const MISSING_PROVIDER_ERROR =\n  'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';\n\n/**\n * @type BalanceMap\n *\n * Key value object containing the balance for each tokenAddress\n * @property [tokenAddress] - Address of the token\n */\nexport type BalanceMap = {\n  [tokenAddress: string]: BN;\n};\n\n/**\n * The name of the {@link AssetsContractController}\n */\nconst name = 'AssetsContractController';\n\n/**\n * A utility type that derives the public method names of a given messenger consumer class,\n * and uses it to generate the class's internal messenger action types.\n * @template Controller - A messenger consumer class.\n */\n// TODO: Figure out generic constraint and move to base-controller\ntype ControllerActionsMap<Controller> = {\n  [ClassMethod in keyof Controller as Controller[ClassMethod] extends ActionConstraint['handler']\n    ? ClassMethod\n    : never]: {\n    type: `${typeof name}:${ClassMethod & string}`;\n    handler: Controller[ClassMethod];\n  };\n};\n\ntype AssetsContractControllerActionsMap =\n  ControllerActionsMap<AssetsContractController>;\n\n/**\n * The union of all public class method names of {@link AssetsContractController}.\n */\ntype AssetsContractControllerMethodName =\n  keyof AssetsContractControllerActionsMap;\n\n/**\n * The union of all internal messenger actions available to the {@link AssetsContractControllerMessenger}.\n */\nexport type AssetsContractControllerActions =\n  AssetsContractControllerActionsMap[AssetsContractControllerMethodName];\n\nexport type AssetsContractControllerGetERC20StandardAction =\n  AssetsContractControllerActionsMap['getERC20Standard'];\n\nexport type AssetsContractControllerGetERC721StandardAction =\n  AssetsContractControllerActionsMap['getERC721Standard'];\n\nexport type AssetsContractControllerGetERC1155StandardAction =\n  AssetsContractControllerActionsMap['getERC1155Standard'];\n\nexport type AssetsContractControllerGetERC20BalanceOfAction =\n  AssetsContractControllerActionsMap['getERC20BalanceOf'];\n\nexport type AssetsContractControllerGetERC20TokenDecimalsAction =\n  AssetsContractControllerActionsMap['getERC20TokenDecimals'];\n\nexport type AssetsContractControllerGetERC20TokenNameAction =\n  AssetsContractControllerActionsMap['getERC20TokenName'];\n\nexport type AssetsContractControllerGetERC721NftTokenIdAction =\n  AssetsContractControllerActionsMap['getERC721NftTokenId'];\n\nexport type AssetsContractControllerGetERC721TokenURIAction =\n  AssetsContractControllerActionsMap['getERC721TokenURI'];\n\nexport type AssetsContractControllerGetERC721AssetNameAction =\n  AssetsContractControllerActionsMap['getERC721AssetName'];\n\nexport type AssetsContractControllerGetERC721AssetSymbolAction =\n  AssetsContractControllerActionsMap['getERC721AssetSymbol'];\n\nexport type AssetsContractControllerGetERC721OwnerOfAction =\n  AssetsContractControllerActionsMap['getERC721OwnerOf'];\n\nexport type AssetsContractControllerGetERC1155TokenURIAction =\n  AssetsContractControllerActionsMap['getERC1155TokenURI'];\n\nexport type AssetsContractControllerGetERC1155BalanceOfAction =\n  AssetsContractControllerActionsMap['getERC1155BalanceOf'];\n\nexport type AssetsContractControllerTransferSingleERC1155Action =\n  AssetsContractControllerActionsMap['transferSingleERC1155'];\n\nexport type AssetsContractControllerGetTokenStandardAndDetailsAction =\n  AssetsContractControllerActionsMap['getTokenStandardAndDetails'];\n\nexport type AssetsContractControllerGetBalancesInSingleCallAction =\n  AssetsContractControllerActionsMap['getBalancesInSingleCall'];\n\n/**\n * The union of all internal messenger events available to the {@link AssetsContractControllerMessenger}.\n */\nexport type AssetsContractControllerEvents = never;\n\n/**\n * The union of all external messenger actions that must be allowed by the {@link AssetsContractControllerMessenger}.\n */\nexport type AllowedActions =\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetStateAction;\n\n/**\n * The union of all external messenger event that must be allowed by the {@link AssetsContractControllerMessenger}.\n */\nexport type AllowedEvents =\n  | PreferencesControllerStateChangeEvent\n  | NetworkControllerNetworkDidChangeEvent;\n\n/**\n * The messenger of the {@link AssetsContractController}.\n */\nexport type AssetsContractControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  AssetsContractControllerActions | AllowedActions,\n  AssetsContractControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Controller that interacts with contracts on mainnet through web3\n */\nexport class AssetsContractController {\n  protected messagingSystem: AssetsContractControllerMessenger;\n\n  #provider: Provider | undefined;\n\n  #ipfsGateway: string;\n\n  #chainId: Hex;\n\n  /**\n   * Creates a AssetsContractController instance.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The controller messenger.\n   * @param options.chainId - The chain ID of the current network.\n   */\n  constructor({\n    messenger,\n    chainId: initialChainId,\n  }: {\n    messenger: AssetsContractControllerMessenger;\n    chainId: Hex;\n  }) {\n    this.messagingSystem = messenger;\n    this.#provider = undefined;\n    this.#ipfsGateway = IPFS_DEFAULT_GATEWAY_URL;\n    this.#chainId = initialChainId;\n\n    this.#registerActionHandlers();\n    this.#registerEventSubscriptions();\n  }\n\n  // TODO: Expand into base-controller utility function that batch registers action handlers.\n  #registerActionHandlers() {\n    const methodsExcludedFromMessenger = [\n      'constructor',\n      'messagingSystem',\n      'setProvider',\n      'provider',\n      'ipfsGateway',\n      'chainId',\n    ];\n\n    getKnownPropertyNames<keyof this>(Object.getPrototypeOf(this)).forEach(\n      (method) => {\n        if (\n          ((key: keyof this): key is AssetsContractControllerMethodName =>\n            !methodsExcludedFromMessenger.find((e) => e === key) &&\n            typeof this[key] === 'function')(method)\n        ) {\n          this.messagingSystem.registerActionHandler(\n            `${name}:${method}`,\n            // TODO: Write a generic for-loop implementation that iterates over an input union type in tandem with the input array.\n            // @ts-expect-error Both assigned argument and assignee parameter are using the entire union type for `method` instead of the type for the current element\n            this[method].bind(this),\n          );\n        }\n      },\n    );\n  }\n\n  #registerEventSubscriptions() {\n    this.messagingSystem.subscribe(\n      `PreferencesController:stateChange`,\n      ({ ipfsGateway }) => {\n        this.#ipfsGateway = ipfsGateway;\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      `NetworkController:networkDidChange`,\n      ({ selectedNetworkClientId }) => {\n        const chainId = this.#getCorrectChainId(selectedNetworkClientId);\n\n        if (this.#chainId !== chainId) {\n          this.#chainId = chainId;\n          // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n          this.#provider = this.#getCorrectProvider();\n        }\n      },\n    );\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * @param provider - Provider used to create a new underlying Web3 instance\n   */\n  setProvider(provider: Provider | undefined) {\n    this.#provider = provider;\n  }\n\n  get ipfsGateway() {\n    return this.#ipfsGateway;\n  }\n\n  get chainId() {\n    return this.#chainId;\n  }\n\n  /**\n   * Get the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID.\n   * @returns Web3Provider instance.\n   */\n  #getCorrectProvider(networkClientId?: NetworkClientId): Web3Provider {\n    const provider = networkClientId\n      ? this.messagingSystem.call(\n          `NetworkController:getNetworkClientById`,\n          networkClientId,\n        ).provider\n      : this.messagingSystem.call('NetworkController:getSelectedNetworkClient')\n          ?.provider ?? this.#provider;\n\n    if (provider === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n\n    return new Web3Provider(provider);\n  }\n\n  /**\n   * Get the relevant chain ID.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns Hex chain ID.\n   */\n  #getCorrectChainId(networkClientId?: NetworkClientId): Hex {\n    if (networkClientId) {\n      const networkClientConfiguration = this.messagingSystem.call(\n        'NetworkController:getNetworkConfigurationByNetworkClientId',\n        networkClientId,\n      );\n      if (networkClientConfiguration) {\n        return networkClientConfiguration.chainId;\n      }\n    }\n    const { selectedNetworkClientId } = this.messagingSystem.call(\n      'NetworkController:getState',\n    );\n    const networkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      selectedNetworkClientId,\n    );\n    return networkClient.configuration?.chainId ?? this.#chainId;\n  }\n\n  /**\n   * Get a ERC20Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC20Standard instance.\n   */\n  getERC20Standard(networkClientId?: NetworkClientId): ERC20Standard {\n    const provider = this.#getCorrectProvider(networkClientId);\n    return new ERC20Standard(provider);\n  }\n\n  /**\n   * Get a ERC721Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC721Standard instance.\n   */\n  getERC721Standard(networkClientId?: NetworkClientId): ERC721Standard {\n    const provider = this.#getCorrectProvider(networkClientId);\n    return new ERC721Standard(provider);\n  }\n\n  /**\n   * Get a ERC1155Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC1155Standard instance.\n   */\n  getERC1155Standard(networkClientId?: NetworkClientId): ERC1155Standard {\n    const provider = this.#getCorrectProvider(networkClientId);\n    return new ERC1155Standard(provider);\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getERC20BalanceOf(\n    address: string,\n    selectedAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getBalanceOf(address, selectedAddress);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenDecimals(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenDecimals(address);\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenName(address);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  async getERC721NftTokenId(\n    address: string,\n    selectedAddress: string,\n    index: number,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getNftTokenId(address, selectedAddress, index);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param tokenAddress - ERC721 asset contract address.\n   * @param userAddress - Current account public address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.\n   */\n  async getTokenStandardAndDetails(\n    tokenAddress: string,\n    userAddress?: string,\n    tokenId?: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<{\n    standard: string;\n    tokenURI?: string | undefined;\n    symbol?: string | undefined;\n    name?: string | undefined;\n    decimals?: string | undefined;\n    balance?: BN | undefined;\n  }> {\n    // Asserts provider is available\n    this.#getCorrectProvider(networkClientId);\n\n    // ERC721\n    try {\n      const erc721Standard = this.getERC721Standard(networkClientId);\n      return {\n        ...(await erc721Standard.getDetails(\n          tokenAddress,\n          this.#ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC1155\n    try {\n      const erc1155Standard = this.getERC1155Standard(networkClientId);\n      return {\n        ...(await erc1155Standard.getDetails(\n          tokenAddress,\n          this.#ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC20\n    try {\n      const erc20Standard = this.getERC20Standard(networkClientId);\n      return {\n        ...(await erc20Standard.getDetails(tokenAddress, userAddress)),\n      };\n    } catch {\n      // Ignore\n    }\n\n    throw new Error('Unable to determine contract standard');\n  }\n\n  /**\n   * Query for tokenURI for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC721TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getERC721AssetName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetName(address);\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getERC721AssetSymbol(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetSymbol(address);\n  }\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the owner address.\n   */\n  async getERC721OwnerOf(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getOwnerOf(address, tokenId);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC1155TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC 1155 token.\n   *\n   * @param userAddress - Wallet public address.\n   * @param nftAddress - ERC1155 asset contract address.\n   * @param nftId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getERC1155BalanceOf(\n    userAddress: string,\n    nftAddress: string,\n    nftId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   *\n   * @param nftAddress - ERC1155 token address.\n   * @param senderAddress - ERC1155 token sender.\n   * @param recipientAddress - ERC1155 token recipient.\n   * @param nftId - ERC1155 token id.\n   * @param qty - Quantity of tokens to be sent.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'transferSingle' ERC1155 token.\n   */\n  async transferSingleERC1155(\n    nftAddress: string,\n    senderAddress: string,\n    recipientAddress: string,\n    nftId: string,\n    qty: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<void> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.transferSingle(\n      nftAddress,\n      senderAddress,\n      recipientAddress,\n      nftId,\n      qty,\n    );\n  }\n\n  /**\n   * Get the token balance for a list of token addresses in a single call. Only non-zero balances\n   * are returned.\n   *\n   * @param selectedAddress - The address to check token balances for.\n   * @param tokensToDetect - The token addresses to detect balances for.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns The list of non-zero token balances.\n   */\n  async getBalancesInSingleCall(\n    selectedAddress: string,\n    tokensToDetect: string[],\n    networkClientId?: NetworkClientId,\n  ) {\n    const chainId = this.#getCorrectChainId(networkClientId);\n    const provider = this.#getCorrectProvider(networkClientId);\n    if (\n      !((id): id is keyof typeof SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID =>\n        id in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)(chainId)\n    ) {\n      // Only fetch balance if contract address exists\n      return {};\n    }\n    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];\n\n    const contract = new Contract(\n      contractAddress,\n      abiSingleCallBalancesContract,\n      provider,\n    );\n    const result = await contract.balances([selectedAddress], tokensToDetect);\n    const nonZeroBalances: BalanceMap = {};\n    /* istanbul ignore else */\n    if (result.length > 0) {\n      tokensToDetect.forEach((tokenAddress, index) => {\n        const balance: BN = result[index];\n        /* istanbul ignore else */\n        if (String(balance) !== '0') {\n          nonZeroBalances[tokenAddress] = balance;\n        }\n      });\n    }\n    return nonZeroBalances;\n  }\n}\n\nexport default AssetsContractController;\n"]}