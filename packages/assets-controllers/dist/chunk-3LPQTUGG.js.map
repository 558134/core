{"version":3,"sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AccountsControllerGetSelectedAccountAction,\n  AccountsControllerGetAccountAction,\n  AccountsControllerSelectedEvmAccountChangeEvent,\n} from '@metamask/accounts-controller';\nimport type {\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport contractMap from '@metamask/contract-metadata';\nimport { ChainId, safelyExecute } from '@metamask/controller-utils';\nimport type {\n  KeyringControllerGetStateAction,\n  KeyringControllerLockEvent,\n  KeyringControllerUnlockEvent,\n} from '@metamask/keyring-controller';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkDidChangeEvent,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type {\n  PreferencesControllerGetStateAction,\n  PreferencesControllerStateChangeEvent,\n} from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { isTokenDetectionSupportedForNetwork } from './assetsUtil';\nimport type {\n  GetTokenListState,\n  TokenListMap,\n  TokenListStateChange,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\nimport type {\n  TokensControllerAddDetectedTokensAction,\n  TokensControllerGetStateAction,\n} from './TokensController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * Compare 2 given strings and return boolean\n * eg: \"foo\" and \"FOO\" => true\n * eg: \"foo\" and \"bar\" => false\n * eg: \"foo\" and 123 => false\n *\n * @param value1 - first string to compare\n * @param value2 - first string to compare\n * @returns true if 2 strings are identical when they are lowercase\n */\nexport function isEqualCaseInsensitive(\n  value1: string,\n  value2: string,\n): boolean {\n  if (typeof value1 !== 'string' || typeof value2 !== 'string') {\n    return false;\n  }\n  return value1.toLowerCase() === value2.toLowerCase();\n}\n\ntype LegacyToken = {\n  name: string;\n  logo: `${string}.svg`;\n  symbol: string;\n  decimals: number;\n  erc20?: boolean;\n  erc721?: boolean;\n};\n\ntype TokenDetectionMap = {\n  [P in keyof TokenListMap]: Omit<TokenListMap[P], 'occurrences'>;\n};\n\nexport const STATIC_MAINNET_TOKEN_LIST = Object.entries<LegacyToken>(\n  contractMap,\n).reduce<TokenDetectionMap>((acc, [base, contract]) => {\n  const { logo, erc20, erc721, ...tokenMetadata } = contract;\n  return {\n    ...acc,\n    [base.toLowerCase()]: {\n      ...tokenMetadata,\n      address: base.toLowerCase(),\n      iconUrl: `images/contract/${logo}`,\n      aggregators: [],\n    },\n  };\n}, {});\n\nexport const controllerName = 'TokenDetectionController';\n\nexport type TokenDetectionState = Record<never, never>;\n\nexport type TokenDetectionControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokenDetectionState\n>;\n\nexport type TokenDetectionControllerActions =\n  TokenDetectionControllerGetStateAction;\n\nexport type AllowedActions =\n  | AccountsControllerGetSelectedAccountAction\n  | AccountsControllerGetAccountAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerGetStateAction\n  | GetTokenListState\n  | KeyringControllerGetStateAction\n  | PreferencesControllerGetStateAction\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\nexport type TokenDetectionControllerStateChangeEvent =\n  ControllerStateChangeEvent<typeof controllerName, TokenDetectionState>;\n\nexport type TokenDetectionControllerEvents =\n  TokenDetectionControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | AccountsControllerSelectedEvmAccountChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | TokenListStateChange\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | PreferencesControllerStateChangeEvent;\n\nexport type TokenDetectionControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokenDetectionControllerActions | AllowedActions,\n  TokenDetectionControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Controller that passively polls on a set interval for Tokens auto detection\n * @property intervalId - Polling interval used to fetch new token rates\n * @property selectedAddress - Vault selected address\n * @property networkClientId - The network client ID of the current selected network\n * @property disabled - Boolean to track if network requests are blocked\n * @property isUnlocked - Boolean to track if the keyring state is unlocked\n * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController\n * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network\n */\nexport class TokenDetectionController extends StaticIntervalPollingController<\n  typeof controllerName,\n  TokenDetectionState,\n  TokenDetectionControllerMessenger\n> {\n  #intervalId?: ReturnType<typeof setTimeout>;\n\n  #selectedAccountId: string;\n\n  #networkClientId: NetworkClientId;\n\n  #tokenList: TokenDetectionMap = {};\n\n  #disabled: boolean;\n\n  #isUnlocked: boolean;\n\n  #isDetectionEnabledFromPreferences: boolean;\n\n  #isDetectionEnabledForNetwork: boolean;\n\n  readonly #getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  readonly #trackMetaMetricsEvent: (options: {\n    event: string;\n    category: string;\n    properties: {\n      tokens: string[];\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      token_standard: string;\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      asset_type: string;\n    };\n  }) => void;\n\n  /**\n   * Creates a TokenDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The controller messaging system.\n   * @param options.disabled - If set to true, all network requests are blocked.\n   * @param options.interval - Polling interval used to fetch new token rates\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.\n   * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.\n   */\n  constructor({\n    interval = DEFAULT_INTERVAL,\n    disabled = true,\n    getBalancesInSingleCall,\n    trackMetaMetricsEvent,\n    messenger,\n  }: {\n    interval?: number;\n    disabled?: boolean;\n    getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n    trackMetaMetricsEvent: (options: {\n      event: string;\n      category: string;\n      properties: {\n        tokens: string[];\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        token_standard: string;\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        asset_type: string;\n      };\n    }) => void;\n    messenger: TokenDetectionControllerMessenger;\n  }) {\n    super({\n      name: controllerName,\n      messenger,\n      state: {},\n      metadata: {},\n    });\n\n    this.#disabled = disabled;\n    this.setIntervalLength(interval);\n\n    this.#selectedAccountId = this.#getSelectedAccount().id;\n\n    const { chainId, networkClientId } =\n      this.#getCorrectChainIdAndNetworkClientId();\n    this.#networkClientId = networkClientId;\n\n    const { useTokenDetection: defaultUseTokenDetection } =\n      this.messagingSystem.call('PreferencesController:getState');\n    this.#isDetectionEnabledFromPreferences = defaultUseTokenDetection;\n    this.#isDetectionEnabledForNetwork =\n      isTokenDetectionSupportedForNetwork(chainId);\n\n    this.#getBalancesInSingleCall = getBalancesInSingleCall;\n\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n\n    const { isUnlocked } = this.messagingSystem.call(\n      'KeyringController:getState',\n    );\n    this.#isUnlocked = isUnlocked;\n\n    this.#registerEventListeners();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system subscriptions to controller events.\n   */\n  #registerEventListeners() {\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.messagingSystem.subscribe('KeyringController:unlock', async () => {\n      this.#isUnlocked = true;\n      await this.#restartTokenDetection();\n    });\n\n    this.messagingSystem.subscribe('KeyringController:lock', () => {\n      this.#isUnlocked = false;\n      this.#stopPolling();\n    });\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      async ({ tokenList }) => {\n        const hasTokens = Object.keys(tokenList).length;\n\n        if (hasTokens) {\n          await this.#restartTokenDetection();\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      async ({ useTokenDetection }) => {\n        const selectedAccount = this.#getSelectedAccount();\n        const isDetectionChangedFromPreferences =\n          this.#isDetectionEnabledFromPreferences !== useTokenDetection;\n\n        this.#isDetectionEnabledFromPreferences = useTokenDetection;\n\n        if (isDetectionChangedFromPreferences) {\n          await this.#restartTokenDetection({\n            selectedAddress: selectedAccount.address,\n          });\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'AccountsController:selectedEvmAccountChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      async (selectedAccount) => {\n        const isSelectedAccountIdChanged =\n          this.#selectedAccountId !== selectedAccount.id;\n        if (isSelectedAccountIdChanged) {\n          this.#selectedAccountId = selectedAccount.id;\n          await this.#restartTokenDetection({\n            selectedAddress: selectedAccount.address,\n          });\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      async ({ selectedNetworkClientId }) => {\n        const isNetworkClientIdChanged =\n          this.#networkClientId !== selectedNetworkClientId;\n\n        const { chainId: newChainId } =\n          this.#getCorrectChainIdAndNetworkClientId(selectedNetworkClientId);\n        this.#isDetectionEnabledForNetwork =\n          isTokenDetectionSupportedForNetwork(newChainId);\n\n        if (isNetworkClientIdChanged && this.#isDetectionEnabledForNetwork) {\n          this.#networkClientId = selectedNetworkClientId;\n          await this.#restartTokenDetection({\n            networkClientId: this.#networkClientId,\n          });\n        }\n      },\n    );\n  }\n\n  /**\n   * Allows controller to make active and passive polling requests\n   */\n  enable(): void {\n    this.#disabled = false;\n  }\n\n  /**\n   * Blocks controller from making network calls\n   */\n  disable(): void {\n    this.#disabled = true;\n  }\n\n  /**\n   * Internal isActive state\n   * @type {boolean}\n   */\n  get isActive(): boolean {\n    return !this.#disabled && this.#isUnlocked;\n  }\n\n  /**\n   * Start polling for detected tokens.\n   */\n  async start(): Promise<void> {\n    this.enable();\n    await this.#startPolling();\n  }\n\n  /**\n   * Stop polling for detected tokens.\n   */\n  stop(): void {\n    this.disable();\n    this.#stopPolling();\n  }\n\n  #stopPolling(): void {\n    if (this.#intervalId) {\n      clearInterval(this.#intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  async #startPolling(): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n    this.#stopPolling();\n    await this.detectTokens();\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.#intervalId = setInterval(async () => {\n      await this.detectTokens();\n    }, this.getIntervalLength());\n  }\n\n  #getCorrectChainIdAndNetworkClientId(networkClientId?: NetworkClientId): {\n    chainId: Hex;\n    networkClientId: NetworkClientId;\n  } {\n    if (networkClientId) {\n      const networkConfiguration = this.messagingSystem.call(\n        'NetworkController:getNetworkConfigurationByNetworkClientId',\n        networkClientId,\n      );\n      if (networkConfiguration) {\n        return {\n          chainId: networkConfiguration.chainId,\n          networkClientId,\n        };\n      }\n    }\n    const { selectedNetworkClientId } = this.messagingSystem.call(\n      'NetworkController:getState',\n    );\n    const {\n      configuration: { chainId },\n    } = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      selectedNetworkClientId,\n    );\n    return {\n      chainId,\n      networkClientId: selectedNetworkClientId,\n    };\n  }\n\n  async _executePoll(\n    networkClientId: NetworkClientId,\n    options: { address: string },\n  ): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n    await this.detectTokens({\n      networkClientId,\n      selectedAddress: options.address,\n    });\n  }\n\n  /**\n   * Restart token detection polling period and call detectNewTokens\n   * in case of address change or user session initialization.\n   *\n   * @param options - Options for restart token detection.\n   * @param options.selectedAddress - the selectedAddress against which to detect for token balances\n   * @param options.networkClientId - The ID of the network client to use.\n   */\n  async #restartTokenDetection({\n    selectedAddress,\n    networkClientId,\n  }: {\n    selectedAddress?: string;\n    networkClientId?: NetworkClientId;\n  } = {}): Promise<void> {\n    await this.detectTokens({\n      networkClientId,\n      selectedAddress,\n    });\n    this.setIntervalLength(DEFAULT_INTERVAL);\n  }\n\n  /**\n   * For each token in the token list provided by the TokenListController, checks the token's balance for the selected account address on the active network.\n   * On mainnet, if token detection is disabled in preferences, ERC20 token auto detection will be triggered for each contract address in the legacy token list from the @metamask/contract-metadata repo.\n   *\n   * @param options - Options for token detection.\n   * @param options.networkClientId - The ID of the network client to use.\n   * @param options.selectedAddress - the selectedAddress against which to detect for token balances.\n   */\n  async detectTokens({\n    networkClientId,\n    selectedAddress,\n  }: {\n    networkClientId?: NetworkClientId;\n    selectedAddress?: string;\n  } = {}): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n\n    const addressAgainstWhichToDetect =\n      selectedAddress ?? this.#getSelectedAddress();\n    const { chainId, networkClientId: selectedNetworkClientId } =\n      this.#getCorrectChainIdAndNetworkClientId(networkClientId);\n    const chainIdAgainstWhichToDetect = chainId;\n    const networkClientIdAgainstWhichToDetect = selectedNetworkClientId;\n\n    if (!isTokenDetectionSupportedForNetwork(chainIdAgainstWhichToDetect)) {\n      return;\n    }\n    if (\n      !this.#isDetectionEnabledFromPreferences &&\n      chainIdAgainstWhichToDetect !== ChainId.mainnet\n    ) {\n      return;\n    }\n    const isTokenDetectionInactiveInMainnet =\n      !this.#isDetectionEnabledFromPreferences &&\n      chainIdAgainstWhichToDetect === ChainId.mainnet;\n    const { tokensChainsCache } = this.messagingSystem.call(\n      'TokenListController:getState',\n    );\n    this.#tokenList = isTokenDetectionInactiveInMainnet\n      ? STATIC_MAINNET_TOKEN_LIST\n      : tokensChainsCache[chainIdAgainstWhichToDetect]?.data ?? {};\n\n    for (const tokensSlice of this.#getSlicesOfTokensToDetect({\n      chainId: chainIdAgainstWhichToDetect,\n      selectedAddress: addressAgainstWhichToDetect,\n    })) {\n      await this.#addDetectedTokens({\n        tokensSlice,\n        selectedAddress: addressAgainstWhichToDetect,\n        networkClientId: networkClientIdAgainstWhichToDetect,\n        chainId: chainIdAgainstWhichToDetect,\n      });\n    }\n  }\n\n  #getSlicesOfTokensToDetect({\n    chainId,\n    selectedAddress,\n  }: {\n    chainId: Hex;\n    selectedAddress: string;\n  }): string[][] {\n    const { allTokens, allDetectedTokens, allIgnoredTokens } =\n      this.messagingSystem.call('TokensController:getState');\n    const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [\n      allTokens,\n      allDetectedTokens,\n      allIgnoredTokens,\n    ].map((tokens) =>\n      (tokens[chainId]?.[selectedAddress] ?? []).map((value) =>\n        typeof value === 'string' ? value : value.address,\n      ),\n    );\n\n    const tokensToDetect: string[] = [];\n    for (const tokenAddress of Object.keys(this.#tokenList)) {\n      if (\n        [\n          tokensAddresses,\n          detectedTokensAddresses,\n          ignoredTokensAddresses,\n        ].every(\n          (addresses) =>\n            !addresses.find((address) =>\n              isEqualCaseInsensitive(address, tokenAddress),\n            ),\n        )\n      ) {\n        tokensToDetect.push(tokenAddress);\n      }\n    }\n\n    const slicesOfTokensToDetect = [];\n    for (let i = 0, size = 1000; i < tokensToDetect.length; i += size) {\n      slicesOfTokensToDetect.push(tokensToDetect.slice(i, i + size));\n    }\n\n    return slicesOfTokensToDetect;\n  }\n\n  async #addDetectedTokens({\n    tokensSlice,\n    selectedAddress,\n    networkClientId,\n    chainId,\n  }: {\n    tokensSlice: string[];\n    selectedAddress: string;\n    networkClientId: NetworkClientId;\n    chainId: Hex;\n  }): Promise<void> {\n    await safelyExecute(async () => {\n      const balances = await this.#getBalancesInSingleCall(\n        selectedAddress,\n        tokensSlice,\n        networkClientId,\n      );\n\n      const tokensWithBalance: Token[] = [];\n      const eventTokensDetails: string[] = [];\n      for (const nonZeroTokenAddress of Object.keys(balances)) {\n        const { decimals, symbol, aggregators, iconUrl, name } =\n          this.#tokenList[nonZeroTokenAddress];\n        eventTokensDetails.push(`${symbol} - ${nonZeroTokenAddress}`);\n        tokensWithBalance.push({\n          address: nonZeroTokenAddress,\n          decimals,\n          symbol,\n          aggregators,\n          image: iconUrl,\n          isERC721: false,\n          name,\n        });\n      }\n\n      if (tokensWithBalance.length) {\n        this.#trackMetaMetricsEvent({\n          event: 'Token Detected',\n          category: 'Wallet',\n          properties: {\n            tokens: eventTokensDetails,\n            // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            token_standard: 'ERC20',\n            // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            asset_type: 'TOKEN',\n          },\n        });\n\n        await this.messagingSystem.call(\n          'TokensController:addDetectedTokens',\n          tokensWithBalance,\n          {\n            selectedAddress,\n            chainId,\n          },\n        );\n      }\n    });\n  }\n\n  #getSelectedAccount() {\n    return this.messagingSystem.call('AccountsController:getSelectedAccount');\n  }\n\n  #getSelectedAddress() {\n    // If the address is not defined (or empty), we fallback to the currently selected account's address\n    const account = this.messagingSystem.call(\n      'AccountsController:getAccount',\n      this.#selectedAccountId,\n    );\n    return account?.address || '';\n  }\n}\n\nexport default TokenDetectionController;\n"]}