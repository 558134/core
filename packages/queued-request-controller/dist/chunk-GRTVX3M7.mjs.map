{"version":3,"sources":["../src/QueuedRequestController.ts"],"sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerSetActiveNetworkAction,\n} from '@metamask/network-controller';\nimport type {\n  SelectedNetworkControllerGetNetworkClientIdForDomainAction,\n  SelectedNetworkControllerStateChangeEvent,\n} from '@metamask/selected-network-controller';\nimport { SelectedNetworkControllerEventTypes } from '@metamask/selected-network-controller';\nimport { createDeferredPromise } from '@metamask/utils';\n\nimport type { QueuedRequestMiddlewareJsonRpcRequest } from './types';\n\nexport const controllerName = 'QueuedRequestController';\n\nexport type QueuedRequestControllerState = {\n  queuedRequestCount: number;\n};\n\nexport const QueuedRequestControllerActionTypes = {\n  enqueueRequest: `${controllerName}:enqueueRequest` as const,\n  getState: `${controllerName}:getState` as const,\n};\n\nexport type QueuedRequestControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  QueuedRequestControllerState\n>;\n\nexport type QueuedRequestControllerEnqueueRequestAction = {\n  type: typeof QueuedRequestControllerActionTypes.enqueueRequest;\n  handler: QueuedRequestController['enqueueRequest'];\n};\n\nexport const QueuedRequestControllerEventTypes = {\n  networkSwitched: `${controllerName}:networkSwitched` as const,\n  stateChange: `${controllerName}:stateChange` as const,\n};\n\nexport type QueuedRequestControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    QueuedRequestControllerState\n  >;\n\nexport type QueuedRequestControllerNetworkSwitched = {\n  type: typeof QueuedRequestControllerEventTypes.networkSwitched;\n  payload: [string];\n};\n\nexport type QueuedRequestControllerEvents =\n  | QueuedRequestControllerStateChangeEvent\n  | QueuedRequestControllerNetworkSwitched;\n\nexport type QueuedRequestControllerActions =\n  | QueuedRequestControllerGetStateAction\n  | QueuedRequestControllerEnqueueRequestAction;\n\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerSetActiveNetworkAction\n  | SelectedNetworkControllerGetNetworkClientIdForDomainAction;\n\nexport type AllowedEvents = SelectedNetworkControllerStateChangeEvent;\n\nexport type QueuedRequestControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  QueuedRequestControllerActions | AllowedActions,\n  QueuedRequestControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport type QueuedRequestControllerOptions = {\n  messenger: QueuedRequestControllerMessenger;\n  shouldRequestSwitchNetwork: (\n    request: QueuedRequestMiddlewareJsonRpcRequest,\n  ) => boolean;\n  clearPendingConfirmations: () => void;\n  showApprovalRequest: () => void;\n};\n\n/**\n * A queued request.\n */\ntype QueuedRequest = {\n  /**\n   * The origin of the queued request.\n   */\n  origin: string;\n  /**\n   * A callback used to continue processing the request, called when the request is dequeued.\n   */\n  processRequest: (error: unknown) => void;\n};\n\n/**\n * Queue requests for processing in batches, by request origin.\n *\n * Processing requests in batches allows us to completely separate sets of requests that originate\n * from different origins. This ensures that our UI will not display those requests as a set, which\n * could mislead users into thinking they are related.\n *\n * Queuing requests in batches also allows us to ensure the globally selected network matches the\n * dapp-selected network, before the confirmation UI is rendered. This is important because the\n * data shown on some confirmation screens is only collected for the globally selected network.\n *\n * Requests get processed in order of insertion, even across batches. All requests get processed\n * even in the event of preceding requests failing.\n */\nexport class QueuedRequestController extends BaseController<\n  typeof controllerName,\n  QueuedRequestControllerState,\n  QueuedRequestControllerMessenger\n> {\n  /**\n   * The origin of the current batch of requests being processed, or `undefined` if there are no\n   * requests currently being processed.\n   */\n  #originOfCurrentBatch: string | undefined;\n\n  /**\n   * The list of all queued requests, in chronological order.\n   */\n  #requestQueue: QueuedRequest[] = [];\n\n  /**\n   * The number of requests currently being processed.\n   *\n   * Note that this does not include queued requests, just those being actively processed (i.e.\n   * those in the \"current batch\").\n   */\n  #processingRequestCount = 0;\n\n  /**\n   * This is a function that returns true if a request requires the globally selected\n   * network to match the dapp selected network before being processed. These can\n   * be for UI/UX reasons where the currently selected network is displayed\n   * in the confirmation even though it will be submitted on the correct\n   * network for the dapp. It could also be that a method expects the\n   * globally selected network to match some value in the request params itself.\n   */\n  readonly #shouldRequestSwitchNetwork: (\n    request: QueuedRequestMiddlewareJsonRpcRequest,\n  ) => boolean;\n\n  /**\n   * This is a function that clears all pending confirmations across\n   * several controllers that may handle them.\n   */\n  #clearPendingConfirmations: () => void;\n\n  /**\n   * This is a function that makes the confirmation notification view\n   * become visible and focused to the user\n   */\n  #showApprovalRequest: () => void;\n\n  /**\n   * Construct a QueuedRequestController.\n   *\n   * @param options - Controller options.\n   * @param options.messenger - The restricted controller messenger that facilitates communication with other controllers.\n   * @param options.shouldRequestSwitchNetwork - A function that returns if a request requires the globally selected network to match the dapp selected network.\n   * @param options.clearPendingConfirmations - A function that will clear all the pending confirmations.\n   * @param options.showApprovalRequest - A function for opening the UI such that\n   * the existing request can be displayed to the user.\n   */\n  constructor({\n    messenger,\n    shouldRequestSwitchNetwork,\n    clearPendingConfirmations,\n    showApprovalRequest,\n  }: QueuedRequestControllerOptions) {\n    super({\n      name: controllerName,\n      metadata: {\n        queuedRequestCount: {\n          anonymous: true,\n          persist: false,\n        },\n      },\n      messenger,\n      state: { queuedRequestCount: 0 },\n    });\n\n    this.#shouldRequestSwitchNetwork = shouldRequestSwitchNetwork;\n    this.#clearPendingConfirmations = clearPendingConfirmations;\n    this.#showApprovalRequest = showApprovalRequest;\n    this.#registerMessageHandlers();\n  }\n\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:enqueueRequest`,\n      this.enqueueRequest.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      SelectedNetworkControllerEventTypes.stateChange,\n      (_, patch) => {\n        patch.forEach(({ op, path }) => {\n          if (\n            path.length === 2 &&\n            path[0] === 'domains' &&\n            typeof path[1] === 'string'\n          ) {\n            const origin = path[1];\n            this.#flushQueueForOrigin(origin);\n            // When a domain is removed from SelectedNetworkController, its because of revoke permissions or the useRequestQueue flag was toggled off.\n            // Rather than subscribe to the permissions controller event in addition to the selectedNetworkController ones, we simplify it and just handle remove on this event alone.\n            if (op === 'remove' && origin === this.#originOfCurrentBatch) {\n              this.#clearPendingConfirmations();\n            }\n          }\n        });\n      },\n    );\n  }\n\n  #flushQueueForOrigin(flushOrigin: string) {\n    this.#requestQueue\n      .filter(({ origin }) => origin === flushOrigin)\n      .forEach(({ processRequest }) => {\n        processRequest(\n          new Error(\n            'The request has been rejected due to a change in selected network. Please verify the selected network and retry the request.',\n          ),\n        );\n      });\n    this.#requestQueue = this.#requestQueue.filter(\n      ({ origin }) => origin !== flushOrigin,\n    );\n  }\n\n  /**\n   * Process the next batch of requests.\n   *\n   * This will trigger the next batch of requests with matching origins to be processed. Each\n   * request in the batch is dequeued one at a time, in chronological order, but they all get\n   * processed in parallel.\n   *\n   * This should be called after a batch of requests has finished processing, if the queue is non-\n   * empty.\n   */\n  async #processNextBatch() {\n    const firstRequest = this.#requestQueue.shift() as QueuedRequest;\n    this.#originOfCurrentBatch = firstRequest.origin;\n    const batch = [firstRequest.processRequest];\n    while (this.#requestQueue[0]?.origin === this.#originOfCurrentBatch) {\n      const nextEntry = this.#requestQueue.shift() as QueuedRequest;\n      batch.push(nextEntry.processRequest);\n    }\n\n    // If globally selected network is different from origin selected network,\n    // switch network before processing batch\n    let networkSwitchError: unknown;\n    try {\n      await this.#switchNetworkIfNecessary();\n    } catch (error: unknown) {\n      networkSwitchError = error;\n    }\n\n    for (const processRequest of batch) {\n      processRequest(networkSwitchError);\n    }\n    this.#updateQueuedRequestCount();\n  }\n\n  /**\n   * Switch the globally selected network client to match the network\n   * client of the current batch.\n   *\n   * @throws Throws an error if the current selected `networkClientId` or the\n   * `networkClientId` on the request are invalid.\n   */\n  async #switchNetworkIfNecessary() {\n    // This branch is unreachable; it's just here for type reasons.\n    /* istanbul ignore next */\n    if (!this.#originOfCurrentBatch) {\n      throw new Error('Current batch origin must be initialized first');\n    }\n    const originNetworkClientId = this.messagingSystem.call(\n      'SelectedNetworkController:getNetworkClientIdForDomain',\n      this.#originOfCurrentBatch,\n    );\n    const { selectedNetworkClientId } = this.messagingSystem.call(\n      'NetworkController:getState',\n    );\n    if (originNetworkClientId === selectedNetworkClientId) {\n      return;\n    }\n\n    await this.messagingSystem.call(\n      'NetworkController:setActiveNetwork',\n      originNetworkClientId,\n    );\n\n    this.messagingSystem.publish(\n      'QueuedRequestController:networkSwitched',\n      originNetworkClientId,\n    );\n  }\n\n  /**\n   * Update the queued request count.\n   */\n  #updateQueuedRequestCount() {\n    this.update((state) => {\n      state.queuedRequestCount = this.#requestQueue.length;\n    });\n  }\n\n  async #waitForDequeue(origin: string): Promise<void> {\n    const { promise, reject, resolve } = createDeferredPromise({\n      suppressUnhandledRejection: true,\n    });\n    this.#requestQueue.push({\n      origin,\n      processRequest: (error: unknown) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      },\n    });\n    this.#updateQueuedRequestCount();\n\n    return promise;\n  }\n\n  /**\n   * Enqueue a request to be processed in a batch with other requests from the same origin.\n   *\n   * We process requests one origin at a time, so that requests from different origins do not get\n   * interwoven, and so that we can ensure that the globally selected network matches the dapp-\n   * selected network.\n   *\n   * Requests get processed in order of insertion, even across origins/batches. All requests get\n   * processed even in the event of preceding requests failing.\n   *\n   * @param request - The JSON-RPC request to process.\n   * @param requestNext - A function representing the next steps for processing this request.\n   * @returns A promise that resolves when the given request has been fully processed.\n   */\n  async enqueueRequest(\n    request: QueuedRequestMiddlewareJsonRpcRequest,\n    requestNext: () => Promise<void>,\n  ): Promise<void> {\n    if (this.#originOfCurrentBatch === undefined) {\n      this.#originOfCurrentBatch = request.origin;\n    }\n\n    try {\n      // Queue request for later processing\n      // Network switch is handled when this batch is processed\n      if (\n        this.state.queuedRequestCount > 0 ||\n        this.#originOfCurrentBatch !== request.origin\n      ) {\n        this.#showApprovalRequest();\n        await this.#waitForDequeue(request.origin);\n      } else if (this.#shouldRequestSwitchNetwork(request)) {\n        // Process request immediately\n        // Requires switching network now if necessary\n        await this.#switchNetworkIfNecessary();\n      }\n      this.#processingRequestCount += 1;\n      try {\n        await requestNext();\n      } finally {\n        this.#processingRequestCount -= 1;\n      }\n      return undefined;\n    } finally {\n      if (this.#processingRequestCount === 0) {\n        this.#originOfCurrentBatch = undefined;\n        if (this.#requestQueue.length > 0) {\n          // The next batch is triggered here. We intentionally omit the `await` because we don't\n          // want the next batch to block resolution of the current request.\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          this.#processNextBatch();\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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","names":[]}