{"version":3,"sources":["../src/NameController.ts"],"names":["NameOrigin"],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { isSafeDynamicKey } from '@metamask/controller-utils';\n\nimport type {\n  NameProvider,\n  NameProviderRequest,\n  NameProviderResult,\n  NameProviderSourceResult,\n} from './types';\nimport { NameType } from './types';\n\nexport const FALLBACK_VARIATION = '*';\nexport const PROPOSED_NAME_EXPIRE_DURATION = 60 * 60 * 24; // 24 hours\n\n/**\n * Enumerates the possible origins responsible for setting a petname.\n */\nexport enum NameOrigin {\n  // Originated from an account identity.\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ACCOUNT_IDENTITY = 'account-identity',\n  // Originated from an address book entry.\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ADDRESS_BOOK = 'address-book',\n  // Originated from the API (NameController.setName). This is the default.\n  API = 'api',\n  // Originated from the user taking action in the UI.\n  UI = 'ui',\n}\n\nconst DEFAULT_UPDATE_DELAY = 60 * 2; // 2 Minutes\nconst DEFAULT_VARIATION = '';\n\nconst controllerName = 'NameController';\n\nconst stateMetadata = {\n  names: { persist: true, anonymous: false },\n  nameSources: { persist: true, anonymous: false },\n};\n\nconst getDefaultState = () => ({\n  names: {\n    [NameType.ETHEREUM_ADDRESS]: {},\n  },\n  nameSources: {},\n});\n\nexport type ProposedNamesEntry = {\n  proposedNames: string[];\n  lastRequestTime: number | null;\n  updateDelay: number | null;\n};\n\nexport type NameEntry = {\n  name: string | null;\n  sourceId: string | null;\n  origin: NameOrigin | null;\n  proposedNames: Record<string, ProposedNamesEntry>;\n};\n\nexport type SourceEntry = {\n  label: string;\n};\n\nexport type NameControllerState = {\n  // Type > Value > Variation > Entry\n  names: Record<NameType, Record<string, Record<string, NameEntry>>>;\n  nameSources: Record<string, SourceEntry>;\n};\n\nexport type GetNameState = ControllerGetStateAction<\n  typeof controllerName,\n  NameControllerState\n>;\n\nexport type NameStateChange = ControllerStateChangeEvent<\n  typeof controllerName,\n  NameControllerState\n>;\n\nexport type NameControllerActions = GetNameState;\n\nexport type NameControllerEvents = NameStateChange;\n\nexport type NameControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  NameControllerActions,\n  NameControllerEvents,\n  never,\n  never\n>;\n\nexport type NameControllerOptions = {\n  messenger: NameControllerMessenger;\n  providers: NameProvider[];\n  state?: Partial<NameControllerState>;\n  updateDelay?: number;\n};\n\nexport type UpdateProposedNamesRequest = {\n  value: string;\n  type: NameType;\n  sourceIds?: string[];\n  onlyUpdateAfterDelay?: boolean;\n  variation?: string;\n};\n\nexport type UpdateProposedNamesResult = {\n  results: Record<string, { proposedNames?: string[]; error?: unknown }>;\n};\n\nexport type SetNameRequest = {\n  value: string;\n  type: NameType;\n  name: string | null;\n  sourceId?: string;\n  variation?: string;\n  origin?: NameOrigin;\n};\n\n/**\n * Controller for storing and deriving names for values such as Ethereum addresses.\n */\nexport class NameController extends BaseController<\n  typeof controllerName,\n  NameControllerState,\n  NameControllerMessenger\n> {\n  #providers: NameProvider[];\n\n  #updateDelay: number;\n\n  /**\n   * Construct a Name controller.\n   *\n   * @param options - Controller options.\n   * @param options.messenger - Restricted controller messenger for the name controller.\n   * @param options.providers - Array of name provider instances to propose names.\n   * @param options.state - Initial state to set on the controller.\n   * @param options.updateDelay - The delay in seconds before a new request to a source should be made.\n   */\n  constructor({\n    messenger,\n    providers,\n    state,\n    updateDelay,\n  }: NameControllerOptions) {\n    super({\n      name: controllerName,\n      metadata: stateMetadata,\n      messenger,\n      state: { ...getDefaultState(), ...state },\n    });\n\n    this.#providers = providers;\n    this.#updateDelay = updateDelay ?? DEFAULT_UPDATE_DELAY;\n  }\n\n  /**\n   * Set the user specified name for a value.\n   *\n   * @param request - Request object.\n   * @param request.name - Name to set.\n   * @param request.sourceId - Optional ID of the source of the proposed name.\n   * @param request.type - Type of value to set the name for.\n   * @param request.value - Value to set the name for.\n   * @param request.variation - Variation of the raw value to set the name for. The chain ID if the type is Ethereum address.\n   */\n  setName(request: SetNameRequest) {\n    this.#validateSetNameRequest(request);\n\n    const {\n      value,\n      type,\n      name,\n      sourceId: requestSourceId,\n      origin: requestOrigin,\n      variation,\n    } = request;\n    const sourceId = requestSourceId ?? null;\n    // If the name is being cleared, the fallback origin should be cleared as well.\n    const fallbackOrigin = name === null ? null : NameOrigin.API;\n    const origin = requestOrigin ?? fallbackOrigin;\n\n    this.#updateEntry(value, type, variation, (entry: NameEntry) => {\n      entry.name = name;\n      entry.sourceId = sourceId;\n      entry.origin = origin;\n    });\n  }\n\n  /**\n   * Generate the proposed names for a value using the name providers and store them in the state.\n   *\n   * @param request - Request object.\n   * @param request.value - Value to update the proposed names for.\n   * @param request.type - Type of value to update the proposed names for.\n   * @param request.sourceIds - Optional array of source IDs to limit which sources are used by the providers. If not provided, all sources in all providers will be used.\n   * @param request.variation - Variation of the raw value to update proposed names for. The chain ID if the type is Ethereum address.\n   * @returns The updated proposed names for the value.\n   */\n  async updateProposedNames(\n    request: UpdateProposedNamesRequest,\n  ): Promise<UpdateProposedNamesResult> {\n    this.#validateUpdateProposedNamesRequest(request);\n\n    const providerResponses = (\n      await Promise.all(\n        this.#providers.map((provider) =>\n          this.#getProviderResponse(request, provider),\n        ),\n      )\n    ).filter((response) => Boolean(response)) as NameProviderResult[];\n\n    this.#updateProposedNameState(request, providerResponses);\n    this.#updateSourceState(this.#providers);\n    this.#removeExpiredEntries();\n\n    return this.#getUpdateProposedNamesResult(providerResponses);\n  }\n\n  #updateProposedNameState(\n    request: UpdateProposedNamesRequest,\n    providerResponses: NameProviderResult[],\n  ) {\n    const { value, type, variation } = request;\n    const currentTime = this.#getCurrentTimeSeconds();\n\n    this.#updateEntry(value, type, variation, (entry: NameEntry) => {\n      this.#removeDormantProposedNames(entry.proposedNames, type);\n\n      for (const providerResponse of providerResponses) {\n        const { results } = providerResponse;\n\n        for (const sourceId of Object.keys(providerResponse.results)) {\n          const result = results[sourceId];\n          const { proposedNames, updateDelay } = result;\n\n          const proposedNameEntry = entry.proposedNames[sourceId] ?? {\n            proposedNames: [],\n            lastRequestTime: null,\n            updateDelay: null,\n          };\n\n          entry.proposedNames[sourceId] = proposedNameEntry;\n\n          if (proposedNames) {\n            proposedNameEntry.proposedNames = proposedNames;\n          }\n\n          proposedNameEntry.lastRequestTime = currentTime;\n          proposedNameEntry.updateDelay = updateDelay ?? null;\n        }\n      }\n    });\n  }\n\n  #updateSourceState(providers: NameProvider[]) {\n    const newNameSources = { ...this.state.nameSources };\n\n    for (const provider of providers) {\n      const { sourceLabels } = provider.getMetadata();\n\n      for (const sourceId of Object.keys(sourceLabels)) {\n        newNameSources[sourceId] = {\n          label: sourceLabels[sourceId],\n        };\n      }\n    }\n\n    this.update((state) => {\n      state.nameSources = newNameSources;\n    });\n  }\n\n  #getUpdateProposedNamesResult(\n    providerResponses: NameProviderResult[],\n  ): UpdateProposedNamesResult {\n    return providerResponses.reduce(\n      (acc: UpdateProposedNamesResult, providerResponse) => {\n        const { results } = providerResponse;\n\n        for (const sourceId of Object.keys(results)) {\n          const { proposedNames, error } = results[sourceId];\n\n          acc.results[sourceId] = {\n            proposedNames,\n            error,\n          };\n        }\n\n        return acc;\n      },\n      { results: {} },\n    );\n  }\n\n  async #getProviderResponse(\n    request: UpdateProposedNamesRequest,\n    provider: NameProvider,\n  ): Promise<NameProviderResult | undefined> {\n    const {\n      value,\n      type,\n      sourceIds: requestedSourceIds,\n      onlyUpdateAfterDelay,\n      variation,\n    } = request;\n\n    /* istanbul ignore next */\n    const variationKey = variation ?? DEFAULT_VARIATION;\n    const supportedSourceIds = this.#getSourceIds(provider, type);\n    const currentTime = this.#getCurrentTimeSeconds();\n    const normalizedValue = this.#normalizeValue(value, type);\n\n    const matchingSourceIds = supportedSourceIds.filter((sourceId) => {\n      if (requestedSourceIds && !requestedSourceIds.includes(sourceId)) {\n        return false;\n      }\n\n      if (onlyUpdateAfterDelay) {\n        const entry =\n          this.state.names[type]?.[normalizedValue]?.[variationKey] ?? {};\n        const proposedNamesEntry = entry.proposedNames?.[sourceId] ?? {};\n        const lastRequestTime = proposedNamesEntry.lastRequestTime ?? 0;\n        const updateDelay = proposedNamesEntry.updateDelay ?? this.#updateDelay;\n\n        if (currentTime - lastRequestTime < updateDelay) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (!matchingSourceIds.length) {\n      return undefined;\n    }\n\n    const providerRequest: NameProviderRequest = {\n      value: this.#normalizeValue(value, type),\n      type,\n      sourceIds: requestedSourceIds ? matchingSourceIds : undefined,\n      variation: this.#normalizeVariation(variationKey, type),\n    };\n\n    let responseError: unknown | undefined;\n    let response: NameProviderResult | undefined;\n\n    try {\n      response = await provider.getProposedNames(providerRequest);\n      responseError = response.error;\n    } catch (error) {\n      responseError = error;\n    }\n\n    return this.#normalizeProviderResult(\n      response,\n      responseError,\n      matchingSourceIds,\n    );\n  }\n\n  #normalizeProviderResult(\n    result: NameProviderResult | undefined,\n    responseError: unknown,\n    matchingSourceIds: string[],\n  ): NameProviderResult {\n    const error = responseError ?? undefined;\n\n    const results = matchingSourceIds.reduce((acc, sourceId) => {\n      const sourceResult = result?.results?.[sourceId];\n\n      const normalizedSourceResult = this.#normalizeProviderSourceResult(\n        sourceResult,\n        responseError,\n      );\n\n      return {\n        ...acc,\n        [sourceId]: normalizedSourceResult,\n      };\n    }, {});\n\n    return { results, error };\n  }\n\n  #normalizeProviderSourceResult(\n    result: NameProviderSourceResult | undefined,\n    responseError: unknown,\n  ): NameProviderSourceResult | undefined {\n    const error = result?.error ?? responseError ?? undefined;\n    const updateDelay = result?.updateDelay ?? undefined;\n    let proposedNames = error ? undefined : result?.proposedNames ?? undefined;\n\n    if (proposedNames) {\n      proposedNames = proposedNames.filter(\n        (proposedName) => proposedName?.length,\n      );\n    }\n\n    return {\n      proposedNames,\n      error,\n      updateDelay,\n    };\n  }\n\n  #normalizeValue(value: string, type: NameType): string {\n    /* istanbul ignore next */\n    switch (type) {\n      case NameType.ETHEREUM_ADDRESS:\n        return value.toLowerCase();\n\n      default:\n        return value;\n    }\n  }\n\n  #normalizeVariation(variation: string, type: NameType): string {\n    /* istanbul ignore next */\n    switch (type) {\n      case NameType.ETHEREUM_ADDRESS:\n        return variation.toLowerCase();\n\n      default:\n        return variation;\n    }\n  }\n\n  #updateEntry(\n    value: string,\n    type: NameType,\n    variation: string | undefined,\n    callback: (entry: NameEntry) => void,\n  ) {\n    /* istanbul ignore next */\n    const variationKey = variation ?? DEFAULT_VARIATION;\n    const normalizedValue = this.#normalizeValue(value, type);\n    const normalizedVariation = this.#normalizeVariation(variationKey, type);\n\n    if (\n      [normalizedValue, normalizedVariation].some(\n        (key) => !isSafeDynamicKey(key),\n      )\n    ) {\n      return;\n    }\n\n    this.update((state) => {\n      const typeEntries = state.names[type] || {};\n      state.names[type] = typeEntries;\n\n      const variationEntries = typeEntries[normalizedValue] || {};\n      typeEntries[normalizedValue] = variationEntries;\n\n      const entry = variationEntries[normalizedVariation] ?? {\n        proposedNames: {},\n        name: null,\n        sourceId: null,\n        origin: null,\n      };\n      variationEntries[normalizedVariation] = entry;\n\n      callback(entry);\n    });\n  }\n\n  #getCurrentTimeSeconds(): number {\n    return Math.round(Date.now() / 1000);\n  }\n\n  #validateSetNameRequest(request: SetNameRequest) {\n    const { name, value, type, sourceId, variation, origin } = request;\n    const errorMessages: string[] = [];\n\n    this.#validateValue(value, errorMessages);\n    this.#validateType(type, errorMessages);\n    this.#validateName(name, errorMessages);\n    this.#validateSourceId(sourceId, type, name, errorMessages);\n    this.#validateVariation(variation, type, errorMessages);\n    this.#validateOrigin(origin, name, errorMessages);\n\n    if (errorMessages.length) {\n      throw new Error(errorMessages.join(' '));\n    }\n  }\n\n  #validateUpdateProposedNamesRequest(request: UpdateProposedNamesRequest) {\n    const { value, type, sourceIds, variation } = request;\n    const errorMessages: string[] = [];\n\n    this.#validateValue(value, errorMessages);\n    this.#validateType(type, errorMessages);\n    this.#validateSourceIds(sourceIds, type, errorMessages);\n    this.#validateDuplicateSourceIds(type, errorMessages);\n    this.#validateVariation(variation, type, errorMessages);\n\n    if (errorMessages.length) {\n      throw new Error(errorMessages.join(' '));\n    }\n  }\n\n  #validateValue(value: string, errorMessages: string[]) {\n    if (!value?.length || typeof value !== 'string') {\n      errorMessages.push('Must specify a non-empty string for value.');\n    }\n  }\n\n  #validateType(type: NameType, errorMessages: string[]) {\n    if (!Object.values(NameType).includes(type)) {\n      errorMessages.push(\n        `Must specify one of the following types: ${Object.values(\n          NameType,\n        ).join(', ')}`,\n      );\n    }\n  }\n\n  #validateName(name: string | null, errorMessages: string[]) {\n    if (name === null) {\n      return;\n    }\n\n    if (!name?.length || typeof name !== 'string') {\n      errorMessages.push('Must specify a non-empty string or null for name.');\n    }\n  }\n\n  #validateSourceIds(\n    sourceIds: string[] | undefined,\n    type: NameType,\n    errorMessages: string[],\n  ) {\n    if (!sourceIds) {\n      return;\n    }\n\n    const allSourceIds = this.#getAllSourceIds(type);\n    const missingSourceIds = [];\n\n    for (const sourceId of sourceIds) {\n      if (!allSourceIds.includes(sourceId)) {\n        missingSourceIds.push(sourceId);\n        continue;\n      }\n    }\n\n    if (missingSourceIds.length) {\n      errorMessages.push(\n        `Unknown source IDs for type '${type}': ${missingSourceIds.join(', ')}`,\n      );\n    }\n  }\n\n  #validateSourceId(\n    sourceId: string | undefined,\n    type: NameType,\n    name: string | null,\n    errorMessages: string[],\n  ) {\n    if (sourceId === null || sourceId === undefined) {\n      return;\n    }\n\n    if (name === null) {\n      errorMessages.push(\n        `Cannot specify a source ID when clearing the saved name: ${sourceId}`,\n      );\n      return;\n    }\n\n    const allSourceIds = this.#getAllSourceIds(type);\n\n    if (!sourceId.length || typeof sourceId !== 'string') {\n      errorMessages.push('Must specify a non-empty string for sourceId.');\n      return;\n    }\n\n    if (!allSourceIds.includes(sourceId)) {\n      errorMessages.push(`Unknown source ID for type '${type}': ${sourceId}`);\n    }\n  }\n\n  #validateDuplicateSourceIds(type: NameType, errorMessages: string[]) {\n    const allSourceIds = this.#getAllSourceIds(type);\n\n    const duplicateSourceIds = allSourceIds.filter(\n      (sourceId, index) => allSourceIds.indexOf(sourceId) !== index,\n    );\n\n    if (duplicateSourceIds.length) {\n      errorMessages.push(\n        `Duplicate source IDs found for type '${type}': ${duplicateSourceIds.join(\n          ', ',\n        )}`,\n      );\n    }\n  }\n\n  #validateVariation(\n    variation: string | undefined,\n    type: string,\n    errorMessages: string[],\n  ) {\n    if (type !== NameType.ETHEREUM_ADDRESS) {\n      return;\n    }\n\n    if (\n      !variation?.length ||\n      typeof variation !== 'string' ||\n      (!variation.match(/^0x[0-9A-Fa-f]+$/u) &&\n        variation !== FALLBACK_VARIATION)\n    ) {\n      errorMessages.push(\n        `Must specify a chain ID in hexidecimal format or the fallback, \"${FALLBACK_VARIATION}\", for variation when using '${type}' type.`,\n      );\n    }\n  }\n\n  #validateOrigin(\n    origin: NameOrigin | null | undefined,\n    name: string | null,\n    errorMessages: string[],\n  ) {\n    if (!origin) {\n      return;\n    }\n\n    if (name === null) {\n      errorMessages.push(\n        `Cannot specify an origin when clearing the saved name: ${origin}`,\n      );\n      return;\n    }\n\n    if (!Object.values(NameOrigin).includes(origin)) {\n      errorMessages.push(\n        `Must specify one of the following origins: ${Object.values(\n          NameOrigin,\n        ).join(', ')}`,\n      );\n    }\n  }\n\n  #getAllSourceIds(type: NameType): string[] {\n    return (\n      this.#providers\n        /* istanbul ignore next */\n        .map((provider) => this.#getSourceIds(provider, type))\n        .flat()\n    );\n  }\n\n  #getSourceIds(provider: NameProvider, type: NameType): string[] {\n    return provider.getMetadata().sourceIds[type];\n  }\n\n  #removeDormantProposedNames(\n    proposedNames: Record<string, ProposedNamesEntry>,\n    type: NameType,\n  ) {\n    if (Object.keys(proposedNames).length === 0) {\n      return;\n    }\n\n    const typeSourceIds = this.#getAllSourceIds(type);\n\n    const dormantSourceIds = Object.keys(proposedNames).filter(\n      (sourceId) => !typeSourceIds.includes(sourceId),\n    );\n\n    for (const dormantSourceId of dormantSourceIds) {\n      delete proposedNames[dormantSourceId];\n    }\n  }\n\n  #removeExpiredEntries(): void {\n    const currentTime = this.#getCurrentTimeSeconds();\n\n    this.update((state: NameControllerState) => {\n      const entries = this.#getEntriesList(state);\n      for (const { nameType, value, variation, entry } of entries) {\n        if (entry.name !== null) {\n          continue;\n        }\n\n        const proposedNames = Object.values(entry.proposedNames);\n        const allProposedNamesExpired = proposedNames.every(\n          (proposedName: ProposedNamesEntry) =>\n            currentTime - (proposedName.lastRequestTime ?? 0) >=\n            PROPOSED_NAME_EXPIRE_DURATION,\n        );\n\n        if (allProposedNamesExpired) {\n          delete state.names[nameType][value][variation];\n        }\n      }\n    });\n  }\n\n  #getEntriesList(state: NameControllerState): {\n    nameType: NameType;\n    value: string;\n    variation: string;\n    entry: NameEntry;\n  }[] {\n    return Object.entries(state.names).flatMap(([type, typeEntries]) =>\n      Object.entries(typeEntries).flatMap(([value, variationEntries]) =>\n        Object.entries(variationEntries).map(([variation, entry]) => ({\n          entry,\n          nameType: type as NameType,\n          value,\n          variation,\n        })),\n      ),\n    );\n  }\n}\n"]}