{"version":3,"sources":["../src/sdk/user-storage.ts"],"names":[],"mappings":"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","sourcesContent":["import type { UserStoragePath } from '../controllers/user-storage/schema';\nimport { createEntryPath } from '../controllers/user-storage/schema';\nimport type { IBaseAuth } from './authentication-jwt-bearer/types';\nimport encryption, { createSHA256Hash } from './encryption';\nimport type { Env } from './env';\nimport { getEnvUrls } from './env';\nimport { NotFoundError, UserStorageError } from './errors';\n\nexport const STORAGE_URL = (env: Env, encryptedPath: string) =>\n  `${getEnvUrls(env).userStorageApiUrl}/api/v1/userstorage/${encryptedPath}`;\n\nexport type UserStorageConfig = {\n  env: Env;\n  auth: Pick<IBaseAuth, 'getAccessToken' | 'getUserProfile' | 'signMessage'>;\n};\n\nexport type StorageOptions = {\n  getStorageKey: () => Promise<string | null>;\n  setStorageKey: (val: string) => Promise<void>;\n};\n\nexport type UserStorageOptions = {\n  storage?: StorageOptions;\n};\n\ntype ErrorMessage = {\n  message: string;\n  error: string;\n};\n\nexport class UserStorage {\n  protected config: UserStorageConfig;\n\n  protected options: UserStorageOptions;\n\n  protected env: Env;\n\n  constructor(config: UserStorageConfig, options: UserStorageOptions) {\n    this.env = config.env;\n    this.config = config;\n    this.options = options;\n  }\n\n  async setItem(path: UserStoragePath, value: string): Promise<void> {\n    await this.#upsertUserStorage(path, value);\n  }\n\n  async getItem(path: UserStoragePath): Promise<string> {\n    return this.#getUserStorage(path);\n  }\n\n  async getStorageKey(): Promise<string> {\n    const storageKey = await this.options.storage?.getStorageKey();\n    if (storageKey) {\n      return storageKey;\n    }\n\n    const userProfile = await this.config.auth.getUserProfile();\n    const storageKeySignature = await this.config.auth.signMessage(\n      `metamask:${userProfile.profileId}`,\n    );\n    const hashedStorageKeySignature = createSHA256Hash(storageKeySignature);\n    await this.options.storage?.setStorageKey(hashedStorageKeySignature);\n    return hashedStorageKeySignature;\n  }\n\n  async #upsertUserStorage(path: UserStoragePath, data: string): Promise<void> {\n    try {\n      const headers = await this.#getAuthorizationHeader();\n      const storageKey = await this.getStorageKey();\n      const encryptedData = encryption.encryptString(data, storageKey);\n      const encryptedPath = createEntryPath(path, storageKey);\n\n      const url = new URL(STORAGE_URL(this.env, encryptedPath));\n\n      const response = await fetch(url.toString(), {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        body: JSON.stringify({ data: encryptedData }),\n      });\n\n      if (!response.ok) {\n        const responseBody: ErrorMessage = await response.json().catch(() => ({\n          message: 'unknown',\n          error: 'unknown',\n        }));\n        throw new Error(\n          `HTTP error message: ${responseBody.message}, error: ${responseBody.error}`,\n        );\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      const errorMessage =\n        e instanceof Error ? e.message : JSON.stringify(e ?? '');\n      throw new UserStorageError(\n        `failed to upsert user storage for path '${path}'. ${errorMessage}`,\n      );\n    }\n  }\n\n  async #getUserStorage(path: UserStoragePath): Promise<string> {\n    try {\n      const headers = await this.#getAuthorizationHeader();\n      const storageKey = await this.getStorageKey();\n      const encryptedPath = createEntryPath(path, storageKey);\n\n      const url = new URL(STORAGE_URL(this.env, encryptedPath));\n\n      const response = await fetch(url.toString(), {\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n      });\n\n      if (response.status === 404) {\n        throw new NotFoundError(\n          `feature/key set not found for path '${path}'.`,\n        );\n      }\n\n      if (!response.ok) {\n        const responseBody = (await response.json()) as ErrorMessage;\n        throw new Error(\n          `HTTP error message: ${responseBody.message}, error: ${responseBody.error}`,\n        );\n      }\n\n      const { Data: encryptedData } = await response.json();\n      return encryption.decryptString(encryptedData, storageKey);\n    } catch (e) {\n      if (e instanceof NotFoundError) {\n        throw e;\n      }\n\n      /* istanbul ignore next */\n      const errorMessage =\n        e instanceof Error ? e.message : JSON.stringify(e ?? '');\n\n      throw new UserStorageError(\n        `failed to get user storage for path '${path}'. ${errorMessage}`,\n      );\n    }\n  }\n\n  #createEntryKey(key: string, storageKey: string): string {\n    const hashedKey = createSHA256Hash(key + storageKey);\n    return hashedKey;\n  }\n\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  async #getAuthorizationHeader(): Promise<{ Authorization: string }> {\n    const accessToken = await this.config.auth.getAccessToken();\n    return { Authorization: `Bearer ${accessToken}` };\n  }\n}\n"]}