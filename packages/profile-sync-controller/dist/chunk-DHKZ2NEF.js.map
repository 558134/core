{"version":3,"sources":["../src/controllers/authentication/AuthenticationController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  RestrictedControllerMessenger,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { HandleSnapRequest } from '@metamask/snaps-controllers';\n\nimport {\n  createSnapPublicKeyRequest,\n  createSnapSignMessageRequest,\n} from './auth-snap-requests';\nimport {\n  createLoginRawMessage,\n  getAccessToken,\n  getNonce,\n  login,\n} from './services';\n\nconst THIRTY_MIN_MS = 1000 * 60 * 30;\n\nconst controllerName = 'AuthenticationController';\n\n// State\ntype SessionProfile = {\n  identifierId: string;\n  profileId: string;\n};\n\ntype SessionData = {\n  /** profile - anonymous profile data for the given logged in user */\n  profile: SessionProfile;\n  /** accessToken - used to make requests authorized endpoints */\n  accessToken: string;\n  /** expiresIn - string date to determine if new access token is required  */\n  expiresIn: string;\n};\n\ntype MetaMetricsAuth = {\n  getMetaMetricsId: () => string | Promise<string>;\n  agent: 'extension' | 'mobile';\n};\n\nexport type AuthenticationControllerState = {\n  /**\n   * Global isSignedIn state.\n   * Can be used to determine if \"Profile Syncing\" is enabled.\n   */\n  isSignedIn: boolean;\n  sessionData?: SessionData;\n};\nexport const defaultState: AuthenticationControllerState = {\n  isSignedIn: false,\n};\nconst metadata: StateMetadata<AuthenticationControllerState> = {\n  isSignedIn: {\n    persist: true,\n    anonymous: true,\n  },\n  sessionData: {\n    persist: true,\n    anonymous: false,\n  },\n};\n\n// Messenger Actions\ntype CreateActionsObj<Controller extends keyof AuthenticationController> = {\n  [K in Controller]: {\n    type: `${typeof controllerName}:${K}`;\n    handler: AuthenticationController[K];\n  };\n};\ntype ActionsObj = CreateActionsObj<\n  | 'performSignIn'\n  | 'performSignOut'\n  | 'getBearerToken'\n  | 'getSessionProfile'\n  | 'isSignedIn'\n>;\nexport type Actions = ActionsObj[keyof ActionsObj];\nexport type AuthenticationControllerPerformSignIn = ActionsObj['performSignIn'];\nexport type AuthenticationControllerPerformSignOut =\n  ActionsObj['performSignOut'];\nexport type AuthenticationControllerGetBearerToken =\n  ActionsObj['getBearerToken'];\nexport type AuthenticationControllerGetSessionProfile =\n  ActionsObj['getSessionProfile'];\nexport type AuthenticationControllerIsSignedIn = ActionsObj['isSignedIn'];\n\n// Allowed Actions\nexport type AllowedActions = HandleSnapRequest;\n\n// Messenger\nexport type AuthenticationControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  Actions | AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller that enables authentication for restricted endpoints.\n * Used for Global Profile Syncing and Notifications\n */\nexport default class AuthenticationController extends BaseController<\n  typeof controllerName,\n  AuthenticationControllerState,\n  AuthenticationControllerMessenger\n> {\n  #metametrics: MetaMetricsAuth;\n\n  constructor({\n    messenger,\n    state,\n    metametrics,\n  }: {\n    messenger: AuthenticationControllerMessenger;\n    state?: AuthenticationControllerState;\n    /**\n     * Not using the Messaging System as we\n     * do not want to tie this strictly to extension\n     */\n    metametrics: MetaMetricsAuth;\n  }) {\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: { ...defaultState, ...state },\n    });\n\n    if (!metametrics) {\n      throw new Error('`metametrics` field is required');\n    }\n\n    this.#metametrics = metametrics;\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      'AuthenticationController:getBearerToken',\n      this.getBearerToken.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'AuthenticationController:getSessionProfile',\n      this.getSessionProfile.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'AuthenticationController:isSignedIn',\n      this.isSignedIn.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'AuthenticationController:performSignIn',\n      this.performSignIn.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'AuthenticationController:performSignOut',\n      this.performSignOut.bind(this),\n    );\n  }\n\n  public async performSignIn(): Promise<string> {\n    const { accessToken } = await this.#performAuthenticationFlow();\n    return accessToken;\n  }\n\n  public performSignOut(): void {\n    this.#assertLoggedIn();\n\n    this.update((state) => {\n      state.isSignedIn = false;\n      state.sessionData = undefined;\n    });\n  }\n\n  public async getBearerToken(): Promise<string> {\n    this.#assertLoggedIn();\n\n    if (this.#hasValidSession(this.state.sessionData)) {\n      return this.state.sessionData.accessToken;\n    }\n\n    const { accessToken } = await this.#performAuthenticationFlow();\n    return accessToken;\n  }\n\n  /**\n   * Will return a session profile.\n   * Throws if a user is not logged in.\n   *\n   * @returns profile for the session.\n   */\n  public async getSessionProfile(): Promise<SessionProfile> {\n    this.#assertLoggedIn();\n\n    if (this.#hasValidSession(this.state.sessionData)) {\n      return this.state.sessionData.profile;\n    }\n\n    const { profile } = await this.#performAuthenticationFlow();\n    return profile;\n  }\n\n  public isSignedIn(): boolean {\n    return this.state.isSignedIn;\n  }\n\n  #assertLoggedIn(): void {\n    if (!this.state.isSignedIn) {\n      throw new Error(\n        `${controllerName}: Unable to call method, user is not authenticated`,\n      );\n    }\n  }\n\n  async #performAuthenticationFlow(): Promise<{\n    profile: SessionProfile;\n    accessToken: string;\n  }> {\n    try {\n      // 1. Nonce\n      const publicKey = await this.#snapGetPublicKey();\n      const nonce = await getNonce(publicKey);\n      if (!nonce) {\n        throw new Error(`Unable to get nonce`);\n      }\n\n      // 2. Login\n      const rawMessage = createLoginRawMessage(nonce, publicKey);\n      const signature = await this.#snapSignMessage(rawMessage);\n      const loginResponse = await login(rawMessage, signature, {\n        metametricsId: await this.#metametrics.getMetaMetricsId(),\n        agent: this.#metametrics.agent,\n      });\n      if (!loginResponse?.token) {\n        throw new Error(`Unable to login`);\n      }\n\n      const profile: SessionProfile = {\n        identifierId: loginResponse.profile.identifier_id,\n        profileId: loginResponse.profile.profile_id,\n      };\n\n      // 3. Trade for Access Token\n      const accessToken = await getAccessToken(\n        loginResponse.token,\n        this.#metametrics.agent,\n      );\n      if (!accessToken) {\n        throw new Error(`Unable to get Access Token`);\n      }\n\n      // Update Internal State\n      this.update((state) => {\n        state.isSignedIn = true;\n        const expiresIn = new Date();\n        expiresIn.setTime(expiresIn.getTime() + THIRTY_MIN_MS);\n        state.sessionData = {\n          profile,\n          accessToken,\n          expiresIn: expiresIn.toString(),\n        };\n      });\n\n      return {\n        profile,\n        accessToken,\n      };\n    } catch (e) {\n      console.error('Failed to authenticate', e);\n      const errorMessage =\n        e instanceof Error ? e.message : JSON.stringify(e ?? '');\n      throw new Error(\n        `${controllerName}: Failed to authenticate - ${errorMessage}`,\n      );\n    }\n  }\n\n  #hasValidSession(\n    sessionData: SessionData | undefined,\n  ): sessionData is SessionData {\n    if (!sessionData) {\n      return false;\n    }\n\n    const prevDate = Date.parse(sessionData.expiresIn);\n    if (isNaN(prevDate)) {\n      return false;\n    }\n\n    const currentDate = new Date();\n    const diffMs = Math.abs(currentDate.getTime() - prevDate);\n\n    return THIRTY_MIN_MS > diffMs;\n  }\n\n  #_snapPublicKeyCache: string | undefined;\n\n  /**\n   * Returns the auth snap public key.\n   *\n   * @returns The snap public key.\n   */\n  async #snapGetPublicKey(): Promise<string> {\n    if (this.#_snapPublicKeyCache) {\n      return this.#_snapPublicKeyCache;\n    }\n\n    const result = (await this.messagingSystem.call(\n      'SnapController:handleRequest',\n      createSnapPublicKeyRequest(),\n    )) as string;\n\n    this.#_snapPublicKeyCache = result;\n\n    return result;\n  }\n\n  #_snapSignMessageCache: Record<`metamask:${string}`, string> = {};\n\n  /**\n   * Signs a specific message using an underlying auth snap.\n   *\n   * @param message - A specific tagged message to sign.\n   * @returns A Signature created by the snap.\n   */\n  async #snapSignMessage(message: `metamask:${string}`): Promise<string> {\n    if (this.#_snapSignMessageCache[message]) {\n      return this.#_snapSignMessageCache[message];\n    }\n\n    const result = (await this.messagingSystem.call(\n      'SnapController:handleRequest',\n      createSnapSignMessageRequest(message),\n    )) as string;\n\n    this.#_snapSignMessageCache[message] = result;\n\n    return result;\n  }\n}\n"]}