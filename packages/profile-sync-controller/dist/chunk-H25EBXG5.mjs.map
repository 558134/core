{"version":3,"sources":["../src/controllers/user-storage/encryption/cache.ts"],"sourcesContent":["import { base64ToByteArray, byteArrayToBase64 } from './utils';\n\ntype CachedEntry = {\n  salt: Uint8Array;\n  base64Salt: string;\n  key: Uint8Array;\n};\n\nconst MAX_PASSWORD_CACHES = 3;\nconst MAX_SALT_CACHES = 10;\n\n/**\n * In-Memory Caching derived keys based from a given salt and password.\n */\ntype PasswordMemCachedKDF = {\n  [hashedPassword: string]: Map<string, Uint8Array>;\n};\nlet inMemCachedKDF: PasswordMemCachedKDF = {};\nconst getPasswordCache = (hashedPassword: string) => {\n  inMemCachedKDF[hashedPassword] ??= new Map();\n  return inMemCachedKDF[hashedPassword];\n};\n\n/**\n * Returns a given cached derived key from a hashed password and salt\n *\n * @param hashedPassword - hashed password for cache lookup\n * @param salt - provide salt to receive cached key\n * @returns cached key\n */\nexport function getCachedKeyBySalt(\n  hashedPassword: string,\n  salt: Uint8Array,\n): CachedEntry | undefined {\n  const cache = getPasswordCache(hashedPassword);\n  const base64Salt = byteArrayToBase64(salt);\n  const cachedKey = cache.get(base64Salt);\n  if (!cachedKey) {\n    return undefined;\n  }\n\n  return {\n    salt,\n    base64Salt,\n    key: cachedKey,\n  };\n}\n\n/**\n * Gets any cached key for a given hashed password\n *\n * @param hashedPassword - hashed password for cache lookup\n * @returns any (the first) cached key\n */\nexport function getAnyCachedKey(\n  hashedPassword: string,\n): CachedEntry | undefined {\n  const cache = getPasswordCache(hashedPassword);\n\n  // Takes 1 item from an Iterator via Map.entries()\n  const cachedEntry: [string, Uint8Array] | undefined = cache\n    .entries()\n    .next().value;\n\n  if (!cachedEntry) {\n    return undefined;\n  }\n\n  const base64Salt = cachedEntry[0];\n  const bytesSalt = base64ToByteArray(base64Salt);\n  return {\n    salt: bytesSalt,\n    base64Salt,\n    key: cachedEntry[1],\n  };\n}\n\n/**\n * Sets a key to the in memory cache.\n * We have set an arbitrary size of 10 cached keys per hashed password.\n *\n * @param hashedPassword - hashed password for cache lookup\n * @param salt - salt to set new derived key\n * @param key - derived key we are setting\n */\nexport function setCachedKey(\n  hashedPassword: string,\n  salt: Uint8Array,\n  key: Uint8Array,\n): void {\n  // Max password caches\n  if (Object.keys(inMemCachedKDF).length > MAX_PASSWORD_CACHES) {\n    inMemCachedKDF = {};\n  }\n\n  const cache = getPasswordCache(hashedPassword);\n  const base64Salt = byteArrayToBase64(salt);\n\n  // Max salt caches\n  if (cache.size > MAX_SALT_CACHES) {\n    cache.clear();\n  }\n\n  cache.set(base64Salt, key);\n}\n"],"mappings":";;;;;;AAQA,IAAM,sBAAsB;AAC5B,IAAM,kBAAkB;AAQxB,IAAI,iBAAuC,CAAC;AAC5C,IAAM,mBAAmB,CAAC,mBAA2B;AACnD,sEAAmC,oBAAI,IAAI;AAC3C,SAAO,eAAe,cAAc;AACtC;AASO,SAAS,mBACd,gBACA,MACyB;AACzB,QAAM,QAAQ,iBAAiB,cAAc;AAC7C,QAAM,aAAa,kBAAkB,IAAI;AACzC,QAAM,YAAY,MAAM,IAAI,UAAU;AACtC,MAAI,CAAC,WAAW;AACd,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,KAAK;AAAA,EACP;AACF;AAQO,SAAS,gBACd,gBACyB;AACzB,QAAM,QAAQ,iBAAiB,cAAc;AAG7C,QAAM,cAAgD,MACnD,QAAQ,EACR,KAAK,EAAE;AAEV,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA,EACT;AAEA,QAAM,aAAa,YAAY,CAAC;AAChC,QAAM,YAAY,kBAAkB,UAAU;AAC9C,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA,KAAK,YAAY,CAAC;AAAA,EACpB;AACF;AAUO,SAAS,aACd,gBACA,MACA,KACM;AAEN,MAAI,OAAO,KAAK,cAAc,EAAE,SAAS,qBAAqB;AAC5D,qBAAiB,CAAC;AAAA,EACpB;AAEA,QAAM,QAAQ,iBAAiB,cAAc;AAC7C,QAAM,aAAa,kBAAkB,IAAI;AAGzC,MAAI,MAAM,OAAO,iBAAiB;AAChC,UAAM,MAAM;AAAA,EACd;AAEA,QAAM,IAAI,YAAY,GAAG;AAC3B;","names":[]}