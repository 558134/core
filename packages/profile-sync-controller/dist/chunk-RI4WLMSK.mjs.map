{"version":3,"sources":["../src/controllers/user-storage/UserStorageController.ts"],"sourcesContent":["import type {\n  RestrictedControllerMessenger,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { HandleSnapRequest } from '@metamask/snaps-controllers';\n\nimport { createSnapSignMessageRequest } from '../authentication/auth-snap-requests';\nimport type {\n  AuthenticationControllerGetBearerToken,\n  AuthenticationControllerGetSessionProfile,\n  AuthenticationControllerIsSignedIn,\n  AuthenticationControllerPerformSignIn,\n  AuthenticationControllerPerformSignOut,\n} from '../authentication/AuthenticationController';\nimport { createSHA256Hash } from './encryption';\nimport type { UserStoragePath } from './schema';\nimport { getUserStorage, upsertUserStorage } from './services';\n\n// TODO: fix external dependencies\nexport declare type NotificationServicesControllerDisableNotificationServices =\n  {\n    type: `NotificationServicesController:disableNotificationServices`;\n    handler: () => Promise<void>;\n  };\n\nexport declare type NotificationServicesControllerSelectIsNotificationServicesEnabled =\n  {\n    type: `NotificationServicesController:selectIsNotificationServicesEnabled`;\n    handler: () => boolean;\n  };\n\nconst controllerName = 'UserStorageController';\n\n// State\nexport type UserStorageControllerState = {\n  /**\n   * Condition used by UI and to determine if we can use some of the User Storage methods.\n   */\n  isProfileSyncingEnabled: boolean;\n  /**\n   * Loading state for the profile syncing update\n   */\n  isProfileSyncingUpdateLoading: boolean;\n};\n\nexport const defaultState: UserStorageControllerState = {\n  isProfileSyncingEnabled: true,\n  isProfileSyncingUpdateLoading: false,\n};\n\nconst metadata: StateMetadata<UserStorageControllerState> = {\n  isProfileSyncingEnabled: {\n    persist: true,\n    anonymous: true,\n  },\n  isProfileSyncingUpdateLoading: {\n    persist: false,\n    anonymous: false,\n  },\n};\n\n// Messenger Actions\ntype CreateActionsObj<Controller extends keyof UserStorageController> = {\n  [K in Controller]: {\n    type: `${typeof controllerName}:${K}`;\n    handler: UserStorageController[K];\n  };\n};\ntype ActionsObj = CreateActionsObj<\n  | 'performGetStorage'\n  | 'performSetStorage'\n  | 'getStorageKey'\n  | 'enableProfileSyncing'\n  | 'disableProfileSyncing'\n>;\nexport type Actions = ActionsObj[keyof ActionsObj];\nexport type UserStorageControllerPerformGetStorage =\n  ActionsObj['performGetStorage'];\nexport type UserStorageControllerPerformSetStorage =\n  ActionsObj['performSetStorage'];\nexport type UserStorageControllerGetStorageKey = ActionsObj['getStorageKey'];\nexport type UserStorageControllerEnableProfileSyncing =\n  ActionsObj['enableProfileSyncing'];\nexport type UserStorageControllerDisableProfileSyncing =\n  ActionsObj['disableProfileSyncing'];\n\n// Allowed Actions\nexport type AllowedActions =\n  // Snap Requests\n  | HandleSnapRequest\n  // Auth Requests\n  | AuthenticationControllerGetBearerToken\n  | AuthenticationControllerGetSessionProfile\n  | AuthenticationControllerPerformSignIn\n  | AuthenticationControllerIsSignedIn\n  | AuthenticationControllerPerformSignOut\n  // Metamask Notifications\n  | NotificationServicesControllerDisableNotificationServices\n  | NotificationServicesControllerSelectIsNotificationServicesEnabled;\n\n// Messenger\nexport type UserStorageControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  Actions | AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Reusable controller that allows any team to store synchronized data for a given user.\n * These can be settings shared cross MetaMask clients, or data we want to persist when uninstalling/reinstalling.\n *\n * NOTE:\n * - data stored on UserStorage is FULLY encrypted, with the only keys stored/managed on the client.\n * - No one can access this data unless they are have the SRP and are able to run the signing snap.\n */\nexport default class UserStorageController extends BaseController<\n  typeof controllerName,\n  UserStorageControllerState,\n  UserStorageControllerMessenger\n> {\n  #auth = {\n    getBearerToken: async () => {\n      return await this.messagingSystem.call(\n        'AuthenticationController:getBearerToken',\n      );\n    },\n    getProfileId: async () => {\n      const sessionProfile = await this.messagingSystem.call(\n        'AuthenticationController:getSessionProfile',\n      );\n      return sessionProfile?.profileId;\n    },\n    isAuthEnabled: () => {\n      return this.messagingSystem.call('AuthenticationController:isSignedIn');\n    },\n    signIn: async () => {\n      return await this.messagingSystem.call(\n        'AuthenticationController:performSignIn',\n      );\n    },\n    signOut: async () => {\n      return this.messagingSystem.call(\n        'AuthenticationController:performSignOut',\n      );\n    },\n  };\n\n  #notificationServices = {\n    disableNotificationServices: async () => {\n      return await this.messagingSystem.call(\n        'NotificationServicesController:disableNotificationServices',\n      );\n    },\n    selectIsNotificationServicesEnabled: async () => {\n      return this.messagingSystem.call(\n        'NotificationServicesController:selectIsNotificationServicesEnabled',\n      );\n    },\n  };\n\n  getMetaMetricsState: () => boolean;\n\n  constructor(params: {\n    messenger: UserStorageControllerMessenger;\n    state?: UserStorageControllerState;\n    getMetaMetricsState: () => boolean;\n  }) {\n    super({\n      messenger: params.messenger,\n      metadata,\n      name: controllerName,\n      state: { ...defaultState, ...params.state },\n    });\n\n    this.getMetaMetricsState = params.getMetaMetricsState;\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      'UserStorageController:performGetStorage',\n      this.performGetStorage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'UserStorageController:performSetStorage',\n      this.performSetStorage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'UserStorageController:getStorageKey',\n      this.getStorageKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'UserStorageController:enableProfileSyncing',\n      this.enableProfileSyncing.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'UserStorageController:disableProfileSyncing',\n      this.disableProfileSyncing.bind(this),\n    );\n  }\n\n  public async enableProfileSyncing(): Promise<void> {\n    try {\n      this.#setIsProfileSyncingUpdateLoading(true);\n\n      const authEnabled = this.#auth.isAuthEnabled();\n      if (!authEnabled) {\n        await this.#auth.signIn();\n      }\n\n      this.update((state) => {\n        state.isProfileSyncingEnabled = true;\n      });\n\n      this.#setIsProfileSyncingUpdateLoading(false);\n    } catch (e) {\n      this.#setIsProfileSyncingUpdateLoading(false);\n      const errorMessage = e instanceof Error ? e.message : JSON.stringify(e);\n      throw new Error(\n        `${controllerName} - failed to enable profile syncing - ${errorMessage}`,\n      );\n    }\n  }\n\n  public async setIsProfileSyncingEnabled(\n    isProfileSyncingEnabled: boolean,\n  ): Promise<void> {\n    this.update((state) => {\n      state.isProfileSyncingEnabled = isProfileSyncingEnabled;\n    });\n  }\n\n  public async disableProfileSyncing(): Promise<void> {\n    const isAlreadyDisabled = !this.state.isProfileSyncingEnabled;\n    if (isAlreadyDisabled) {\n      return;\n    }\n\n    try {\n      this.#setIsProfileSyncingUpdateLoading(true);\n\n      const isNotificationServicesEnabled =\n        await this.#notificationServices.selectIsNotificationServicesEnabled();\n\n      if (isNotificationServicesEnabled) {\n        await this.#notificationServices.disableNotificationServices();\n      }\n\n      const isMetaMetricsParticipation = this.getMetaMetricsState();\n\n      if (!isMetaMetricsParticipation) {\n        this.messagingSystem.call('AuthenticationController:performSignOut');\n      }\n\n      this.#setIsProfileSyncingUpdateLoading(false);\n\n      this.update((state) => {\n        state.isProfileSyncingEnabled = false;\n      });\n    } catch (e) {\n      this.#setIsProfileSyncingUpdateLoading(false);\n      const errorMessage = e instanceof Error ? e.message : JSON.stringify(e);\n      throw new Error(\n        `${controllerName} - failed to disable profile syncing - ${errorMessage}`,\n      );\n    }\n  }\n\n  /**\n   * Allows retrieval of stored data. Data stored is string formatted.\n   * Developers can extend the entry path and entry name through the `schema.ts` file.\n   *\n   * @param path - string in the form of `${feature}.${key}` that matches schema\n   * @returns the decrypted string contents found from user storage (or null if not found)\n   */\n  public async performGetStorage(\n    path: UserStoragePath,\n  ): Promise<string | null> {\n    this.#assertProfileSyncingEnabled();\n\n    const { bearerToken, storageKey } =\n      await this.#getStorageKeyAndBearerToken();\n\n    const result = await getUserStorage({\n      path,\n      bearerToken,\n      storageKey,\n    });\n\n    return result;\n  }\n\n  /**\n   * Allows storage of user data. Data stored must be string formatted.\n   * Developers can extend the entry path and entry name through the `schema.ts` file.\n   *\n   * @param path - string in the form of `${feature}.${key}` that matches schema\n   * @param value - The string data you want to store.\n   * @returns nothing. NOTE that an error is thrown if fails to store data.\n   */\n  public async performSetStorage(\n    path: UserStoragePath,\n    value: string,\n  ): Promise<void> {\n    this.#assertProfileSyncingEnabled();\n\n    const { bearerToken, storageKey } =\n      await this.#getStorageKeyAndBearerToken();\n\n    await upsertUserStorage(value, {\n      path,\n      bearerToken,\n      storageKey,\n    });\n  }\n\n  /**\n   * Retrieves the storage key, for internal use only!\n   *\n   * @returns the storage key\n   */\n  public async getStorageKey(): Promise<string> {\n    this.#assertProfileSyncingEnabled();\n    const storageKey = await this.#createStorageKey();\n    return storageKey;\n  }\n\n  #assertProfileSyncingEnabled(): void {\n    if (!this.state.isProfileSyncingEnabled) {\n      throw new Error(\n        `${controllerName}: Unable to call method, user is not authenticated`,\n      );\n    }\n  }\n\n  /**\n   * Utility to get the bearer token and storage key\n   */\n  async #getStorageKeyAndBearerToken(): Promise<{\n    bearerToken: string;\n    storageKey: string;\n  }> {\n    const bearerToken = await this.#auth.getBearerToken();\n    if (!bearerToken) {\n      throw new Error('UserStorageController - unable to get bearer token');\n    }\n    const storageKey = await this.#createStorageKey();\n\n    return { bearerToken, storageKey };\n  }\n\n  /**\n   * Rather than storing the storage key, we can compute the storage key when needed.\n   *\n   * @returns the storage key\n   */\n  async #createStorageKey(): Promise<string> {\n    const id: string = await this.#auth.getProfileId();\n    if (!id) {\n      throw new Error('UserStorageController - unable to create storage key');\n    }\n\n    const storageKeySignature = await this.#snapSignMessage(`metamask:${id}`);\n    const storageKey = createSHA256Hash(storageKeySignature);\n    return storageKey;\n  }\n\n  #_snapSignMessageCache: Record<`metamask:${string}`, string> = {};\n\n  /**\n   * Signs a specific message using an underlying auth snap.\n   *\n   * @param message - A specific tagged message to sign.\n   * @returns A Signature created by the snap.\n   */\n  async #snapSignMessage(message: `metamask:${string}`): Promise<string> {\n    if (this.#_snapSignMessageCache[message]) {\n      return this.#_snapSignMessageCache[message];\n    }\n\n    const result = (await this.messagingSystem.call(\n      'SnapController:handleRequest',\n      createSnapSignMessageRequest(message),\n    )) as string;\n\n    this.#_snapSignMessageCache[message] = result;\n\n    return result;\n  }\n\n  #setIsProfileSyncingUpdateLoading(\n    isProfileSyncingUpdateLoading: boolean,\n  ): void {\n    this.update((state) => {\n      state.isProfileSyncingUpdateLoading = isProfileSyncingUpdateLoading;\n    });\n  }\n}\n"],"mappings":"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","names":[]}