{"version":3,"sources":["../src/controllers/authentication/services.ts"],"names":[],"mappings":";;;;;;AAEA,IAAM,WAAW,0BAAkB;AAEnC,IAAM,gBAAwB,SAAS;AAChC,IAAM,sBAAsB,GAAG,aAAa;AAC5C,IAAM,sBAAsB,GAAG,aAAa;AAEnD,IAAM,gBAAwB,SAAS,cAAc;AAC9C,IAAM,uBAAuB,GAAG,aAAa;AACpD,IAAM,iBAAiB,CAAC,aAAqC;AAC3D,MAAI,aAAa,aAAa;AAC5B,WAAO,4DAA2C;AAAA,EACpD;AACA,MAAI,aAAa,UAAU;AACzB,WAAO,sDAAwC;AAAA,EACjD;AAEA,QAAM,IAAI,MAAM,0BAA0B,QAAkB,EAAE;AAChE;AACA,IAAM,kBAAkB;AAYxB,eAAsB,SAAS,WAA2C;AACxE,QAAM,WAAW,IAAI,IAAI,mBAAmB;AAC5C,WAAS,aAAa,IAAI,cAAc,SAAS;AAEjD,MAAI;AACF,UAAM,gBAAgB,MAAM,MAAM,SAAS,SAAS,CAAC;AACrD,QAAI,CAAC,cAAc,IAAI;AACrB,aAAO;AAAA,IACT;AAEA,UAAM,YAA2B,MAAM,cAAc,KAAK;AAC1D,WAAO,WAAW,SAAS;AAAA,EAC7B,SAAS,GAAG;AACV,YAAQ,MAAM,2DAA2D,CAAC;AAC1E,WAAO;AAAA,EACT;AACF;AAqCA,eAAsB,MACpB,YACA,WACA,mBAC+B;AAC/B,MAAI;AACF,UAAM,WAAW,MAAM,MAAM,qBAAqB;AAAA,MAChD,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,MACA,MAAM,KAAK,UAAU;AAAA,QACnB;AAAA;AAAA,QAEA,aAAa;AAAA,QACb,aAAa;AAAA;AAAA,UAEX,gBAAgB,kBAAkB;AAAA,UAClC,OAAO,kBAAkB;AAAA,QAC3B;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,aAAO;AAAA,IACT;AAEA,UAAM,gBAA+B,MAAM,SAAS,KAAK;AACzD,WAAO,iBAAiB;AAAA,EAC1B,SAAS,GAAG;AACV,YAAQ,MAAM,uDAAuD,CAAC;AACtE,WAAO;AAAA,EACT;AACF;AAoBA,eAAsB,eACpB,UACA,UACwB;AACxB,QAAM,UAAU,IAAI,QAAQ;AAAA,IAC1B,gBAAgB;AAAA,EAClB,CAAC;AAED,QAAM,iBAAiB,IAAI,gBAAgB;AAC3C,iBAAe,OAAO,cAAc,eAAe;AACnD,iBAAe,OAAO,aAAa,eAAe,QAAQ,CAAC;AAC3D,iBAAe,OAAO,aAAa,QAAQ;AAE3C,MAAI;AACF,UAAM,WAAW,MAAM,MAAM,sBAAsB;AAAA,MACjD,QAAQ;AAAA,MACR;AAAA,MACA,MAAM,eAAe,SAAS;AAAA,IAChC,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,aAAO;AAAA,IACT;AAEA,UAAM,sBAA0C,MAAM,SAAS,KAAK;AACpE,WAAO,qBAAqB,gBAAgB;AAAA,EAC9C,SAAS,GAAG;AACV,YAAQ;AAAA,MACN;AAAA,MACA;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;AASO,SAAS,sBACd,OACA,WACgC;AAChC,SAAO,YAAY,KAAK,IAAI,SAAS;AACvC","sourcesContent":["import { Env, Platform, getEnvUrls, getOidcClientId } from '../../sdk';\n\nconst ENV_URLS = getEnvUrls(Env.PRD);\n\nconst AUTH_ENDPOINT: string = ENV_URLS.authApiUrl;\nexport const AUTH_NONCE_ENDPOINT = `${AUTH_ENDPOINT}/api/v2/nonce`;\nexport const AUTH_LOGIN_ENDPOINT = `${AUTH_ENDPOINT}/api/v2/srp/login`;\n\nconst OIDC_ENDPOINT: string = ENV_URLS.oidcApiUrl || '';\nexport const OIDC_TOKENS_ENDPOINT = `${OIDC_ENDPOINT}/oauth2/token`;\nconst OIDC_CLIENT_ID = (platform: 'mobile' | 'extension') => {\n  if (platform === 'extension') {\n    return getOidcClientId(Env.PRD, Platform.EXTENSION);\n  }\n  if (platform === 'mobile') {\n    return getOidcClientId(Env.PRD, Platform.MOBILE);\n  }\n\n  throw new Error(`Unsupported platform - ${platform as string}`);\n};\nconst OIDC_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:jwt-bearer';\n\nexport type NonceResponse = {\n  nonce: string;\n};\n\n/**\n * Auth Service - Get Nonce. Used for the initial JWTBearer flow\n *\n * @param publicKey - public key to associate a nonce with\n * @returns the nonce or null if failed\n */\nexport async function getNonce(publicKey: string): Promise<string | null> {\n  const nonceUrl = new URL(AUTH_NONCE_ENDPOINT);\n  nonceUrl.searchParams.set('identifier', publicKey);\n\n  try {\n    const nonceResponse = await fetch(nonceUrl.toString());\n    if (!nonceResponse.ok) {\n      return null;\n    }\n\n    const nonceJson: NonceResponse = await nonceResponse.json();\n    return nonceJson?.nonce ?? null;\n  } catch (e) {\n    console.error('authentication-controller/services: unable to get nonce', e);\n    return null;\n  }\n}\n\n/**\n * The Login API Server Response Shape\n */\nexport type LoginResponse = {\n  token: string;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  expires_in: string;\n  /**\n   * Contains anonymous information about the logged in profile.\n   *\n   * @property identifier_id - a deterministic unique identifier on the method used to sign in\n   * @property profile_id - a unique id for a given profile\n   * @property metametrics_id - an anonymous server id\n   */\n  profile: {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    identifier_id: string;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    profile_id: string;\n  };\n};\n\ntype ClientMetaMetrics = {\n  metametricsId: string;\n  agent: 'extension' | 'mobile';\n};\n\n/**\n * Auth Service - Login. Will perform login with a given signature and will return a single use JWT Token.\n *\n * @param rawMessage - the original message before signing\n * @param signature - the signed message\n * @param clientMetaMetrics - optional client metametrics id (to associate on backend)\n * @returns The Login Response\n */\nexport async function login(\n  rawMessage: string,\n  signature: string,\n  clientMetaMetrics: ClientMetaMetrics,\n): Promise<LoginResponse | null> {\n  try {\n    const response = await fetch(AUTH_LOGIN_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        signature,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        raw_message: rawMessage,\n        metametrics: {\n          // eslint-disable-next-line @typescript-eslint/naming-convention\n          metametrics_id: clientMetaMetrics.metametricsId,\n          agent: clientMetaMetrics.agent,\n        },\n      }),\n    });\n\n    if (!response.ok) {\n      return null;\n    }\n\n    const loginResponse: LoginResponse = await response.json();\n    return loginResponse ?? null;\n  } catch (e) {\n    console.error('authentication-controller/services: unable to login', e);\n    return null;\n  }\n}\n\n/**\n * The Auth API Token Response Shape\n */\nexport type OAuthTokenResponse = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  access_token: string;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  expires_in: number;\n};\n\n/**\n * OIDC Service - Access Token. Trades the Auth Token for an access token (to be used for other authenticated endpoints)\n * NOTE - the access token is short lived, which means it is best practice to validate session before calling authenticated endpoints\n *\n * @param jwtToken - the JWT Auth Token, received from `/login`\n * @param platform - the OIDC platform to retrieve access token\n * @returns JWT Access token to store and use on authorized endpoints.\n */\nexport async function getAccessToken(\n  jwtToken: string,\n  platform: ClientMetaMetrics['agent'],\n): Promise<string | null> {\n  const headers = new Headers({\n    'Content-Type': 'application/x-www-form-urlencoded',\n  });\n\n  const urlEncodedBody = new URLSearchParams();\n  urlEncodedBody.append('grant_type', OIDC_GRANT_TYPE);\n  urlEncodedBody.append('client_id', OIDC_CLIENT_ID(platform));\n  urlEncodedBody.append('assertion', jwtToken);\n\n  try {\n    const response = await fetch(OIDC_TOKENS_ENDPOINT, {\n      method: 'POST',\n      headers,\n      body: urlEncodedBody.toString(),\n    });\n\n    if (!response.ok) {\n      return null;\n    }\n\n    const accessTokenResponse: OAuthTokenResponse = await response.json();\n    return accessTokenResponse?.access_token ?? null;\n  } catch (e) {\n    console.error(\n      'authentication-controller/services: unable to get access token',\n      e,\n    );\n    return null;\n  }\n}\n\n/**\n * Utility to create the raw login message for the JWT bearer flow (via SRP)\n *\n * @param nonce - nonce received from `/nonce` endpoint\n * @param publicKey - public key used to retrieve nonce and for message signing\n * @returns Raw Message which will be used for signing & logging in.\n */\nexport function createLoginRawMessage(\n  nonce: string,\n  publicKey: string,\n): `metamask:${string}:${string}` {\n  return `metamask:${nonce}:${publicKey}` as const;\n}\n"]}