{"version":3,"sources":["../src/LoggingController.ts"],"names":[],"mappings":";;;;;;AACA,SAAS,sBAAsB;AAC/B,SAAS,MAAM,cAAc;AA0B7B,IAAM,OAAO;AAwBb,IAAM,WAAW;AAAA,EACf,MAAM,EAAE,SAAS,MAAM,WAAW,MAAM;AAC1C;AAEA,IAAM,eAAe;AAAA,EACnB,MAAM,CAAC;AACT;AA1DA;AA+DO,IAAM,oBAAN,cAAgC,eAIrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY;AAAA,IACV;AAAA,IACA;AAAA,EACF,GAGG;AACD,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG;AAAA,MACL;AAAA,IACF,CAAC;AAiBH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAfE,SAAK,gBAAgB;AAAA,MACnB,GAAG,IAAI;AAAA,MACP,CAAC,QAAa,KAAK,IAAI,GAAG;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,IAAI,KAAU;AACZ,UAAM,SAAmB;AAAA,MACvB,IAAI,sBAAK,4BAAL;AAAA,MACJ,WAAW,KAAK,IAAI;AAAA,MACpB;AAAA,IACF;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,KAAK,OAAO,EAAE,IAAI;AAAA,IAC1B,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,OAAO,CAAC;AAAA,IAChB,CAAC;AAAA,EACH;AACF;AAjCE;AAAA,gBAAW,WAAW;AACpB,MAAI,KAAK,OAAO;AAChB,SAAO,MAAM,KAAK,MAAM,MAAM;AAC5B,SAAK,OAAO;AAAA,EACd;AACA,SAAO;AACT","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { v1 as random } from 'uuid';\n\nimport type { Log } from './logTypes';\n\n/**\n * LogEntry is the entry that will be added to the logging controller state.\n * It consists of a entry key that must be on of the Log union types, and an\n * additional id and timestamp.\n */\nexport type LogEntry = {\n  id: string;\n  timestamp: number;\n  log: Log;\n};\n\n/**\n * Logging controller state\n *\n * @property logs - An object of logs indexed by their ids\n */\nexport type LoggingControllerState = {\n  logs: {\n    [id: string]: LogEntry;\n  };\n};\n\nconst name = 'LoggingController';\n\n/**\n * An action to add log messages to the controller state.\n */\nexport type AddLog = {\n  type: `${typeof name}:add`;\n  handler: LoggingController['add'];\n};\n\n/**\n * Currently only an alias, but the idea here is if future actions are needed\n * this can transition easily into a union type.\n */\nexport type LoggingControllerActions = AddLog;\n\nexport type LoggingControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  LoggingControllerActions,\n  never,\n  never,\n  never\n>;\n\nconst metadata = {\n  logs: { persist: true, anonymous: false },\n};\n\nconst defaultState = {\n  logs: {},\n};\n\n/**\n * Controller that manages a list of logs for signature requests.\n */\nexport class LoggingController extends BaseController<\n  typeof name,\n  LoggingControllerState,\n  LoggingControllerMessenger\n> {\n  /**\n   * Creates a LoggingController instance.\n   *\n   * @param options - Constructor options\n   * @param options.messenger - An instance of the ControllerMessenger\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: LoggingControllerMessenger;\n    state?: Partial<LoggingControllerState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:add` as const,\n      (log: Log) => this.add(log),\n    );\n  }\n\n  /**\n   * Method to generate a randomId and ensures no collision with existing ids.\n   *\n   * We may want to end up using a hashing mechanism to make ids deterministic\n   * by the *data* passed in, and then make each key an array of logs that\n   * match that id.\n   *\n   * @returns unique id\n   */\n  #generateId(): string {\n    let id = random();\n    while (id in this.state.logs) {\n      id = random();\n    }\n    return id;\n  }\n\n  /**\n   * Add log to the state.\n   *\n   * @param log - Log to add to the controller\n   */\n  add(log: Log) {\n    const newLog: LogEntry = {\n      id: this.#generateId(),\n      timestamp: Date.now(),\n      log,\n    };\n\n    this.update((state) => {\n      state.logs[newLog.id] = newLog;\n    });\n  }\n\n  /**\n   * Removes all log entries.\n   */\n  clear() {\n    this.update((state) => {\n      state.logs = {};\n    });\n  }\n}\n"]}