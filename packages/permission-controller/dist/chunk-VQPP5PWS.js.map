{"version":3,"sources":["../src/utils.ts"],"names":["MethodNames"],"mappings":";AAsBO,IAAK,cAAL,kBAAKA,iBAAL;AACL,EAAAA,aAAA,wBAAqB;AACrB,EAAAA,aAAA,oBAAiB;AACjB,EAAAA,aAAA,uBAAoB;AAHV,SAAAA;AAAA,GAAA;AAsEL,SAAS,8BACd,gBACA,iBACA;AACA,QAAM,cAAc,gBAAgB,SAAS,MAAM,KAAK,CAAC;AACzD,QAAM,eAAe,gBAAgB,SAAS,MAAM,KAAK,CAAC;AAC1D,QAAM,oBAAwC,CAAC;AAC/C,QAAM,cAAsD,CAAC;AAE7D,cAAY,QAAQ,CAAC,eAAe;AAClC,UAAM,mBAAmB,aAAa;AAAA,MACpC,CAAC,gBAAgB,YAAY,SAAS,WAAW;AAAA,IACnD;AAEA,QAAI,qBAAqB,IAAI;AAC3B,wBAAkB,KAAK,UAAU;AAAA,IACnC,OAAO;AACL,kBAAY,KAAK,CAAC,YAAY,aAAa,gBAAgB,CAAC,CAAC;AAC7D,mBAAa,OAAO,kBAAkB,CAAC;AAAA,IACzC;AAAA,EACF,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,oBAAoB,CAAC,GAAG,YAAY;AAAA,EACtC;AACF","sourcesContent":["import type {\n  JsonRpcEngineEndCallback,\n  JsonRpcEngineNextCallback,\n} from '@metamask/json-rpc-engine';\nimport type {\n  Json,\n  JsonRpcParams,\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n} from '@metamask/utils';\n\nimport type {\n  CaveatConstraint,\n  CaveatSpecificationConstraint,\n  CaveatSpecificationMap,\n} from './Caveat';\nimport type {\n  PermissionConstraint,\n  PermissionSpecificationConstraint,\n  PermissionSpecificationMap,\n} from './Permission';\n\nexport enum MethodNames {\n  RequestPermissions = 'wallet_requestPermissions',\n  GetPermissions = 'wallet_getPermissions',\n  RevokePermissions = 'wallet_revokePermissions',\n}\n\n/**\n * Utility type for extracting a union of all individual caveat or permission\n * specification types from a {@link CaveatSpecificationMap} or\n * {@link PermissionSpecificationMap}.\n *\n * @template SpecificationsMap - The caveat or permission specifications map\n * whose specification type union to extract.\n */\nexport type ExtractSpecifications<\n  SpecificationsMap extends\n    | CaveatSpecificationMap<CaveatSpecificationConstraint>\n    | PermissionSpecificationMap<PermissionSpecificationConstraint>,\n> = SpecificationsMap[keyof SpecificationsMap];\n\n/**\n * A middleware function for handling a permitted method.\n */\nexport type HandlerMiddlewareFunction<\n  Hooks,\n  Params extends JsonRpcParams,\n  Result extends Json,\n> = (\n  req: JsonRpcRequest<Params>,\n  res: PendingJsonRpcResponse<Result>,\n  next: JsonRpcEngineNextCallback,\n  end: JsonRpcEngineEndCallback,\n  hooks: Hooks,\n) => void | Promise<void>;\n\n/**\n * We use a mapped object type in order to create a type that requires the\n * presence of the names of all hooks for the given handler.\n * This can then be used to select only the necessary hooks whenever a method\n * is called for purposes of POLA.\n */\nexport type HookNames<HookMap> = {\n  [Property in keyof HookMap]: true;\n};\n\n/**\n * A handler for a permitted method.\n */\nexport type PermittedHandlerExport<\n  Hooks,\n  Params extends JsonRpcParams,\n  Result extends Json,\n> = {\n  implementation: HandlerMiddlewareFunction<Hooks, Params, Result>;\n  hookNames: HookNames<Hooks>;\n  methodNames: string[];\n};\n\n/**\n * Given two permission objects, computes 3 sets:\n * - The set of caveat pairs that are common to both permissions.\n * - The set of caveats that are unique to the existing permission.\n * - The set of caveats that are unique to the requested permission.\n *\n * Assumes that the caveat arrays of both permissions are valid.\n *\n * @param leftPermission - The left-hand permission.\n * @param rightPermission - The right-hand permission.\n * @returns The sets of caveat pairs and unique caveats.\n */\nexport function collectUniqueAndPairedCaveats(\n  leftPermission: Partial<PermissionConstraint> | undefined,\n  rightPermission: Partial<PermissionConstraint>,\n) {\n  const leftCaveats = leftPermission?.caveats?.slice() ?? [];\n  const rightCaveats = rightPermission.caveats?.slice() ?? [];\n  const leftUniqueCaveats: CaveatConstraint[] = [];\n  const caveatPairs: [CaveatConstraint, CaveatConstraint][] = [];\n\n  leftCaveats.forEach((leftCaveat) => {\n    const rightCaveatIndex = rightCaveats.findIndex(\n      (rightCaveat) => rightCaveat.type === leftCaveat.type,\n    );\n\n    if (rightCaveatIndex === -1) {\n      leftUniqueCaveats.push(leftCaveat);\n    } else {\n      caveatPairs.push([leftCaveat, rightCaveats[rightCaveatIndex]]);\n      rightCaveats.splice(rightCaveatIndex, 1);\n    }\n  });\n\n  return {\n    caveatPairs,\n    leftUniqueCaveats,\n    rightUniqueCaveats: [...rightCaveats],\n  };\n}\n"]}