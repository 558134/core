{"version":3,"sources":["../src/RateLimitController.ts"],"names":[],"mappings":";AAMA,SAAS,sBAAsB;AAC/B,SAAS,iBAAiB;AAC1B,SAAS,6BAA6B;AAmCtC,IAAM,OAAO;AAoCb,IAAM,WAAW;AAAA,EACf,UAAU,EAAE,SAAS,OAAO,WAAW,MAAM;AAC/C;AAKO,IAAM,sBAAN,cAEG,eAIR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,YAAY;AAAA,IACV,mBAAmB;AAAA,IACnB,iBAAiB;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAMG;AACD,UAAM,eAAe;AAAA,MACnB,UAAU,sBAAsB,eAAe,EAAE,OAE/C,CAAC,KAAK,SAAS,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,CAAC,EAAE,IAAI,CAAC,CAAU;AAAA,IACtD;AACA,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO,EAAE,GAAG,cAAc,GAAG,MAAM;AAAA,IACrC,CAAC;AACD,SAAK,kBAAkB;AACvB,SAAK,mBAAmB;AACxB,SAAK,iBAAiB;AAEtB,SAAK,gBAAgB;AAAA,MACnB,GAAG,IAAI;AAAA,MACP,CACE,QACA,SACG,SACA,KAAK,KAAK,QAAQ,MAAM,GAAG,IAAI;AAAA,IACtC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,KACJ,QACA,SACG,MACsD;AACzD,QAAI,KAAK,cAAc,MAAM,MAAM,GAAG;AACpC,YAAM,UAAU,cAAc;AAAA,QAC5B,SAAS,IAAI,KAAK,SAAS,CAAC;AAAA,MAC9B,CAAC;AAAA,IACH;AACA,SAAK,cAAc,MAAM,MAAM;AAE/B,UAAM,iBAAiB,KAAK,gBAAgB,IAAI,EAAE;AAElD,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AAEA,WAAO,eAAe,GAAG,IAAI;AAAA,EAG/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,cAAc,KAA4B,QAAgB;AAChE,UAAM,iBACJ,KAAK,gBAAgB,GAAG,EAAE,kBAAkB,KAAK;AACnD,WAAO,KAAK,MAAM,SAAS,GAAG,EAAE,MAAM,KAAK;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,cAAc,KAA4B,QAAgB;AAChE,UAAM,mBACJ,KAAK,gBAAgB,GAAG,EAAE,oBAAoB,KAAK;AACrD,UAAM,WAAW,KAAK,MAAM,SAAS,GAAG,EAAE,MAAM,KAAK;AACrD,SAAK,OAAO,CAAC,UAAU;AACrB,UAAI,aAAa,GAAG;AAClB,mBAAW,MAAM,KAAK,kBAAkB,KAAK,MAAM,GAAG,gBAAgB;AAAA,MACxE;AACA,aAAO,OAAO,OAAO;AAAA,QACnB,UAAU;AAAA,UACR,GAAI,MAAM;AAAA;AAAA;AAAA,UAGV,CAAC,GAAG,GAAG,EAAE,CAAC,MAAM,GAAG,WAAW,EAAE;AAAA,QAClC;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,kBAAkB,KAA4B,QAAgB;AACpE,SAAK,OAAO,CAAC,UAAU;AACrB,aAAO,OAAO,OAAO;AAAA,QACnB,UAAU;AAAA,UACR,GAAI,MAAM;AAAA,UACV,CAAC,GAAG,GAAG,EAAE,CAAC,MAAM,GAAG,EAAE;AAAA,QACvB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF","sourcesContent":["import type {\n  ActionConstraint,\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport { getKnownPropertyNames } from '@metamask/utils';\n\n/**\n * A rate-limited API endpoint.\n * @property method - The method that is rate-limited.\n * @property rateLimitTimeout - The time window in which the rate limit is applied (in ms).\n * @property rateLimitCount - The amount of calls an origin can make in the rate limit time window.\n */\nexport type RateLimitedApi = {\n  method: ActionConstraint['handler'];\n  rateLimitTimeout?: number;\n  rateLimitCount?: number;\n};\n\n/**\n * A map of rate-limited API types to APIs.\n */\nexport type RateLimitedApiMap = Record<string, RateLimitedApi>;\n\n/**\n * A map of rate-limited API types to the number of requests made in a given interval for each origin and api type combination.\n * @template RateLimitedApis - A {@link RateLimitedApiMap} containing the rate-limited API endpoints that is used by the {@link RateLimitController}.\n */\nexport type RateLimitedRequests<RateLimitedApis extends RateLimitedApiMap> =\n  Record<keyof RateLimitedApis, Record<string, number>>;\n\n/**\n * The state of the {@link RateLimitController}.\n * @template RateLimitedApis - A {@link RateLimitedApiMap} containing the rate-limited API endpoints that is used by the {@link RateLimitController}.\n * @property requests - An object containing the number of requests made in a given interval for each origin and api type combination.\n */\nexport type RateLimitState<RateLimitedApis extends RateLimitedApiMap> = {\n  requests: RateLimitedRequests<RateLimitedApis>;\n};\n\nconst name = 'RateLimitController';\n\nexport type RateLimitControllerStateChangeEvent<\n  RateLimitedApis extends RateLimitedApiMap,\n> = ControllerStateChangeEvent<typeof name, RateLimitState<RateLimitedApis>>;\n\nexport type RateLimitControllerGetStateAction<\n  RateLimitedApis extends RateLimitedApiMap,\n> = ControllerGetStateAction<typeof name, RateLimitState<RateLimitedApis>>;\n\nexport type RateLimitControllerCallApiAction<\n  RateLimitedApis extends RateLimitedApiMap,\n> = {\n  type: `${typeof name}:call`;\n  handler: RateLimitController<RateLimitedApis>['call'];\n};\n\nexport type RateLimitControllerActions<\n  RateLimitedApis extends RateLimitedApiMap,\n> =\n  | RateLimitControllerGetStateAction<RateLimitedApis>\n  | RateLimitControllerCallApiAction<RateLimitedApis>;\n\nexport type RateLimitControllerEvents<\n  RateLimitedApis extends RateLimitedApiMap,\n> = RateLimitControllerStateChangeEvent<RateLimitedApis>;\n\nexport type RateLimitMessenger<RateLimitedApis extends RateLimitedApiMap> =\n  RestrictedControllerMessenger<\n    typeof name,\n    RateLimitControllerActions<RateLimitedApis>,\n    RateLimitControllerEvents<RateLimitedApis>,\n    never,\n    never\n  >;\n\nconst metadata = {\n  requests: { persist: false, anonymous: false },\n};\n\n/**\n * Controller with logic for rate-limiting API endpoints per requesting origin.\n */\nexport class RateLimitController<\n  RateLimitedApis extends RateLimitedApiMap,\n> extends BaseController<\n  typeof name,\n  RateLimitState<RateLimitedApis>,\n  RateLimitMessenger<RateLimitedApis>\n> {\n  private readonly implementations;\n\n  private readonly rateLimitTimeout;\n\n  private readonly rateLimitCount;\n\n  /**\n   * Creates a RateLimitController instance.\n   *\n   * @param options - Constructor options.\n   * @param options.messenger - A reference to the messaging system.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.implementations - Mapping from API type to API implementation.\n   * @param options.rateLimitTimeout - The time window in which the rate limit is applied (in ms).\n   * @param options.rateLimitCount - The amount of calls an origin can make in the rate limit time window.\n   */\n  constructor({\n    rateLimitTimeout = 5000,\n    rateLimitCount = 1,\n    messenger,\n    state,\n    implementations,\n  }: {\n    rateLimitTimeout?: number;\n    rateLimitCount?: number;\n    messenger: RateLimitMessenger<RateLimitedApis>;\n    state?: Partial<RateLimitState<RateLimitedApis>>;\n    implementations: RateLimitedApis;\n  }) {\n    const defaultState = {\n      requests: getKnownPropertyNames(implementations).reduce<\n        RateLimitedRequests<RateLimitedApis>\n      >((acc, key) => ({ ...acc, [key]: {} }), {} as never),\n    };\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.implementations = implementations;\n    this.rateLimitTimeout = rateLimitTimeout;\n    this.rateLimitCount = rateLimitCount;\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:call`,\n      (\n        origin: string,\n        type: keyof RateLimitedApis,\n        ...args: Parameters<RateLimitedApis[typeof type]['method']>\n      ) => this.call(origin, type, ...args),\n    );\n  }\n\n  /**\n   * Calls an API if the requesting origin is not rate-limited.\n   *\n   * @param origin - The requesting origin.\n   * @param type - The type of API call to make.\n   * @param args - Arguments for the API call.\n   */\n  async call<ApiType extends keyof RateLimitedApis>(\n    origin: string,\n    type: ApiType,\n    ...args: Parameters<RateLimitedApis[ApiType]['method']>\n  ): Promise<ReturnType<RateLimitedApis[ApiType]['method']>> {\n    if (this.isRateLimited(type, origin)) {\n      throw rpcErrors.limitExceeded({\n        message: `\"${type.toString()}\" is currently rate-limited. Please try again later.`,\n      });\n    }\n    this.recordRequest(type, origin);\n\n    const implementation = this.implementations[type].method;\n\n    if (!implementation) {\n      throw new Error('Invalid api type');\n    }\n\n    return implementation(...args) as ReturnType<\n      RateLimitedApis[ApiType]['method']\n    >;\n  }\n\n  /**\n   * Checks whether an origin is rate limited for the a specific API.\n   *\n   * @param api - The API the origin is trying to access.\n   * @param origin - The origin trying to access the API.\n   * @returns `true` if rate-limited, and `false` otherwise.\n   */\n  private isRateLimited(api: keyof RateLimitedApis, origin: string) {\n    const rateLimitCount =\n      this.implementations[api].rateLimitCount ?? this.rateLimitCount;\n    return this.state.requests[api][origin] >= rateLimitCount;\n  }\n\n  /**\n   * Records that an origin has made a request to call an API, for rate-limiting purposes.\n   *\n   * @param api - The API the origin is trying to access.\n   * @param origin - The origin trying to access the API.\n   */\n  private recordRequest(api: keyof RateLimitedApis, origin: string) {\n    const rateLimitTimeout =\n      this.implementations[api].rateLimitTimeout ?? this.rateLimitTimeout;\n    const previous = this.state.requests[api][origin] ?? 0;\n    this.update((state) => {\n      if (previous === 0) {\n        setTimeout(() => this.resetRequestCount(api, origin), rateLimitTimeout);\n      }\n      Object.assign(state, {\n        requests: {\n          ...(state.requests as RateLimitedRequests<RateLimitedApis>),\n          // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n          // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n          [api]: { [origin]: previous + 1 },\n        },\n      });\n    });\n  }\n\n  /**\n   * Resets the request count for a given origin and API combination, for rate-limiting purposes.\n   *\n   * @param api - The API in question.\n   * @param origin - The origin in question.\n   */\n  private resetRequestCount(api: keyof RateLimitedApis, origin: string) {\n    this.update((state) => {\n      Object.assign(state, {\n        requests: {\n          ...(state.requests as RateLimitedRequests<RateLimitedApis>),\n          [api]: { [origin]: 0 },\n        },\n      });\n    });\n  }\n}\n"]}