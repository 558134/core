{"version":3,"file":"PhishingController.js","sourceRoot":"","sources":["../src/PhishingController.ts"],"names":[],"mappings":"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","sourcesContent":["import crossFetch from 'cross-fetch';\nimport { toASCII } from 'punycode/';\nimport DEFAULT_PHISHING_RESPONSE from 'eth-phishing-detect/src/config.json';\nimport PhishingDetector from 'eth-phishing-detect/src/detector';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\n\n/**\n * @type EthPhishingResponse\n *\n * Configuration response from the eth-phishing-detect package\n * consisting of approved and unapproved website origins\n * @property blacklist - List of unapproved origins\n * @property fuzzylist - List of fuzzy-matched unapproved origins\n * @property tolerance - Fuzzy match tolerance level\n * @property version - Version number of this configuration\n * @property whitelist - List of approved origins\n */\nexport interface EthPhishingResponse {\n  blacklist: string[];\n  fuzzylist: string[];\n  tolerance: number;\n  version: number;\n  whitelist: string[];\n}\n\n/**\n * @type EthPhishingDetectConfig\n *\n * Interface defining expected input to PhishingDetector.\n * @property allowlist - List of approved origins (legacy naming \"whitelist\")\n * @property blocklist - List of unapproved origins (legacy naming \"blacklist\")\n * @property fuzzylist - List of fuzzy-matched unapproved origins\n * @property tolerance - Fuzzy match tolerance level\n */\nexport interface EthPhishingDetectConfig {\n  allowlist: string[];\n  blocklist: string[];\n  fuzzylist: string[];\n  tolerance: number;\n  name: string;\n  version: number;\n}\n\n/**\n * @type EthPhishingDetectResult\n *\n * Interface that describes the result of the `test` method.\n * @property name - Name of the config on which a match was found.\n * @property version - Version of the config on which a match was found.\n * @property result - Whether a domain was detected as a phishing domain. True means an unsafe domain.\n * @property match - The matching fuzzylist origin when a fuzzylist match is found. Returned as undefined for non-fuzzy true results.\n * @property type - The field of the config on which a match was found.\n */\nexport interface EthPhishingDetectResult {\n  name?: string;\n  version?: string;\n  result: boolean;\n  match?: string; // Returned as undefined for non-fuzzy true results.\n  type: 'all' | 'fuzzy' | 'blocklist' | 'allowlist';\n}\n\n/**\n * @type PhishingConfig\n *\n * Phishing controller configuration\n * @property interval - Polling interval used to fetch new block / approve lists\n */\nexport interface PhishingConfig extends BaseConfig {\n  refreshInterval: number;\n}\n\n/**\n * @type PhishingState\n *\n * Phishing controller state\n * @property phishing - eth-phishing-detect configuration\n * @property whitelist - array of temporarily-approved origins\n */\nexport interface PhishingState extends BaseState {\n  phishing: EthPhishingDetectConfig[];\n  whitelist: string[];\n}\n\nexport const PHISHING_CONFIG_BASE_URL =\n  'https://static.metafi.codefi.network/api/v1/lists';\n\nexport const METAMASK_CONFIG_FILE = '/eth_phishing_detect_config.json';\n\nexport const PHISHFORT_HOTLIST_FILE = '/phishfort_hotlist.json';\n\nexport const METAMASK_CONFIG_URL = `${PHISHING_CONFIG_BASE_URL}${METAMASK_CONFIG_FILE}`;\nexport const PHISHFORT_HOTLIST_URL = `${PHISHING_CONFIG_BASE_URL}${PHISHFORT_HOTLIST_FILE}`;\n\n/**\n * Controller that passively polls on a set interval for approved and unapproved website origins\n */\nexport class PhishingController extends BaseController<\n  PhishingConfig,\n  PhishingState\n> {\n  private detector: any;\n\n  private lastFetched = 0;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'PhishingController';\n\n  /**\n   * Creates a PhishingController instance.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    config?: Partial<PhishingConfig>,\n    state?: Partial<PhishingState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      refreshInterval: 60 * 60 * 1000,\n    };\n\n    this.defaultState = {\n      phishing: [\n        {\n          allowlist: DEFAULT_PHISHING_RESPONSE.whitelist,\n          blocklist: DEFAULT_PHISHING_RESPONSE.blacklist,\n          fuzzylist: DEFAULT_PHISHING_RESPONSE.fuzzylist,\n          tolerance: DEFAULT_PHISHING_RESPONSE.tolerance,\n          name: `MetaMask`,\n          version: DEFAULT_PHISHING_RESPONSE.version,\n        },\n      ],\n      whitelist: [],\n    };\n    this.detector = new PhishingDetector(this.defaultState.phishing);\n    this.initialize();\n  }\n\n  /**\n   * Set the interval at which the phishing list will be refetched. Fetching will only occur on the next call to test/bypass. For immediate update to the phishing list, call updatePhishingLists directly.\n   *\n   * @param interval - the new interval, in ms.\n   */\n  setRefreshInterval(interval: number) {\n    this.configure({ refreshInterval: interval }, false, false);\n  }\n\n  /**\n   * Calls this.updatePhishingLists if this.refreshInterval has passed since last this.lastFetched.\n   *\n   * @returns Promise<void> when finished fetching phishing lists or when fetching in not necessary.\n   */\n  private async fetchIfNecessary(): Promise<void> {\n    const outOfDate =\n      Date.now() - this.lastFetched >= this.config.refreshInterval;\n\n    if (outOfDate) {\n      await this.updatePhishingLists();\n    }\n  }\n\n  /**\n   * Determines if a given origin is unapproved.\n   *\n   * @param origin - Domain origin of a website.\n   * @returns Promise<EthPhishingDetectResult> Whether the origin is an unapproved origin.\n   */\n  async test(origin: string): Promise<EthPhishingDetectResult> {\n    await this.fetchIfNecessary();\n\n    const punycodeOrigin = toASCII(origin);\n    if (this.state.whitelist.indexOf(punycodeOrigin) !== -1) {\n      return { result: false, type: 'all' }; // Same as whitelisted match returned by detector.check(...).\n    }\n    return this.detector.check(punycodeOrigin);\n  }\n\n  /**\n   * Temporarily marks a given origin as approved.\n   *\n   * @param origin - The origin to mark as approved.\n   */\n  bypass(origin: string) {\n    const punycodeOrigin = toASCII(origin);\n    const { whitelist } = this.state;\n    if (whitelist.indexOf(punycodeOrigin) !== -1) {\n      return;\n    }\n    this.update({ whitelist: [...whitelist, punycodeOrigin] });\n  }\n\n  /**\n   * Updates lists of approved and unapproved website origins.\n   */\n  async updatePhishingLists() {\n    if (this.disabled) {\n      return;\n    }\n\n    this.lastFetched = Date.now();\n\n    const configs: EthPhishingDetectConfig[] = [];\n\n    // We ignore network failures here instead of bubbling them up\n    const [metamaskConfigLegacy, phishfortHotlist] = await Promise.all([\n      this.queryConfig<EthPhishingResponse>(METAMASK_CONFIG_URL),\n      this.queryConfig<string[]>(PHISHFORT_HOTLIST_URL),\n    ]);\n\n    // Correctly shaping MetaMask config.\n    const metamaskConfig: EthPhishingDetectConfig = {\n      allowlist: metamaskConfigLegacy ? metamaskConfigLegacy.whitelist : [],\n      blocklist: metamaskConfigLegacy ? metamaskConfigLegacy.blacklist : [],\n      fuzzylist: metamaskConfigLegacy ? metamaskConfigLegacy.fuzzylist : [],\n      tolerance: metamaskConfigLegacy ? metamaskConfigLegacy.tolerance : 0,\n      name: `MetaMask`,\n      version: metamaskConfigLegacy ? metamaskConfigLegacy.version : 0,\n    };\n    if (metamaskConfigLegacy) {\n      configs.push(metamaskConfig);\n    }\n\n    // Correctly shaping PhishFort config.\n    const phishfortConfig: EthPhishingDetectConfig = {\n      allowlist: [],\n      blocklist: (phishfortHotlist || []).filter(\n        (i) => !metamaskConfig.blocklist.includes(i),\n      ), // Removal of duplicates.\n      fuzzylist: [],\n      tolerance: 0,\n      name: `PhishFort`,\n      version: 1,\n    };\n    if (phishfortHotlist) {\n      configs.push(phishfortConfig);\n    }\n\n    // Do not update if all configs are unavailable.\n    if (!configs.length) {\n      return;\n    }\n\n    this.detector = new PhishingDetector(configs);\n    this.update({\n      phishing: configs,\n    });\n  }\n\n  private async queryConfig<ResponseType>(\n    input: RequestInfo,\n  ): Promise<ResponseType | null> {\n    const response = await safelyExecute(\n      () => crossFetch(input, { cache: 'no-cache' }),\n      true,\n    );\n\n    switch (response?.status) {\n      case 200: {\n        return await response.json();\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n}\n\nexport default PhishingController;\n"]}