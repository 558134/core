{"version":3,"sources":["../src/KeyringController.ts"],"sourcesContent":["import type { TxData, TypedTransaction } from '@ethereumjs/tx';\nimport { isValidPrivate, toBuffer, getBinarySize } from '@ethereumjs/util';\nimport type {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport * as encryptorUtils from '@metamask/browser-passworder';\nimport HDKeyring from '@metamask/eth-hd-keyring';\nimport { normalize as ethNormalize } from '@metamask/eth-sig-util';\nimport SimpleKeyring from '@metamask/eth-simple-keyring';\nimport type {\n  EthBaseTransaction,\n  EthBaseUserOperation,\n  EthKeyring,\n  EthUserOperation,\n  EthUserOperationPatch,\n  KeyringExecutionContext,\n} from '@metamask/keyring-api';\nimport type {\n  PersonalMessageParams,\n  TypedMessageParams,\n} from '@metamask/message-manager';\nimport type {\n  Eip1024EncryptedData,\n  Hex,\n  Json,\n  KeyringClass,\n} from '@metamask/utils';\nimport {\n  add0x,\n  assertIsStrictHexString,\n  bytesToHex,\n  hasProperty,\n  isObject,\n  isStrictHexString,\n  isValidHexAddress,\n  isValidJson,\n  remove0x,\n} from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { MutexInterface } from 'async-mutex';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport type { Patch } from 'immer';\n\nimport { KeyringControllerError } from './constants';\n\nconst name = 'KeyringController';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  simple = 'Simple Key Pair',\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  hd = 'HD Key Tree',\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  qr = 'QR Hardware Wallet Device',\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  trezor = 'Trezor Hardware',\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ledger = 'Ledger Hardware',\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  lattice = 'Lattice Hardware',\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  snap = 'Snap Keyring',\n}\n\n/**\n * Custody keyring types are a special case, as they are not a single type\n * but they all start with the prefix \"Custody\".\n * @param keyringType - The type of the keyring.\n * @returns Whether the keyring type is a custody keyring.\n */\nexport const isCustodyKeyring = (keyringType: string): boolean => {\n  return keyringType.startsWith('Custody');\n};\n\n/**\n * @type KeyringControllerState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n * @property encryptionKey - Keyring encryption key\n * @property encryptionSalt - Keyring encryption salt\n */\nexport type KeyringControllerState = {\n  vault?: string;\n  isUnlocked: boolean;\n  keyrings: KeyringObject[];\n  encryptionKey?: string;\n  encryptionSalt?: string;\n};\n\nexport type KeyringControllerMemState = Omit<\n  KeyringControllerState,\n  'vault' | 'encryptionKey' | 'encryptionSalt'\n>;\n\nexport type KeyringControllerGetStateAction = {\n  type: `${typeof name}:getState`;\n  handler: () => KeyringControllerState;\n};\n\nexport type KeyringControllerSignMessageAction = {\n  type: `${typeof name}:signMessage`;\n  handler: KeyringController['signMessage'];\n};\n\nexport type KeyringControllerSignPersonalMessageAction = {\n  type: `${typeof name}:signPersonalMessage`;\n  handler: KeyringController['signPersonalMessage'];\n};\n\nexport type KeyringControllerSignTypedMessageAction = {\n  type: `${typeof name}:signTypedMessage`;\n  handler: KeyringController['signTypedMessage'];\n};\n\nexport type KeyringControllerDecryptMessageAction = {\n  type: `${typeof name}:decryptMessage`;\n  handler: KeyringController['decryptMessage'];\n};\n\nexport type KeyringControllerGetEncryptionPublicKeyAction = {\n  type: `${typeof name}:getEncryptionPublicKey`;\n  handler: KeyringController['getEncryptionPublicKey'];\n};\n\nexport type KeyringControllerGetKeyringsByTypeAction = {\n  type: `${typeof name}:getKeyringsByType`;\n  handler: KeyringController['getKeyringsByType'];\n};\n\nexport type KeyringControllerGetKeyringForAccountAction = {\n  type: `${typeof name}:getKeyringForAccount`;\n  handler: KeyringController['getKeyringForAccount'];\n};\n\nexport type KeyringControllerGetAccountsAction = {\n  type: `${typeof name}:getAccounts`;\n  handler: KeyringController['getAccounts'];\n};\n\nexport type KeyringControllerPersistAllKeyringsAction = {\n  type: `${typeof name}:persistAllKeyrings`;\n  handler: KeyringController['persistAllKeyrings'];\n};\n\nexport type KeyringControllerPrepareUserOperationAction = {\n  type: `${typeof name}:prepareUserOperation`;\n  handler: KeyringController['prepareUserOperation'];\n};\n\nexport type KeyringControllerPatchUserOperationAction = {\n  type: `${typeof name}:patchUserOperation`;\n  handler: KeyringController['patchUserOperation'];\n};\n\nexport type KeyringControllerSignUserOperationAction = {\n  type: `${typeof name}:signUserOperation`;\n  handler: KeyringController['signUserOperation'];\n};\n\nexport type KeyringControllerStateChangeEvent = {\n  type: `${typeof name}:stateChange`;\n  payload: [KeyringControllerState, Patch[]];\n};\n\nexport type KeyringControllerAccountRemovedEvent = {\n  type: `${typeof name}:accountRemoved`;\n  payload: [string];\n};\n\nexport type KeyringControllerLockEvent = {\n  type: `${typeof name}:lock`;\n  payload: [];\n};\n\nexport type KeyringControllerUnlockEvent = {\n  type: `${typeof name}:unlock`;\n  payload: [];\n};\n\nexport type KeyringControllerQRKeyringStateChangeEvent = {\n  type: `${typeof name}:qrKeyringStateChange`;\n  payload: [ReturnType<IQRKeyringState['getState']>];\n};\n\nexport type KeyringControllerActions =\n  | KeyringControllerGetStateAction\n  | KeyringControllerSignMessageAction\n  | KeyringControllerSignPersonalMessageAction\n  | KeyringControllerSignTypedMessageAction\n  | KeyringControllerDecryptMessageAction\n  | KeyringControllerGetEncryptionPublicKeyAction\n  | KeyringControllerGetAccountsAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetKeyringForAccountAction\n  | KeyringControllerPersistAllKeyringsAction\n  | KeyringControllerPrepareUserOperationAction\n  | KeyringControllerPatchUserOperationAction\n  | KeyringControllerSignUserOperationAction;\n\nexport type KeyringControllerEvents =\n  | KeyringControllerStateChangeEvent\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | KeyringControllerAccountRemovedEvent\n  | KeyringControllerQRKeyringStateChangeEvent;\n\nexport type KeyringControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  KeyringControllerActions,\n  KeyringControllerEvents,\n  never,\n  never\n>;\n\nexport type KeyringControllerOptions = {\n  keyringBuilders?: { (): EthKeyring<Json>; type: string }[];\n  messenger: KeyringControllerMessenger;\n  state?: { vault?: string };\n} & (\n  | {\n      cacheEncryptionKey: true;\n      encryptor?: ExportableKeyEncryptor;\n    }\n  | {\n      cacheEncryptionKey?: false;\n      encryptor?: GenericEncryptor | ExportableKeyEncryptor;\n    }\n);\n\n/**\n * @type KeyringObject\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n */\nexport type KeyringObject = {\n  accounts: string[];\n  type: string;\n};\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  privateKey = 'privateKey',\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * A serialized keyring object.\n */\nexport type SerializedKeyring = {\n  type: string;\n  data: Json;\n};\n\n/**\n * A generic encryptor interface that supports encrypting and decrypting\n * serializable data with a password.\n */\nexport type GenericEncryptor = {\n  /**\n   * Encrypts the given object with the given password.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encrypted string.\n   */\n  encrypt: (password: string, object: Json) => Promise<string>;\n  /**\n   * Decrypts the given encrypted string with the given password.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decrypt: (password: string, encryptedString: string) => Promise<unknown>;\n  /**\n   * Optional vault migration helper. Checks if the provided vault is up to date\n   * with the desired encryption algorithm.\n   *\n   * @param vault - The encrypted string to check.\n   * @param targetDerivationParams - The desired target derivation params.\n   * @returns The updated encrypted string.\n   */\n  isVaultUpdated?: (\n    vault: string,\n    targetDerivationParams?: encryptorUtils.KeyDerivationOptions,\n  ) => boolean;\n};\n\n/**\n * An encryptor interface that supports encrypting and decrypting\n * serializable data with a password, and exporting and importing keys.\n */\nexport type ExportableKeyEncryptor = GenericEncryptor & {\n  /**\n   * Encrypts the given object with the given encryption key.\n   *\n   * @param key - The encryption key to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encryption result.\n   */\n  encryptWithKey: (\n    key: unknown,\n    object: Json,\n  ) => Promise<encryptorUtils.EncryptionResult>;\n  /**\n   * Encrypts the given object with the given password, and returns the\n   * encryption result and the exported key string.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @param salt - The optional salt to use for encryption.\n   * @returns The encrypted string and the exported key string.\n   */\n  encryptWithDetail: (\n    password: string,\n    object: Json,\n    salt?: string,\n  ) => Promise<encryptorUtils.DetailedEncryptionResult>;\n  /**\n   * Decrypts the given encrypted string with the given encryption key.\n   *\n   * @param key - The encryption key to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decryptWithKey: (key: unknown, encryptedString: string) => Promise<unknown>;\n  /**\n   * Decrypts the given encrypted string with the given password, and returns\n   * the decrypted object and the salt and exported key string used for\n   * encryption.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object and the salt and exported key string used for\n   * encryption.\n   */\n  decryptWithDetail: (\n    password: string,\n    encryptedString: string,\n  ) => Promise<encryptorUtils.DetailedDecryptResult>;\n  /**\n   * Generates an encryption key from exported key string.\n   *\n   * @param key - The exported key string.\n   * @returns The encryption key.\n   */\n  importKey: (key: string) => Promise<unknown>;\n};\n\nexport type KeyringSelector =\n  | {\n      type: string;\n      index?: number;\n    }\n  | {\n      address: Hex;\n    };\n\n/**\n * A function executed within a mutually exclusive lock, with\n * a mutex releaser in its option bag.\n *\n * @param releaseLock - A function to release the lock.\n */\n// TODO: Either fix this lint violation or explain why it's necessary to ignore.\n// eslint-disable-next-line @typescript-eslint/naming-convention\ntype MutuallyExclusiveCallback<T> = ({\n  releaseLock,\n}: {\n  releaseLock: MutexInterface.Releaser;\n}) => Promise<T>;\n\n/**\n * Get builder function for `Keyring`\n *\n * Returns a builder function for `Keyring` with a `type` property.\n *\n * @param KeyringConstructor - The Keyring class for the builder.\n * @returns A builder function for the given Keyring.\n */\nexport function keyringBuilderFactory(KeyringConstructor: KeyringClass<Json>) {\n  const builder = () => new KeyringConstructor();\n\n  builder.type = KeyringConstructor.type;\n\n  return builder;\n}\n\nconst defaultKeyringBuilders = [\n  keyringBuilderFactory(SimpleKeyring),\n  keyringBuilderFactory(HDKeyring),\n];\n\nexport const getDefaultKeyringState = (): KeyringControllerState => {\n  return {\n    isUnlocked: false,\n    keyrings: [],\n  };\n};\n\n/**\n * Assert that the given keyring has an exportable\n * mnemonic.\n *\n * @param keyring - The keyring to check\n * @throws When the keyring does not have a mnemonic\n */\nfunction assertHasUint8ArrayMnemonic(\n  keyring: EthKeyring<Json>,\n): asserts keyring is EthKeyring<Json> & { mnemonic: Uint8Array } {\n  if (\n    !(\n      hasProperty(keyring, 'mnemonic') && keyring.mnemonic instanceof Uint8Array\n    )\n  ) {\n    throw new Error(\"Can't get mnemonic bytes from keyring\");\n  }\n}\n\n/**\n * Assert that the provided encryptor supports\n * encryption and encryption key export.\n *\n * @param encryptor - The encryptor to check.\n * @throws If the encryptor does not support key encryption.\n */\nfunction assertIsExportableKeyEncryptor(\n  encryptor: GenericEncryptor | ExportableKeyEncryptor,\n): asserts encryptor is ExportableKeyEncryptor {\n  if (\n    !(\n      'importKey' in encryptor &&\n      typeof encryptor.importKey === 'function' &&\n      'decryptWithKey' in encryptor &&\n      typeof encryptor.decryptWithKey === 'function' &&\n      'encryptWithKey' in encryptor &&\n      typeof encryptor.encryptWithKey === 'function'\n    )\n  ) {\n    throw new Error(KeyringControllerError.UnsupportedEncryptionKeyExport);\n  }\n}\n\n/**\n * Assert that the provided password is a valid non-empty string.\n *\n * @param password - The password to check.\n * @throws If the password is not a valid string.\n */\nfunction assertIsValidPassword(password: unknown): asserts password is string {\n  if (typeof password !== 'string') {\n    throw new Error(KeyringControllerError.WrongPasswordType);\n  }\n\n  if (!password || !password.length) {\n    throw new Error(KeyringControllerError.InvalidEmptyPassword);\n  }\n}\n\n/**\n * Checks if the provided value is a serialized keyrings array.\n *\n * @param array - The value to check.\n * @returns True if the value is a serialized keyrings array.\n */\nfunction isSerializedKeyringsArray(\n  array: unknown,\n): array is SerializedKeyring[] {\n  return (\n    typeof array === 'object' &&\n    Array.isArray(array) &&\n    array.every((value) => value.type && isValidJson(value.data))\n  );\n}\n\n/**\n * Display For Keyring\n *\n * Is used for adding the current keyrings to the state object.\n *\n * @param keyring - The keyring to display.\n * @returns A keyring display object, with type and accounts properties.\n */\nasync function displayForKeyring(\n  keyring: EthKeyring<Json>,\n): Promise<{ type: string; accounts: string[] }> {\n  const accounts = await keyring.getAccounts();\n\n  return {\n    type: keyring.type,\n    // Cast to `string[]` here is safe here because `accounts` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    accounts: accounts.map(normalize) as string[],\n  };\n}\n\n/**\n * Check if address is an ethereum address\n *\n * @param address - An address.\n * @returns Returns true if the address is an ethereum one, false otherwise.\n */\nfunction isEthAddress(address: string): boolean {\n  // We first check if it's a matching `Hex` string, so that is narrows down\n  // `address` as an `Hex` type, allowing us to use `isValidHexAddress`\n  return (\n    // NOTE: This function only checks for lowercased strings\n    isStrictHexString(address.toLowerCase()) &&\n    // This checks for lowercased addresses and checksum addresses too\n    isValidHexAddress(address as Hex)\n  );\n}\n\n/**\n * Normalize ethereum or non-EVM address.\n *\n * @param address - Ethereum or non-EVM address.\n * @returns The normalized address.\n */\nfunction normalize(address: string): string | undefined {\n  // Since the `KeyringController` is only dealing with address, we have\n  // no other way to get the associated account type with this address. So we\n  // are down to check the actual address format for now\n  // TODO: Find a better way to not have those runtime checks based on the\n  //       address value!\n  return isEthAddress(address) ? ethNormalize(address) : address;\n}\n\n/**\n * Controller responsible for establishing and managing user identity.\n *\n * This class is a wrapper around the `eth-keyring-controller` package. The\n * `eth-keyring-controller` manages the \"vault\", which is an encrypted store of private keys, and\n * it manages the wallet \"lock\" state. This wrapper class has convenience methods for interacting\n * with the internal keyring controller and handling certain complex operations that involve the\n * keyrings.\n */\nexport class KeyringController extends BaseController<\n  typeof name,\n  KeyringControllerState,\n  KeyringControllerMessenger\n> {\n  readonly #controllerOperationMutex = new Mutex();\n\n  readonly #vaultOperationMutex = new Mutex();\n\n  #keyringBuilders: { (): EthKeyring<Json>; type: string }[];\n\n  #keyrings: EthKeyring<Json>[];\n\n  #unsupportedKeyrings: SerializedKeyring[];\n\n  #password?: string;\n\n  #encryptor: GenericEncryptor | ExportableKeyEncryptor;\n\n  #cacheEncryptionKey: boolean;\n\n  #qrKeyringStateListener?: (\n    state: ReturnType<IQRKeyringState['getState']>,\n  ) => void;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - Initial options used to configure this controller\n   * @param options.encryptor - An optional object for defining encryption schemes.\n   * @param options.keyringBuilders - Set a new name for account.\n   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor(options: KeyringControllerOptions) {\n    const {\n      encryptor = encryptorUtils,\n      keyringBuilders,\n      messenger,\n      state,\n    } = options;\n\n    super({\n      name,\n      metadata: {\n        vault: { persist: true, anonymous: false },\n        isUnlocked: { persist: false, anonymous: true },\n        keyrings: { persist: false, anonymous: false },\n        encryptionKey: { persist: false, anonymous: false },\n        encryptionSalt: { persist: false, anonymous: false },\n      },\n      messenger,\n      state: {\n        ...getDefaultKeyringState(),\n        ...state,\n      },\n    });\n\n    this.#keyringBuilders = keyringBuilders\n      ? keyringBuilders.concat(defaultKeyringBuilders)\n      : defaultKeyringBuilders;\n\n    this.#encryptor = encryptor;\n    this.#keyrings = [];\n    this.#unsupportedKeyrings = [];\n\n    // This option allows the controller to cache an exported key\n    // for use in decrypting and encrypting data without password\n    this.#cacheEncryptionKey = Boolean(options.cacheEncryptionKey);\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(encryptor);\n    }\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @param accountCount - Number of accounts before adding a new one, used to\n   * make the method idempotent.\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccount(accountCount?: number): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const oldAccounts = await primaryKeyring.getAccounts();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n        // we return the account already existing at index `accountCount`\n        const existingAccount = oldAccounts[accountCount];\n\n        if (!existingAccount) {\n          throw new Error(`Can't find account at index ${accountCount}`);\n        }\n\n        return existingAccount;\n      }\n\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the specified keyring.\n   *\n   * @param keyring - Keyring to add the account to.\n   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.\n   * @returns Promise resolving to the added account address\n   */\n  async addNewAccountForKeyring(\n    keyring: EthKeyring<Json>,\n    accountCount?: number,\n  ): Promise<Hex> {\n    // READ THIS CAREFULLY:\n    // We still uses `Hex` here, since we are not using this method when creating\n    // and account using a \"Snap Keyring\". This function assume the `keyring` is\n    // ethereum compatible, but \"Snap Keyring\" might not be.\n    return this.#persistOrRollback(async () => {\n      const oldAccounts = await this.#getAccountsFromKeyrings();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n\n        const existingAccount = oldAccounts[accountCount];\n        assertIsStrictHexString(existingAccount);\n\n        return existingAccount;\n      }\n\n      await keyring.addAccounts(1);\n\n      const addedAccountAddress = (await this.#getAccountsFromKeyrings()).find(\n        (selectedAddress) => !oldAccounts.includes(selectedAddress),\n      );\n      assertIsStrictHexString(addedAccountAddress);\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccountWithoutUpdate(): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase as Uint8Array,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seed: Uint8Array,\n  ): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      assertIsValidPassword(password);\n\n      await this.#createNewVaultWithKeyring(password, {\n        type: KeyringTypes.hd,\n        opts: {\n          mnemonic: seed,\n          numberOfAccounts: 1,\n        },\n      });\n    });\n  }\n\n  /**\n   * Create a new vault and primary keyring.\n   *\n   * This only works if keyrings are empty. If there is a pre-existing unlocked vault, calling this will have no effect.\n   * If there is a pre-existing locked vault, it will be replaced.\n   *\n   * @param password - Password to unlock the new vault.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    return this.#persistOrRollback(async () => {\n      const accounts = await this.#getAccountsFromKeyrings();\n      if (!accounts.length) {\n        await this.#createNewVaultWithKeyring(password, {\n          type: KeyringTypes.hd,\n        });\n      }\n    });\n  }\n\n  /**\n   * Adds a new keyring of the given `type`.\n   *\n   * @param type - Keyring type name.\n   * @param opts - Keyring options.\n   * @throws If a builder for the given `type` does not exist.\n   * @returns Promise resolving to the added keyring.\n   */\n  async addNewKeyring(\n    type: KeyringTypes | string,\n    opts?: unknown,\n  ): Promise<unknown> {\n    if (type === KeyringTypes.qr) {\n      return this.getOrAddQRKeyring();\n    }\n\n    return this.#persistOrRollback(async () => this.#newKeyring(type, opts));\n  }\n\n  /**\n   * Method to verify a given password validity. Throws an\n   * error if the password is invalid.\n   *\n   * @param password - Password of the keyring.\n   */\n  async verifyPassword(password: string) {\n    if (!this.state.vault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n    await this.#encryptor.decrypt(password, this.state.vault);\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.state.isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  async exportSeedPhrase(password: string): Promise<Uint8Array> {\n    await this.verifyPassword(password);\n    assertHasUint8ArrayMnemonic(this.#keyrings[0]);\n    return this.#keyrings[0].mnemonic;\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  async exportAccount(password: string, address: string): Promise<string> {\n    await this.verifyPassword(password);\n\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAccount);\n    }\n\n    return await keyring.exportAccount(normalize(address) as Hex);\n  }\n\n  /**\n   * Returns the public addresses of all accounts from every keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  async getAccounts(): Promise<string[]> {\n    return this.state.keyrings.reduce<string[]>(\n      (accounts, keyring) => accounts.concat(keyring.accounts),\n      [],\n    );\n  }\n\n  /**\n   * Get encryption public key.\n   *\n   * @param account - An account address.\n   * @param opts - Additional encryption options.\n   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method\n   * @returns Promise resolving to encyption public key of the `account` if one exists.\n   */\n  async getEncryptionPublicKey(\n    account: string,\n    opts?: Record<string, unknown>,\n  ): Promise<string> {\n    const address = ethNormalize(account) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    if (!keyring.getEncryptionPublicKey) {\n      throw new Error(KeyringControllerError.UnsupportedGetEncryptionPublicKey);\n    }\n\n    return await keyring.getEncryptionPublicKey(address, opts);\n  }\n\n  /**\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param messageParams - The decryption message parameters.\n   * @param messageParams.from - The address of the account you want to use to decrypt the message.\n   * @param messageParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(messageParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<string> {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.decryptMessage) {\n      throw new Error(KeyringControllerError.UnsupportedDecryptMessage);\n    }\n\n    return keyring.decryptMessage(address, messageParams.data);\n  }\n\n  /**\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param account - An account address.\n   * @returns Promise resolving to keyring of the `account` if one exists.\n   */\n  async getKeyringForAccount(account: string): Promise<unknown> {\n    const address = normalize(account);\n\n    const candidates = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        return Promise.all([keyring, keyring.getAccounts()]);\n      }),\n    );\n\n    const winners = candidates.filter((candidate) => {\n      const accounts = candidate[1].map(normalize);\n      return accounts.includes(address);\n    });\n\n    if (winners.length && winners[0]?.length) {\n      return winners[0][0];\n    }\n\n    // Adding more info to the error\n    let errorInfo = '';\n    if (!candidates.length) {\n      errorInfo = 'There are no keyrings';\n    } else if (!winners.length) {\n      errorInfo = 'There are keyrings, but none match the address';\n    }\n    throw new Error(\n      `${KeyringControllerError.NoKeyring}. Error info: ${errorInfo}`,\n    );\n  }\n\n  /**\n   * Returns all keyrings of the given type.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param type - Keyring type name.\n   * @returns An array of keyrings of the given type.\n   */\n  getKeyringsByType(type: KeyringTypes | string): unknown[] {\n    return this.#keyrings.filter((keyring) => keyring.type === type);\n  }\n\n  /**\n   * Persist all serialized keyrings in the vault.\n   *\n   * @deprecated This method is being phased out in favor of `withKeyring`.\n   * @returns Promise resolving with `true` value when the\n   * operation completes.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    return this.#persistOrRollback(async () => true);\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to the imported account address.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any[],\n  ): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      let privateKey;\n      switch (strategy) {\n        case 'privateKey':\n          const [importedKey] = args;\n          if (!importedKey) {\n            throw new Error('Cannot import an empty key.');\n          }\n          const prefixed = add0x(importedKey);\n\n          let bufferedPrivateKey;\n          try {\n            bufferedPrivateKey = toBuffer(prefixed);\n          } catch {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          if (\n            !isValidPrivate(bufferedPrivateKey) ||\n            // ensures that the key is 64 bytes long\n            getBinarySize(prefixed) !== 64 + '0x'.length\n          ) {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          privateKey = remove0x(prefixed);\n          break;\n        case 'json':\n          let wallet;\n          const [input, password] = args;\n          try {\n            wallet = importers.fromEtherWallet(input, password);\n          } catch (e) {\n            wallet = wallet || (await Wallet.fromV3(input, password, true));\n          }\n          privateKey = bytesToHex(wallet.getPrivateKey());\n          break;\n        default:\n          throw new Error(`Unexpected import strategy: '${strategy}'`);\n      }\n      const newKeyring = (await this.#newKeyring(KeyringTypes.simple, [\n        privateKey,\n      ])) as EthKeyring<Json>;\n      const accounts = await newKeyring.getAccounts();\n      return accounts[0];\n    });\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @fires KeyringController:accountRemoved\n   * @returns Promise resolving when the account is removed.\n   */\n  async removeAccount(address: string): Promise<void> {\n    await this.#persistOrRollback(async () => {\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n\n      // Not all the keyrings support this, so we have to check\n      if (!keyring.removeAccount) {\n        throw new Error(KeyringControllerError.UnsupportedRemoveAccount);\n      }\n\n      // The `removeAccount` method of snaps keyring is async. We have to update\n      // the interface of the other keyrings to be async as well.\n      // eslint-disable-next-line @typescript-eslint/await-thenable\n      // FIXME: We do cast to `Hex` to makes the type checker happy here, and\n      // because `Keyring<State>.removeAccount` requires address to be `Hex`. Those\n      // type would need to be updated for a full non-EVM support.\n      keyring.removeAccount(address as Hex);\n\n      const accounts = await keyring.getAccounts();\n      // Check if this was the last/only account\n      if (accounts.length === 0) {\n        await this.#removeEmptyKeyrings();\n      }\n    });\n\n    this.messagingSystem.publish(`${name}:accountRemoved`, address);\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving when the operation completes.\n   */\n  async setLocked(): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#unsubscribeFromQRKeyringsEvents();\n\n      this.#password = undefined;\n      await this.#clearKeyrings();\n\n      this.update((state) => {\n        state.isUnlocked = false;\n        state.keyrings = [];\n        delete state.encryptionKey;\n        delete state.encryptionSalt;\n      });\n\n      this.messagingSystem.publish(`${name}:lock`);\n    });\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signMessage(messageParams: PersonalMessageParams): Promise<string> {\n    if (!messageParams.data) {\n      throw new Error(\"Can't sign an empty message\");\n    }\n\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignMessage);\n    }\n\n    return await keyring.signMessage(address, messageParams.data);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signPersonalMessage(messageParams: PersonalMessageParams) {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signPersonalMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignPersonalMessage);\n    }\n\n    const normalizedData = normalize(messageParams.data) as Hex;\n\n    return await keyring.signPersonalMessage(address, normalizedData);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ): Promise<string> {\n    try {\n      if (\n        ![\n          SignTypedDataVersion.V1,\n          SignTypedDataVersion.V3,\n          SignTypedDataVersion.V4,\n        ].includes(version)\n      ) {\n        throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n\n      // Cast to `Hex` here is safe here because `messageParams.from` is not nullish.\n      // `normalize` returns `Hex` unless given a nullish value.\n      const address = ethNormalize(messageParams.from) as Hex;\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n      if (!keyring.signTypedData) {\n        throw new Error(KeyringControllerError.UnsupportedSignTypedMessage);\n      }\n\n      return await keyring.signTypedData(\n        address,\n        version !== SignTypedDataVersion.V1 &&\n          typeof messageParams.data === 'string'\n          ? JSON.parse(messageParams.data)\n          : messageParams.data,\n        { version },\n      );\n    } catch (error) {\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @param opts - An optional options object.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  async signTransaction(\n    transaction: TypedTransaction,\n    from: string,\n    opts?: Record<string, unknown>,\n  ): Promise<TxData> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signTransaction) {\n      throw new Error(KeyringControllerError.UnsupportedSignTransaction);\n    }\n\n    return await keyring.signTransaction(address, transaction, opts);\n  }\n\n  /**\n   * Convert a base transaction to a base UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param transactions - Base transactions to include in the UserOperation.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A pseudo-UserOperation that can be used to construct a real.\n   */\n  async prepareUserOperation(\n    from: string,\n    transactions: EthBaseTransaction[],\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthBaseUserOperation> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.prepareUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPrepareUserOperation);\n    }\n\n    return await keyring.prepareUserOperation(\n      address,\n      transactions,\n      executionContext,\n    );\n  }\n\n  /**\n   * Patches properties of a UserOperation. Currently, only the\n   * `paymasterAndData` can be patched.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to patch.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A patch to apply to the UserOperation.\n   */\n  async patchUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthUserOperationPatch> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.patchUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPatchUserOperation);\n    }\n\n    return await keyring.patchUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Signs an UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to sign.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns The signature of the UserOperation.\n   */\n  async signUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<string> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.signUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedSignUserOperation);\n    }\n\n    return await keyring.signUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Changes the password used to encrypt the vault.\n   *\n   * @param password - The new password.\n   * @returns Promise resolving when the operation completes.\n   */\n  changePassword(password: string): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      if (!this.state.isUnlocked) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      assertIsValidPassword(password);\n\n      this.#password = password;\n      // We need to clear encryption key and salt from state\n      // to force the controller to re-encrypt the vault using\n      // the new password.\n      if (this.#cacheEncryptionKey) {\n        this.update((state) => {\n          delete state.encryptionKey;\n          delete state.encryptionSalt;\n        });\n      }\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given encryption key and salt.\n   *\n   * @param encryptionKey - Key to unlock the keychain.\n   * @param encryptionSalt - Salt to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt: string,\n  ): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(\n        undefined,\n        encryptionKey,\n        encryptionSalt,\n      );\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given password.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitPassword(password: string): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(password);\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Promise resolving to the seed phrase as Uint8Array.\n   */\n  async verifySeedPhrase(): Promise<Uint8Array> {\n    const primaryKeyring = this.getKeyringsByType(KeyringTypes.hd)[0] as\n      | EthKeyring<Json>\n      | undefined;\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    assertHasUint8ArrayMnemonic(primaryKeyring);\n\n    const seedWords = primaryKeyring.mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    // The HD Keyring Builder is a default keyring builder\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const hdKeyringBuilder = this.#getKeyringBuilderForType(KeyringTypes.hd)!;\n\n    const hdKeyring = hdKeyringBuilder();\n    // @ts-expect-error @metamask/eth-hd-keyring correctly handles\n    // Uint8Array seed phrases in the `deserialize` method.\n    await hdKeyring.deserialize({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await hdKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @param options - Additional options.\n   * @param options.createIfMissing - Whether to create a new keyring if the selected one is missing.\n   * @param options.createWithData - Optional data to use when creating a new keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   * @deprecated This method overload is deprecated. Use `withKeyring` without options instead.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown },\n  ): Promise<CallbackResult>;\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n  ): Promise<CallbackResult>;\n\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown } = {\n      createIfMissing: false,\n    },\n  ): Promise<CallbackResult> {\n    return this.#persistOrRollback(async () => {\n      let keyring: SelectedKeyring | undefined;\n\n      if ('address' in selector) {\n        keyring = (await this.getKeyringForAccount(selector.address)) as\n          | SelectedKeyring\n          | undefined;\n      } else {\n        keyring = this.getKeyringsByType(selector.type)[selector.index || 0] as\n          | SelectedKeyring\n          | undefined;\n\n        if (!keyring && options.createIfMissing) {\n          keyring = (await this.#newKeyring(\n            selector.type,\n            options.createWithData,\n          )) as SelectedKeyring;\n        }\n      }\n\n      if (!keyring) {\n        throw new Error(KeyringControllerError.KeyringNotFound);\n      }\n\n      const result = await operation(keyring);\n\n      if (Object.is(result, keyring)) {\n        // Access to a keyring instance outside of controller safeguards\n        // should be discouraged, as it can lead to unexpected behavior.\n        // This error is thrown to prevent consumers using `withKeyring`\n        // as a way to get a reference to a keyring instance.\n        throw new Error(KeyringControllerError.UnsafeDirectKeyringAccess);\n      }\n\n      return result;\n    });\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Get QR Hardware keyring.\n   *\n   * @returns The QR Keyring if defined, otherwise undefined\n   * @deprecated Use `withKeyring` instead.\n   */\n  getQRKeyring(): QRKeyring | undefined {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return this.getKeyringsByType(KeyringTypes.qr)[0] as unknown as QRKeyring;\n  }\n\n  /**\n   * Get QR hardware keyring. If it doesn't exist, add it.\n   *\n   * @returns The added keyring\n   * @deprecated Use `addNewKeyring` and `withKeyring` instead.\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    return (\n      this.getQRKeyring() ||\n      (await this.#persistOrRollback(async () => this.#addQRKeyring()))\n    );\n  }\n\n  /**\n   * Restore QR keyring from serialized data.\n   *\n   * @param serialized - Serialized data to restore the keyring from.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n      keyring.deserialize(serialized);\n    });\n  }\n\n  /**\n   * Reset QR keyring state.\n   *\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  /**\n   * Get QR keyring state.\n   *\n   * @returns Promise resolving to the keyring state.\n   * @deprecated Use `withKeyring` or subscribe to `\"KeyringController:qrKeyringStateChange\"`\n   * instead.\n   */\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  /**\n   * Submit QR hardware wallet public HDKey.\n   *\n   * @param cryptoHDKey - The key to submit.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  /**\n   * Submit QR hardware wallet account.\n   *\n   * @param cryptoAccount - The account to submit.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  /**\n   * Submit QR hardware wallet signature.\n   *\n   * @param requestId - The request ID.\n   * @param ethSignature - The signature to submit.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  /**\n   * Cancel QR sign request.\n   *\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  /**\n   * Cancels qr keyring sync.\n   *\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async cancelQRSynchronization(): Promise<void> {\n    // eslint-disable-next-line n/no-sync\n    (await this.getOrAddQRKeyring()).cancelSync();\n  }\n\n  /**\n   * Connect to QR hardware wallet.\n   *\n   * @param page - The page to connect to.\n   * @returns Promise resolving to the connected accounts.\n   * @deprecated Use of this method is discouraged as it creates a dangling promise\n   * internal to the `QRKeyring`, which can lead to unpredictable deadlocks. Please use\n   * `withKeyring` instead.\n   */\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    return this.#persistOrRollback(async () => {\n      try {\n        const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n        let accounts;\n        switch (page) {\n          case -1:\n            accounts = await keyring.getPreviousPage();\n            break;\n          case 1:\n            accounts = await keyring.getNextPage();\n            break;\n          default:\n            accounts = await keyring.getFirstPage();\n        }\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return accounts.map((account: any) => {\n          return {\n            ...account,\n            balance: '0x0',\n          };\n        });\n      } catch (e) {\n        // TODO: Add test case for when keyring throws\n        /* istanbul ignore next */\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n      }\n    });\n  }\n\n  /**\n   * Unlock a QR hardware wallet account.\n   *\n   * @param index - The index of the account to unlock.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n\n      keyring.setAccountToUnlock(index);\n      await keyring.addAccounts(1);\n    });\n  }\n\n  async getAccountKeyringType(account: string): Promise<string> {\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    return keyring.type;\n  }\n\n  /**\n   * Forget the QR hardware wallet.\n   *\n   * @returns Promise resolving to the removed accounts and the remaining accounts.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async forgetQRDevice(): Promise<{\n    removedAccounts: string[];\n    remainingAccounts: string[];\n  }> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring();\n\n      if (!keyring) {\n        return { removedAccounts: [], remainingAccounts: [] };\n      }\n\n      const allAccounts = (await this.#getAccountsFromKeyrings()) as string[];\n      keyring.forgetDevice();\n      const remainingAccounts =\n        (await this.#getAccountsFromKeyrings()) as string[];\n      const removedAccounts = allAccounts.filter(\n        (address: string) => !remainingAccounts.includes(address),\n      );\n      return { removedAccounts, remainingAccounts };\n    });\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${name}:signMessage`,\n      this.signMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signPersonalMessage`,\n      this.signPersonalMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signTypedMessage`,\n      this.signTypedMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:decryptMessage`,\n      this.decryptMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getEncryptionPublicKey`,\n      this.getEncryptionPublicKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getAccounts`,\n      this.getAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringsByType`,\n      this.getKeyringsByType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringForAccount`,\n      this.getKeyringForAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:persistAllKeyrings`,\n      this.persistAllKeyrings.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:prepareUserOperation`,\n      this.prepareUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:patchUserOperation`,\n      this.patchUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signUserOperation`,\n      this.signUserOperation.bind(this),\n    );\n  }\n\n  /**\n   * Get the keyring builder for the given `type`.\n   *\n   * @param type - The type of keyring to get the builder for.\n   * @returns The keyring builder, or undefined if none exists.\n   */\n  #getKeyringBuilderForType(\n    type: string,\n  ): { (): EthKeyring<Json>; type: string } | undefined {\n    return this.#keyringBuilders.find(\n      (keyringBuilder) => keyringBuilder.type === type,\n    );\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   * @throws If a QRKeyring builder is not provided\n   * when initializing the controller\n   */\n  async #addQRKeyring(): Promise<QRKeyring> {\n    this.#assertControllerMutexIsLocked();\n\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return (await this.#newKeyring(KeyringTypes.qr)) as unknown as QRKeyring;\n  }\n\n  /**\n   * Subscribe to a QRKeyring state change events and\n   * forward them through the messaging system.\n   *\n   * @param qrKeyring - The QRKeyring instance to subscribe to\n   */\n  #subscribeToQRKeyringEvents(qrKeyring: QRKeyring) {\n    this.#qrKeyringStateListener = (state) => {\n      this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);\n    };\n\n    qrKeyring.getMemStore().subscribe(this.#qrKeyringStateListener);\n  }\n\n  #unsubscribeFromQRKeyringsEvents() {\n    const qrKeyrings = this.getKeyringsByType(\n      KeyringTypes.qr,\n    ) as unknown as QRKeyring[];\n\n    qrKeyrings.forEach((qrKeyring) => {\n      if (this.#qrKeyringStateListener) {\n        qrKeyring.getMemStore().unsubscribe(this.#qrKeyringStateListener);\n      }\n    });\n  }\n\n  /**\n   * Create new vault with an initial keyring\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * creates a new wallet with 1 account.\n   *\n   * @fires KeyringController:unlock\n   * @param password - The password to encrypt the vault with.\n   * @param keyring - A object containing the params to instantiate a new keyring.\n   * @param keyring.type - The keyring type.\n   * @param keyring.opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves to the state.\n   */\n  async #createNewVaultWithKeyring(\n    password: string,\n    keyring: {\n      type: string;\n      opts?: unknown;\n    },\n  ): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n\n    if (typeof password !== 'string') {\n      throw new TypeError(KeyringControllerError.WrongPasswordType);\n    }\n\n    this.update((state) => {\n      delete state.encryptionKey;\n      delete state.encryptionSalt;\n    });\n\n    this.#password = password;\n\n    await this.#clearKeyrings();\n    await this.#createKeyringWithFirstAccount(keyring.type, keyring.opts);\n    this.#setUnlocked();\n  }\n\n  /**\n   * Get the updated array of each keyring's type and\n   * accounts list.\n   *\n   * @returns A promise resolving to the updated keyrings array.\n   */\n  async #getUpdatedKeyrings(): Promise<KeyringObject[]> {\n    return Promise.all(this.#keyrings.map(displayForKeyring));\n  }\n\n  /**\n   * Serialize the current array of keyring instances,\n   * including unsupported keyrings by default.\n   *\n   * @param options - Method options.\n   * @param options.includeUnsupported - Whether to include unsupported keyrings.\n   * @returns The serialized keyrings.\n   */\n  async #getSerializedKeyrings(\n    { includeUnsupported }: { includeUnsupported: boolean } = {\n      includeUnsupported: true,\n    },\n  ): Promise<SerializedKeyring[]> {\n    const serializedKeyrings = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        const [type, data] = await Promise.all([\n          keyring.type,\n          keyring.serialize(),\n        ]);\n        return { type, data };\n      }),\n    );\n\n    if (includeUnsupported) {\n      serializedKeyrings.push(...this.#unsupportedKeyrings);\n    }\n\n    return serializedKeyrings;\n  }\n\n  /**\n   * Restore a serialized keyrings array.\n   *\n   * @param serializedKeyrings - The serialized keyrings array.\n   */\n  async #restoreSerializedKeyrings(\n    serializedKeyrings: SerializedKeyring[],\n  ): Promise<void> {\n    await this.#clearKeyrings();\n\n    for (const serializedKeyring of serializedKeyrings) {\n      await this.#restoreKeyring(serializedKeyring);\n    }\n  }\n\n  /**\n   * Unlock Keyrings, decrypting the vault and deserializing all\n   * keyrings contained in it, using a password or an encryption key with salt.\n   *\n   * @param password - The keyring controller password.\n   * @param encryptionKey - An exported key string to unlock keyrings with.\n   * @param encryptionSalt - The salt used to encrypt the vault.\n   * @returns A promise resolving to the deserialized keyrings array.\n   */\n  async #unlockKeyrings(\n    password: string | undefined,\n    encryptionKey?: string,\n    encryptionSalt?: string,\n  ): Promise<EthKeyring<Json>[]> {\n    return this.#withVaultLock(async ({ releaseLock }) => {\n      const encryptedVault = this.state.vault;\n      if (!encryptedVault) {\n        throw new Error(KeyringControllerError.VaultError);\n      }\n\n      let vault;\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (password) {\n          const result = await this.#encryptor.decryptWithDetail(\n            password,\n            encryptedVault,\n          );\n          vault = result.vault;\n          this.#password = password;\n\n          updatedState.encryptionKey = result.exportedKeyString;\n          updatedState.encryptionSalt = result.salt;\n        } else {\n          const parsedEncryptedVault = JSON.parse(encryptedVault);\n\n          if (encryptionSalt !== parsedEncryptedVault.salt) {\n            throw new Error(KeyringControllerError.ExpiredCredentials);\n          }\n\n          if (typeof encryptionKey !== 'string') {\n            throw new TypeError(KeyringControllerError.WrongPasswordType);\n          }\n\n          const key = await this.#encryptor.importKey(encryptionKey);\n          vault = await this.#encryptor.decryptWithKey(\n            key,\n            parsedEncryptedVault,\n          );\n\n          // This call is required on the first call because encryptionKey\n          // is not yet inside the memStore\n          updatedState.encryptionKey = encryptionKey;\n          // we can safely assume that encryptionSalt is defined here\n          // because we compare it with the salt from the vault\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          updatedState.encryptionSalt = encryptionSalt!;\n        }\n      } else {\n        if (typeof password !== 'string') {\n          throw new TypeError(KeyringControllerError.WrongPasswordType);\n        }\n\n        vault = await this.#encryptor.decrypt(password, encryptedVault);\n        this.#password = password;\n      }\n\n      if (!isSerializedKeyringsArray(vault)) {\n        throw new Error(KeyringControllerError.VaultDataError);\n      }\n\n      await this.#restoreSerializedKeyrings(vault);\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n\n      this.update((state) => {\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey || updatedState.encryptionSalt) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = updatedState.encryptionSalt;\n        }\n      });\n\n      if (\n        this.#password &&\n        (!this.#cacheEncryptionKey || !encryptionKey) &&\n        this.#encryptor.isVaultUpdated &&\n        !this.#encryptor.isVaultUpdated(encryptedVault)\n      ) {\n        // The lock needs to be released before persisting the keyrings\n        // to avoid deadlock\n        releaseLock();\n        // Re-encrypt the vault with safer method if one is available\n        await this.#updateVault();\n      }\n\n      return this.#keyrings;\n    });\n  }\n\n  /**\n   * Update the vault with the current keyrings.\n   *\n   * @returns A promise resolving to `true` if the operation is successful.\n   */\n  #updateVault(): Promise<boolean> {\n    return this.#withVaultLock(async () => {\n      const { encryptionKey, encryptionSalt } = this.state;\n\n      if (!this.#password && !encryptionKey) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      const serializedKeyrings = await this.#getSerializedKeyrings();\n\n      if (\n        !serializedKeyrings.some((keyring) => keyring.type === KeyringTypes.hd)\n      ) {\n        throw new Error(KeyringControllerError.NoHdKeyring);\n      }\n\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (encryptionKey) {\n          const key = await this.#encryptor.importKey(encryptionKey);\n          const vaultJSON = await this.#encryptor.encryptWithKey(\n            key,\n            serializedKeyrings,\n          );\n          vaultJSON.salt = encryptionSalt;\n          updatedState.vault = JSON.stringify(vaultJSON);\n        } else if (this.#password) {\n          const { vault: newVault, exportedKeyString } =\n            await this.#encryptor.encryptWithDetail(\n              this.#password,\n              serializedKeyrings,\n            );\n\n          updatedState.vault = newVault;\n          updatedState.encryptionKey = exportedKeyString;\n        }\n      } else {\n        assertIsValidPassword(this.#password);\n        updatedState.vault = await this.#encryptor.encrypt(\n          this.#password,\n          serializedKeyrings,\n        );\n      }\n\n      if (!updatedState.vault) {\n        throw new Error(KeyringControllerError.MissingVaultData);\n      }\n\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n      this.update((state) => {\n        state.vault = updatedState.vault;\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = JSON.parse(updatedState.vault as string).salt;\n        }\n      });\n\n      return true;\n    });\n  }\n\n  /**\n   * Retrieves all the accounts from keyrings instances\n   * that are currently in memory.\n   *\n   * @returns A promise resolving to an array of accounts.\n   */\n  async #getAccountsFromKeyrings(): Promise<string[]> {\n    const keyrings = this.#keyrings;\n\n    const keyringArrays = await Promise.all(\n      keyrings.map(async (keyring) => keyring.getAccounts()),\n    );\n    const addresses = keyringArrays.reduce((res, arr) => {\n      return res.concat(arr);\n    }, []);\n\n    // Cast to `string[]` here is safe here because `addresses` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    return addresses.map(normalize) as string[];\n  }\n\n  /**\n   * Create a new keyring, ensuring that the first account is\n   * also created.\n   *\n   * @param type - Keyring type to instantiate.\n   * @param opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves if the operation is successful.\n   */\n  async #createKeyringWithFirstAccount(type: string, opts?: unknown) {\n    this.#assertControllerMutexIsLocked();\n\n    const keyring = (await this.#newKeyring(type, opts)) as EthKeyring<Json>;\n\n    const [firstAccount] = await keyring.getAccounts();\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoFirstAccount);\n    }\n  }\n\n  /**\n   * Instantiate, initialize and return a new keyring of the given `type`,\n   * using the given `opts`. The keyring is built using the keyring builder\n   * registered for the given `type`.\n   *\n   *\n   * @param type - The type of keyring to add.\n   * @param data - The data to restore a previously serialized keyring.\n   * @returns The new keyring.\n   * @throws If the keyring includes duplicated accounts.\n   */\n  async #newKeyring(type: string, data?: unknown): Promise<EthKeyring<Json>> {\n    this.#assertControllerMutexIsLocked();\n\n    const keyringBuilder = this.#getKeyringBuilderForType(type);\n\n    if (!keyringBuilder) {\n      throw new Error(\n        `${KeyringControllerError.NoKeyringBuilder}. Keyring type: ${type}`,\n      );\n    }\n\n    const keyring = keyringBuilder();\n\n    // @ts-expect-error Enforce data type after updating clients\n    await keyring.deserialize(data);\n\n    if (keyring.init) {\n      await keyring.init();\n    }\n\n    if (type === KeyringTypes.hd && (!isObject(data) || !data.mnemonic)) {\n      if (!keyring.generateRandomMnemonic) {\n        throw new Error(\n          KeyringControllerError.UnsupportedGenerateRandomMnemonic,\n        );\n      }\n\n      keyring.generateRandomMnemonic();\n      await keyring.addAccounts(1);\n    }\n\n    await this.#checkForDuplicate(type, await keyring.getAccounts());\n\n    if (type === KeyringTypes.qr) {\n      // In case of a QR keyring type, we need to subscribe\n      // to its events after creating it\n      this.#subscribeToQRKeyringEvents(keyring as unknown as QRKeyring);\n    }\n\n    this.#keyrings.push(keyring);\n\n    return keyring;\n  }\n\n  /**\n   * Remove all managed keyrings, destroying all their\n   * instances in memory.\n   */\n  async #clearKeyrings() {\n    this.#assertControllerMutexIsLocked();\n    for (const keyring of this.#keyrings) {\n      await this.#destroyKeyring(keyring);\n    }\n    this.#keyrings = [];\n  }\n\n  /**\n   * Restore a Keyring from a provided serialized payload.\n   * On success, returns the resulting keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @returns The deserialized keyring or undefined if the keyring type is unsupported.\n   */\n  async #restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<EthKeyring<Json> | undefined> {\n    this.#assertControllerMutexIsLocked();\n\n    try {\n      const { type, data } = serialized;\n      return await this.#newKeyring(type, data);\n    } catch (_) {\n      this.#unsupportedKeyrings.push(serialized);\n      return undefined;\n    }\n  }\n\n  /**\n   * Destroy Keyring\n   *\n   * Some keyrings support a method called `destroy`, that destroys the\n   * keyring along with removing all its event listeners and, in some cases,\n   * clears the keyring bridge iframe from the DOM.\n   *\n   * @param keyring - The keyring to destroy.\n   */\n  async #destroyKeyring(keyring: EthKeyring<Json>) {\n    await keyring.destroy?.();\n  }\n\n  /**\n   * Remove empty keyrings.\n   *\n   * Loops through the keyrings and removes the ones with empty accounts\n   * (usually after removing the last / only account) from a keyring.\n   */\n  async #removeEmptyKeyrings(): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n    const validKeyrings: EthKeyring<Json>[] = [];\n\n    // Since getAccounts returns a Promise\n    // We need to wait to hear back form each keyring\n    // in order to decide which ones are now valid (accounts.length > 0)\n\n    await Promise.all(\n      this.#keyrings.map(async (keyring: EthKeyring<Json>) => {\n        const accounts = await keyring.getAccounts();\n        if (accounts.length > 0) {\n          validKeyrings.push(keyring);\n        } else {\n          await this.#destroyKeyring(keyring);\n        }\n      }),\n    );\n    this.#keyrings = validKeyrings;\n  }\n\n  /**\n   * Checks for duplicate keypairs, using the the first account in the given\n   * array. Rejects if a duplicate is found.\n   *\n   * Only supports 'Simple Key Pair'.\n   *\n   * @param type - The key pair type to check for.\n   * @param newAccountArray - Array of new accounts.\n   * @returns The account, if no duplicate is found.\n   */\n  async #checkForDuplicate(\n    type: string,\n    newAccountArray: string[],\n  ): Promise<string[]> {\n    const accounts = await this.#getAccountsFromKeyrings();\n\n    switch (type) {\n      case KeyringTypes.simple: {\n        const isIncluded = Boolean(\n          accounts.find(\n            (key) =>\n              newAccountArray[0] &&\n              (key === newAccountArray[0] ||\n                key === remove0x(newAccountArray[0])),\n          ),\n        );\n\n        if (isIncluded) {\n          throw new Error(KeyringControllerError.DuplicatedAccount);\n        }\n        return newAccountArray;\n      }\n\n      default: {\n        return newAccountArray;\n      }\n    }\n  }\n\n  /**\n   * Set the `isUnlocked` to true and notify listeners\n   * through the messenger.\n   *\n   * @fires KeyringController:unlock\n   */\n  #setUnlocked(): void {\n    this.#assertControllerMutexIsLocked();\n\n    this.update((state) => {\n      state.isUnlocked = true;\n    });\n    this.messagingSystem.publish(`${name}:unlock`);\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and save the keyrings to state after it, or rollback to their\n   * previous state in case of error.\n   *\n   * @param fn - The function to execute.\n   * @returns The result of the function.\n   */\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  async #persistOrRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withRollback(async ({ releaseLock }) => {\n      const callbackResult = await fn({ releaseLock });\n      // State is committed only if the operation is successful\n      await this.#updateVault();\n\n      return callbackResult;\n    });\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and rollback keyrings and password states in case of error.\n   *\n   * @param fn - The function to execute atomically.\n   * @returns The result of the function.\n   */\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  async #withRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withControllerLock(async ({ releaseLock }) => {\n      const currentSerializedKeyrings = await this.#getSerializedKeyrings();\n      const currentPassword = this.#password;\n\n      try {\n        return await fn({ releaseLock });\n      } catch (e) {\n        // Keyrings and password are restored to their previous state\n        await this.#restoreSerializedKeyrings(currentSerializedKeyrings);\n        this.#password = currentPassword;\n\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Assert that the controller mutex is locked.\n   *\n   * @throws If the controller mutex is not locked.\n   */\n  #assertControllerMutexIsLocked() {\n    if (!this.#controllerOperationMutex.isLocked()) {\n      throw new Error(KeyringControllerError.ControllerLockRequired);\n    }\n  }\n\n  /**\n   * Lock the controller mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This wrapper ensures that each mutable operation that interacts with the\n   * controller and that changes its state is executed in a mutually exclusive way,\n   * preventing unsafe concurrent access that could lead to unpredictable behavior.\n   *\n   * @param fn - The function to execute while the controller mutex is locked.\n   * @returns The result of the function.\n   */\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  async #withControllerLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return withLock(this.#controllerOperationMutex, fn);\n  }\n\n  /**\n   * Lock the vault mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This ensures that each operation that interacts with the vault\n   * is executed in a mutually exclusive way.\n   *\n   * @param fn - The function to execute while the vault mutex is locked.\n   * @returns The result of the function.\n   */\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  async #withVaultLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    this.#assertControllerMutexIsLocked();\n\n    return withLock(this.#vaultOperationMutex, fn);\n  }\n}\n\n/**\n * Lock the given mutex before executing the given function,\n * and release it after the function is resolved or after an\n * error is thrown.\n *\n * @param mutex - The mutex to lock.\n * @param fn - The function to execute while the mutex is locked.\n * @returns The result of the function.\n */\n// TODO: Either fix this lint violation or explain why it's necessary to ignore.\n// eslint-disable-next-line @typescript-eslint/naming-convention\nasync function withLock<T>(\n  mutex: Mutex,\n  fn: MutuallyExclusiveCallback<T>,\n): Promise<T> {\n  const releaseLock = await mutex.acquire();\n\n  try {\n    return await fn({ releaseLock });\n  } finally {\n    releaseLock();\n  }\n}\n\nexport default KeyringController;\n"],"mappings":"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","names":["KeyringTypes","AccountImportStrategy","SignTypedDataVersion"]}