{"version":3,"file":"ERC1155Standard.js","sourceRoot":"","sources":["../../../../src/assets/CollectibleStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,MAAM,iCAAiC,GAAG,YAAY,CAAC;AACvD,MAAM,mCAAmC,GAAG,YAAY,CAAC;AAEzD,MAAa,eAAe;IAA5B;QACE;;;;;WAKG;QACH,yCAAoC,GAAG,CACrC,QAAa,EACK,EAAE;YACpB,OAAO,IAAI,CAAC,yBAAyB,CACnC,QAAQ,EACR,iCAAiC,CAClC,CAAC;QACJ,CAAC,CAAA,CAAC;QAEF;;;;;WAKG;QACH,2CAAsC,GAAG,CACvC,QAAa,EACK,EAAE;YACpB,OAAO,IAAI,CAAC,yBAAyB,CACnC,QAAQ,EACR,mCAAmC,CACpC,CAAC;QACJ,CAAC,CAAA,CAAC;QAEF;;;;;;WAMG;QACH,QAAG,GAAG,CAAO,QAAa,EAAE,OAAe,EAAmB,EAAE;YAC9D,MAAM,EAAE,GAAG,EAAE,GAAG,QAAQ,CAAC,OAAO,CAAC;YACjC,OAAO,MAAM,GAAG,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;QACnC,CAAC,CAAA,CAAC;QAEF;;;;;;;WAOG;QACH,iBAAY,GAAG,CACb,QAAa,EACb,OAAe,EACf,OAAe,EACE,EAAE;YACnB,MAAM,EAAE,SAAS,EAAE,GAAG,QAAQ,CAAC,OAAO,CAAC;YACvC,OAAO,MAAM,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;QAClD,CAAC,CAAA,CAAC;QAEF;;;;;;;;;;;;WAYG;QACH,mBAAc,GAAG,CACf,QAAa,EACb,QAAgB,EAChB,IAAY,EACZ,EAAU,EACV,EAAU,EACV,KAAa,EACE,EAAE;YACjB,MAAM,EAAE,cAAc,EAAE,GAAG,QAAQ,CAAC,OAAO,CAAC;YAC5C,OAAO,MAAM,cAAc,CAAC,QAAQ,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;QAC7D,CAAC,CAAA,CAAC;QAEF;;;;;;WAMG;QACK,8BAAyB,GAAG,CAClC,QAAa,EACb,WAAmB,EACD,EAAE;YACpB,MAAM,EAAE,iBAAiB,EAAE,GAAG,QAAQ,CAAC,OAAO,CAAC;YAC/C,OAAO,iBAAiB,CAAC,WAAW,CAAC,CAAC,IAAI,EAAE,CAAC;QAC/C,CAAC,CAAA,CAAC;IACJ,CAAC;CAAA;AAnGD,0CAmGC","sourcesContent":["const ERC1155_METADATA_URI_INTERFACE_ID = '0x0e89341c';\nconst ERC1155_TOKEN_RECEIVER_INTERFACE_ID = '0x4e2312e0';\n\nexport class ERC1155Standard {\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param contract - ERC1155 asset contract.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  contractSupportsURIMetadataInterface = async (\n    contract: any,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      contract,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param contract - ERC1155 asset contract.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  contractSupportsTokenReceiverInterface = async (\n    contract: any,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      contract,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param contract - ERC1155 asset contract.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  uri = async (contract: any, tokenId: string): Promise<string> => {\n    const { uri } = contract.methods;\n    return await uri(tokenId).call();\n  };\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contract - ERC1155 asset contract.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  getBalanceOf = async (\n    contract: any,\n    address: string,\n    tokenId: string,\n  ): Promise<number> => {\n    const { balanceOf } = contract.methods;\n    return await balanceOf(address, tokenId).call();\n  };\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param contract - ERC1155 asset contract.\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  transferSingle = async (\n    contract: any,\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> => {\n    const { transferSingle } = contract.methods;\n    return await transferSingle(operator, from, to, id, value);\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param contract - ERC1155 asset contract.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private contractSupportsInterface = async (\n    contract: any,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const { supportsInterface } = contract.methods;\n    return supportsInterface(interfaceId).call();\n  };\n}\n"]}