{"version":3,"file":"CollectibleMintingController.js","sourceRoot":"","sources":["../../src/assets/CollectibleMintingController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,mCAAsC;AACtC,gDAAwB;AACxB,0EAAkE;AAClE,0DAAsD;AACtD,sDAA0E;AAE1E,4CAMsB;AACtB,kCAAsC;AA4DtC,MAAa,4BAA6B,SAAQ,+BAGjD;IA2IC;;;;;;;;;OASG;IACH,YACE,EACE,oBAAoB,EACpB,cAAc,EACd,cAAc,GAOf,EACD,MAA4B,EAC5B,KAA6C;QAE7C,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAzCvB;;WAEG;QACH,QAAG,GAAG,IAAI,qBAAY,EAAE,CAAC;QAEzB;;WAEG;QACH,SAAI,GAAG,8BAA8B,CAAC;QAkCpC,IAAI,CAAC,aAAa,GAAG;YACnB,WAAW,EAAE,mBAAO;YACpB,eAAe,EAAE,EAAE;YACnB,OAAO,EAAE,EAAE;YACX,WAAW,EAAE,oCAAwB;YACrC,iBAAiB,EAAE,IAAI;YACvB,QAAQ,EAAE,SAAS;SACpB,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG;YAClB,OAAO,EAAE,UAAU;SACpB,CAAC;QACF,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,oBAAoB,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE;YACpC,MAAM,EAAE,OAAO,EAAE,GAAG,QAAQ,CAAC;YAC7B,IAAI,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAvLD,iCAAiC;IACjC,gCAAgC;IAChC,kBAAkB;IAClB,oBAAoB;IACpB,qBAAqB;IACrB,sBAAsB;IACtB,mCAAmC;IACnC,iCAAiC;IACjC,OAAO;IACP,qBAAqB;IACrB,uBAAuB;IACvB,kBAAkB;IAClB,4BAA4B;IAC5B,OAAO;IAEP,uEAAuE;IACvE,IAAI;IAEE,0BAA0B,CAAC,QAAgB;;YAC/C,wDAAwD;YACxD,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YACtB,oCAAoC;YACpC,mOAAmO;YACnO,uBAAuB;YACvB,gEAAgE;YAChE,0BAA0B;YAC1B,6BAA6B;YAC7B,wBAAwB;YACxB,0EAA0E;YAC1E,gBAAgB;YAChB,aAAa;YACb,6BAA6B;YAC7B,KAAK;YACL,sEAAsE;QACxE,CAAC;KAAA;IAEK,WAAW,CAAC,QAAgB,EAAE,YAA0B;;YAC5D,MAAM,EAAE,WAAW,EAAE,eAAe,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;YACrD,MAAM,EAAE,SAAS,EAAE,uBAAuB,EAAE,IAAI,EAAE,GAAG,YAAY,CAAC;YAClE,IACE,WAAW,KAAK,mBAAO;gBACvB,WAAW,KAAK,mBAAO;gBACvB,WAAW,KAAK,mBAAO,EACvB;gBACA,MAAM,IAAI,KAAK,CACb,WAAW,WAAW,0DAA0D,CACjF,CAAC;aACH;YACD,MAAM,QAAQ,GAAU;gBACtB,EAAE,OAAO,EAAE,eAAe,EAAE,KAAK,EAAE,uBAAuB,EAAE;aAC7D,CAAC;YACF,MAAM,iBAAiB,GAAG,sCAA0B,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC;YAC1E,MAAM,GAAG,GAAG,wCAAgB,CAC1B,IAAI,4BAAY,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,EACrC,sCAA0B,CAAC,WAAW,CAAC,CAAC,GAAU,CACnD,CAAC;YACF,MAAM,aAAa,GAAQ,MAAM,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAC1E;gBACE,UAAU,EAAE,iBAAiB;aAC9B,CACF,CAAC;YAEF,OAAO,MAAM,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC;gBACxB,UAAU,EAAE,aAAa;gBACzB,GAAG,EAAE,QAAQ;gBACb,QAAQ;gBACR,SAAS;gBACT,IAAI;aACL,CAAC,CAAC;QACL,CAAC;KAAA;IAED;;;;;OAKG;IACG,gBAAgB,CAAC,IAAgC;;YACrD,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE,CAAC;YAChC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;YAE9C,MAAM,eAAe,GAAG,MAAM,kBAAW,CACvC,wCAAwC,EACxC;gBACE,MAAM,EAAE,MAAM;gBACd,IAAI,EAAE,QAAQ;aACf,CACF,CAAC;YAEF,OAAO,eAAe,CAAC;QACzB,CAAC;KAAA;IAEK,IAAI,CACR,QAAgB,EAChB,OAAuB,EACvB,YAA2B;;YAE3B,IAAI,OAAO,CAAC,OAAO,KAAK,SAAS,IAAI,YAAY,EAAE;gBACjD,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;aAChD;iBAAM;gBACL,MAAM,IAAI,CAAC,0BAA0B,CAAC,QAAQ,CAAC,CAAC;aACjD;YAED,SAAS;YACT,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;YAC5B,IAAI,CAAC,cAAc,CAAC,EAAS,CAAC,CAAC;QACjC,CAAC;KAAA;IAED;;;;OAIG;IACH,kBAAkB,CAAC,eAAuB;QACxC,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;IACzC,CAAC;IAsED;;;;OAIG;IACH,IAAI,QAAQ,CAAC,QAAa;QACxB,IAAI,CAAC,IAAI,GAAG,IAAI,cAAI,CAAC,QAAQ,CAAC,CAAC;QAC/B,OAAO,CAAC,GAAG,CAAC,qCAAqC,EAAE,QAAQ,CAAC,CAAC;IAC/D,CAAC;IAED,IAAI,QAAQ;QACV,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACpD,CAAC;CACF;AA1MD,oEA0MC;AAED,kBAAe,4BAA4B,CAAC","sourcesContent":["import { EventEmitter } from 'events';\nimport Web3 from 'web3';\nimport { createRaribleSdk } from '@rarible/protocol-ethereum-sdk';\nimport { Web3Ethereum } from '@rarible/web3-ethereum';\nimport { BaseController, BaseConfig, BaseState } from '../BaseController';\nimport type { NetworkState, NetworkType } from '../network/NetworkController';\nimport {\n  MAINNET,\n  RINKEBY,\n  ROPSTEN,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721_RARIBLE_COLLECTIONS,\n} from '../constants';\nimport { handleFetch } from '../util';\nimport type { TransactionController } from '../transaction/TransactionController';\nimport type { CollectiblesController } from './CollectiblesController';\n\nexport interface MintingOptions {\n  nftType: 'rarible' | 'custom';\n}\n\n/**\n * @type NftMetaData\n *\n * Collectible creator object coming from OpenSea api\n * @property name - name entered for nft\n * @property description - description entered for nft\n * @property image - IPFS hash of image (e.g. ipfs://QmYMuoAgKcqvd34rNU2WpoQunLj3WsAPWn9xUokiyposdC)\n */\nexport interface NftMetaData {\n  name: string;\n  description: string;\n  image: string;\n}\n\n/**\n * @type NftMediaData\n *\n * Collectible creator object coming from OpenSea api\n * @property name - name of media with extension\n * @property type - post file type (e.g. image/jpeg)\n * @property uri - path of image to be uploaded to IPFS\n */\nexport interface NftMediaData {\n  name: string | 'nft';\n  type: string;\n  uri: string;\n}\n\nexport interface RaribleProps {\n  royalties: any[];\n  creatorProfitPercentage: number;\n  lazy: boolean;\n}\n\nexport interface CollectibleMintingMetaData {\n  name: string;\n  description: string;\n  image: string;\n  attributes: any;\n}\nexport interface CollectibleMintingControllerConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n  chainId: string;\n  ipfsGateway: string;\n  useIPFSSubdomains: boolean;\n  provider: any;\n}\nexport interface CollectibleMintingControllerState extends BaseState {\n  minting: 'awaiting' | 'started' | 'processing' | 'complete';\n}\n\nexport class CollectibleMintingController extends BaseController<\n  CollectibleMintingControllerConfig,\n  CollectibleMintingControllerState\n> {\n  // private async deployNewERC721(\n  //   smartContractBytecode: any,\n  //   name: string,\n  //   symbol: string,\n  // ): Promise<void> {\n  //   const payload = {\n  //     data: smartContractBytecode,\n  //     arguments: [name, symbol],\n  //   };\n  //   const params = {\n  //     from: 'address',\n  //     gas: '0x0',\n  //     gasPrice: '0x3DFB2E',\n  //   };\n\n  //   this.addTransaction({ ...params, ...payload }, 'Contract Deploy');\n  // }\n\n  async customMintWithMMCollection(tokenUri: string) {\n    // ipfs://QmRUA2oJUceyGLxh6yVYQodL5smkP2Xr1u9eHciTM2xLMd\n    console.log(tokenUri);\n    // // Logic to covert metadat to hex\n    // 0x60806040526040518060400160405280600581526020017f2e6a736f6e000000000000000000000000000000000000000000000000000000815250600c90805190602001906200005192919062000de6565b5066470de4df820000600d55612710600e556001600f556000601060..\n    // const txParams = {};\n    // txParams.from = '0x260416FDEc04AB146464aF833E63835a704C4860';\n    // txParams.value = '0x0';\n    // txParams.gas = '0x3DFB2E';\n    // txParams.data = data;\n    // const { transactionMeta } = await TransactionController.addTransaction(\n    //     txParams,\n    //     'nft',\n    //     WalletDevice.MM_MOBILE\n    // );\n    // await TransactionController.approveTransaction(transactionMeta.id);\n  }\n\n  async raribleMint(tokenUri: string, raribleProps: RaribleProps) {\n    const { networkType, selectedAddress } = this.config;\n    const { royalties, creatorProfitPercentage, lazy } = raribleProps;\n    if (\n      networkType !== MAINNET &&\n      networkType !== RINKEBY &&\n      networkType !== ROPSTEN\n    ) {\n      throw new Error(\n        `Network ${networkType} not support by Rarible. Use mainnet, rinkeby or ropsten`,\n      );\n    }\n    const creators: any[] = [\n      { account: selectedAddress, value: creatorProfitPercentage },\n    ];\n    const collectionAddress = ERC721_RARIBLE_COLLECTIONS[networkType].address;\n    const sdk = createRaribleSdk(\n      new Web3Ethereum({ web3: this.web3 }),\n      ERC721_RARIBLE_COLLECTIONS[networkType].env as any,\n    );\n    const nftCollection: any = await sdk.apis.nftCollection.getNftCollectionById(\n      {\n        collection: collectionAddress,\n      },\n    );\n\n    return await sdk.nft.mint({\n      collection: nftCollection,\n      uri: tokenUri,\n      creators,\n      royalties,\n      lazy,\n    });\n  }\n\n  /**\n   * Method to add and pin data to IPFS.\n   *\n   * @param data - data objects to be posted on IPFS\n   * @returns IPFS response\n   */\n  async uploadDataToIpfs(data: NftMediaData | NftMetaData): Promise<Response> {\n    const formData = new FormData();\n    formData.append('file', JSON.stringify(data));\n\n    const ipfsAddResponse = await handleFetch(\n      'https://ipfs.infura.io:5001/api/v0/add',\n      {\n        method: 'POST',\n        body: formData,\n      },\n    );\n\n    return ipfsAddResponse;\n  }\n\n  async mint(\n    tokenUri: string,\n    options: MintingOptions,\n    raribleProps?: RaribleProps,\n  ) {\n    if (options.nftType === 'rarible' && raribleProps) {\n      await this.raribleMint(tokenUri, raribleProps);\n    } else {\n      await this.customMintWithMMCollection(tokenUri);\n    }\n\n    // REMOVE\n    this.addCollectible('', '');\n    this.addTransaction({} as any);\n  }\n\n  /**\n   * Sets an Infura Project ID to POST collectible information.\n   *\n   * @param infuraProjectId - Infura Project ID\n   */\n  setInfuraProjectId(infuraProjectId: string) {\n    this.infuraProjectId = infuraProjectId;\n  }\n\n  /**\n   * Optional Infura Project ID to use with infura\n   */\n  infuraProjectId?: string;\n\n  /**\n   * EventEmitter instance used to listen to specific transactional events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'CollectibleMintingController';\n\n  private addCollectible: CollectiblesController['addCollectible'];\n\n  private addTransaction: TransactionController['addTransaction'];\n\n  private web3: any;\n\n  /**\n   * Creates the CollectibleMintingController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.addCollectible - Allows the controlelr to add a collectible to collectible controller.\n   * @param options.addTransaction - Allows the controler to add a transaction to transaction controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onNetworkStateChange,\n      addCollectible,\n      addTransaction,\n    }: {\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      addCollectible: CollectiblesController['addCollectible'];\n      addTransaction: TransactionController['addTransaction'];\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<CollectibleMintingController>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      networkType: MAINNET,\n      selectedAddress: '',\n      chainId: '',\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      useIPFSSubdomains: true,\n      provider: undefined,\n    };\n\n    this.defaultState = {\n      minting: 'awaiting',\n    };\n    this.initialize();\n    onNetworkStateChange(({ provider }) => {\n      const { chainId } = provider;\n      this.configure({ chainId });\n    });\n    this.addCollectible = addCollectible;\n    this.addTransaction = addTransaction;\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * @property provider - Provider used to create a new underlying Web3 instance\n   */\n  set provider(provider: any) {\n    this.web3 = new Web3(provider);\n    console.log('New provider created for provider: ', provider);\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n}\n\nexport default CollectibleMintingController;\n"]}